<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GTFS Fusion</title>
  <script src="vendor/libs/fflate/umd/index.js"></script>
  <script>
    if (typeof exports !== 'undefined' && exports.unzip) {
      window.fflate = exports;
    }
  </script>

  <script src="vendor/libs/zip.js/dist/zip.js"></script>

  <link rel="stylesheet" href="vendor/leaflet/leaflet.css">
  <script src="vendor/leaflet/leaflet.js"></script>

  <link rel="stylesheet" href="vendor/markercluster/MarkerCluster.css">
  <link rel="stylesheet" href="vendor/markercluster/MarkerCluster.Default.css">
  <script src="vendor/markercluster/leaflet.markercluster.js"></script>
  <link rel="stylesheet" href="styles/app.css">
<script src="src/utils/utils.js"></script>
</head>

<body>
  <div id="root"></div>
  <script>
// ═══════════════════════════════════════════════════════════════
// GTFS Fusion - Single Page Application
// ═══════════════════════════════════════════════════════════════
// For architectural documentation, see DOCUMENTATION.md
// For refactoring notes, see REFACTORING.md
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// 1. CONSTANTS & CONFIGURATION
// ═══════════════════════════════════════════════════════════════
console.log('Utils in index:', window.Utils);
const DAY_NAMES = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
const SUNDAY = 0, WEDNESDAY = 3, SATURDAY = 6;
const icons = { upload: (size=24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12" /></svg>` };
    const VIEW = {
      LOADING: 'loading',
      ERROR: 'error',
      UPLOAD: 'upload',
      ROUTES_LIST: 'routes_list',
      STOPS_LIST: 'stops_list',
      STOP_DETAIL: 'stop_detail',
      ROUTE_TIMETABLE: 'route_timetable'
    };

    const KEY_ALIAS = {
      'route id':'route_id','routeid':'route_id','route_id':'route_id','route short name':'route_short_name','route_short_name':'route_short_name',
      'route long name':'route_long_name','route_long_name':'route_long_name','trip id':'trip_id','tripid':'trip_id','trip_id':'trip_id',
      'service id':'service_id','serviceid':'service_id','service_id':'service_id','stop id':'stop_id','stopid':'stop_id','stop_id':'stop_id',
      'stop sequence':'stop_sequence','stop_sequence':'stop_sequence','arrival time':'arrival_time','arrival_time':'arrival_time',
      'departure time':'departure_time','departure_time':'departure_time','pickup type':'pickup_type','pickup_type':'pickup_type',
      'drop off type':'drop_off_type','drop_off_type':'drop_off_type','stop lat':'stop_lat','stop_lat':'stop_lat',
      'stop lon':'stop_lon','stop_lon':'stop_lon','direction id':'direction_id','direction_id':'direction_id',
      'trip headsign':'trip_headsign','trip_headsign':'trip_headsign','start date':'start_date','start_date':'start_date',
      'end date':'end_date','end_date':'end_date','monday':'monday','tuesday':'tuesday','wednesday':'wednesday','thursday':'thursday',
      'friday':'friday','saturday':'saturday','sunday':'sunday','exception type':'exception_type','exception_type':'exception_type','date':'date'
    };

    const ROUTE_TYPE_META_BASIC = {
      0: { label: 'Tram', color: '#f59e0b', weight: 3, iconSvg: 'M6 3v13' },
      1: { label: 'Subway', color: '#ef4444', weight: 3, iconSvg: 'M3 6h18v12H3z' },
      2: { label: 'Rail', color: '#10b981', weight: 3, iconSvg: 'M4 6h16' },
      3: { label: 'Bus', color: '#2563eb', weight: 3, iconSvg: 'M5 6h14v8H5z' },
      4: { label: 'Ferry', color: '#0ea5a4', weight: 3, iconSvg: 'M2 16s3-4 10-4 10 4 10 4' },
      5: { label: 'Cable car', color: '#7c3aed', weight: 3, iconSvg: 'M4 6l8-4 8 4' },
      6: { label: 'Gondola', color: '#06b6d4', weight: 3, iconSvg: 'M4 6c4 0 8-4 12 0' },
      7: { label: 'Funicular', color: '#f97316', weight: 3, iconSvg: 'M3 18h18' },
      11:{ label: 'Trolleybus', color: '#8b5cf6', weight: 3, iconSvg: 'M4 6h16' },
      12:{ label: 'Monorail', color: '#06b6d4', weight: 3, iconSvg: 'M2 12h20' }
    };

    const ROUTE_TYPE_META_EXTENDED = {
100: { label: 'Railway service', color:'#10b981', weight:4 },          // ← ZMIEŃ
101: { label: 'High speed rail service', color:'#10b981', weight:4 },  // ← ZMIEŃ
102: { label: 'Long distance trains', color:'#10b981', weight:4 },     // ← ZMIEŃ
103: { label: 'Inter regional rail service', color:'#10b981', weight:4 }, // ← ZMIEŃ
      104: { label: 'Car transport rail service', color:'#6b7280', weight:3 }, 105: { label: 'Sleeper rail service', color:'#6b7280', weight:3 },
      106: { label: 'Regional rail service', color:'#059669', weight:4 }, 107: { label: 'Tourist railway service', color:'#f59e0b', weight:3 },
      108: { label: 'Rail shuttle (within complex)', color:'#9ca3af', weight:2 }, 109: { label: 'Suburban railway', color:'#059669', weight:4 },
      110: { label: 'Replacement rail service', color:'#9ca3af', weight:3 }, 111: { label: 'Special rail service', color:'#6b7280', weight:3 },
      112: { label: 'Lorry transport rail service', color:'#6b7280', weight:3 },
      113: { label: 'All rail services', color:'#10b981', weight:4 }, 
      114: { label: 'Cross-country rail service', color:'#10b981', weight: 4 }, 115: { label: 'Vehicle transport rail service', color:'#6b7280', weight:3 },
      116: { label: 'Rack and pinion railway', color:'#f97316', weight:3 }, 117: { label: 'Additional rail service', color:'#0b74de', weight:3 },

      200: { label: 'Coach service', color:'#1f2937', weight:3 }, 201: { label: 'International coach service', color:'#374151', weight:3 },
      202: { label: 'National coach service', color:'#374151', weight:3 }, 203: { label: 'Shuttle coach service', color:'#6b7280', weight:3 },
      204: { label: 'Regional coach service', color:'#374151', weight:3 }, 205: { label: 'Special coach service', color:'#6b7280', weight:3 },
      206: { label: 'Sightseeing coach service', color:'#f59e0b', weight:3 }, 207: { label: 'Tourist coach service', color:'#f59e0b', weight:3 },
      208: { label: 'Commuter coach service', color:'#2563eb', weight:3 }, 209: { label: 'All coach services', color:'#1f2937', weight:3 },

      300: { label: 'Suburban railway service', color:'#059669', weight:3 }, 400: { label: 'Urban railway service', color:'#ef4444', weight:3 },
      401: { label: 'Metro service', color:'#ef4444', weight:3 }, 402: { label: 'Underground service', color:'#ef4444', weight:3 },
      403: { label: 'Urban railway service (other)', color:'#ef4444', weight:3 }, 404: { label: 'All urban railway services', color:'#ef4444', weight:3 },
      405: { label: 'Monorail', color:'#7c3aed', weight:3 },

      500: { label: 'Water transport service', color:'#0ea5a4', weight:3 }, 501: { label: 'International car ferry service', color:'#0ea5a4', weight:3 },
      502: { label: 'National car ferry service', color:'#0ea5a4', weight:3 }, 503: { label: 'Regional car ferry service', color:'#0ea5a4', weight:3 },
      504: { label: 'Local car ferry service', color:'#0ea5a4', weight:3 }, 505: { label: 'International passenger ferry service', color:'#0ea5a4', weight:3 },
      506: { label: 'National passenger ferry service', color:'#0ea5a4', weight:3 }, 507: { label: 'Regional passenger ferry service', color:'#0ea5a4', weight:3 },
      508: { label: 'Local passenger ferry service', color:'#0ea5a4', weight:3 }, 509: { label: 'Post boat service', color:'#0ea5a4', weight:3 },
      510: { label: 'Water taxi', color:'#0ea5a4', weight:3 }, 511: { label: 'River bus service', color:'#0ea5a4', weight:3 },
      512: { label: 'Scheduled ferry service', color:'#0ea5a4', weight:3 }, 513: { label: 'Shuttle ferry service', color:'#0ea5a4', weight:3 },
      514: { label: 'All water transport services', color:'#0ea5a4', weight:3 },

      1100: { label: 'Air service', color:'#6b7280', weight:2 }, 1101: { label: 'International air service', color:'#6b7280', weight:2 },
      1102: { label: 'Domestic air service', color:'#6b7280', weight:2 }, 1103: { label: 'Intercontinental air service', color:'#6b7280', weight:2 },
      1104: { label: 'Domestic scheduled air service', color:'#6b7280', weight:2 }, 1105: { label: 'Shuttle air service', color:'#6b7280', weight:2 },
      1106: { label: 'Intercontinental charter air service', color:'#6b7280', weight:2 }, 1107: { label: 'International charter air service', color:'#6b7280', weight:2 },
      1108: { label: 'Round-trip charter air service', color:'#6b7280', weight:2 }, 1109: { label: 'Sightseeing air service', color:'#f59e0b', weight:2 },
      1110: { label: 'Helicopter air service', color:'#6b7280', weight:2 }, 1111: { label: 'Domestic charter air service', color:'#6b7280', weight:2 },
      1112: { label: 'Schengen-area air service', color:'#6b7280', weight:2 }, 1113: { label: 'Airship service', color:'#6b7280', weight:2 },
      1114: { label: 'All air services', color:'#6b7280', weight:2 },

      700: { label: 'Bus service', color:'#2563eb', weight:3 }, 701: { label: 'Regional bus service', color:'#2563eb', weight:3 },
      702: { label: 'Express bus service', color:'#1d4ed8', weight:3 }, 703: { label: 'Stopping bus service', color:'#2563eb', weight:3 },
      704: { label: 'Local bus service', color:'#2563eb', weight:3 }, 705: { label: 'Night bus service', color:'#0f172a', weight:3 },
      706: { label: 'Post bus service', color:'#6b7280', weight:3 }, 707: { label: 'Special needs bus', color:'#6b7280', weight:3 },
      708: { label: 'Mobility bus service', color:'#6b7280', weight:3 }, 709: { label: 'Mobility bus for registered disabled', color:'#6b7280', weight:3 },
      710: { label: 'Sightseeing bus', color:'#f59e0b', weight:3 }, 711: { label: 'Shuttle bus', color:'#6b7280', weight:3 },
      712: { label: 'School bus', color:'#6b7280', weight:3 }, 713: { label: 'School and public service bus', color:'#6b7280', weight:3 },
      714: { label: 'Rail replacement bus service', color:'#9ca3af', weight:3 }, 715: { label: 'Demand and response bus service', color:'#6b7280', weight:3 },
      716: { label: 'All bus services', color:'#2563eb', weight:3 },

      800: { label: 'Trolleybus service', color:'#8b5cf6', weight:3 },

      900: { label: 'Tram service', color:'#f59e0b', weight:3 }, 901: { label: 'City tram service', color:'#f59e0b', weight:3 },
      902: { label: 'Local tram service', color:'#f59e0b', weight:3 }, 903: { label: 'Regional tram service', color:'#f59e0b', weight:3 },
      904: { label: 'Sightseeing tram service', color:'#f59e0b', weight:3 }, 905: { label: 'Shuttle tram service', color:'#f59e0b', weight:3 },
      906: { label: 'All tram services', color:'#f59e0b', weight:3 },

      1300: { label: 'Telecabin / cable car', color:'#7c3aed', weight:3 }, 1301: { label: 'Gondola lift', color:'#06b6d4', weight:3 }
    };

const CANONICAL_CATEGORIES = {
  metro: { label: 'Metro', order: 10 },
  tram: { label: 'Tramwaj', order: 20 },
  trolleybus: { label: 'Trolejbus', order: 30 },
  bus: { label: 'Autobus', order: 40 },
  rail: { label: 'Kolej', order: 50 },
  other: { label: 'Inne', order: 60 },
  coach: { label: 'Autokar', order: 70 },
  ferry: { label: 'Promy', order: 80 },
  air: { label: 'Samolot', order: 90 },
  cable: { label: 'Koleje liniowe', order: 100 },
  gondola: { label: 'Gondola', order: 110 },
  funicular: { label: 'Funikular', order: 120 },
  monorail: { label: 'Monorail', order: 130 }
};
// --- END: Canonical route type collector

// ═══════════════════════════════════════════════════════════════
// 2. STATE MANAGEMENT
// ═══════════════════════════════════════════════════════════════

let lastRenderTime = 0;
const RENDER_THROTTLE_MS = 200; // Max 5 FPS

let state = {
  gtfsData: null,
  selectedRoute: null,
  loading: false,
  loadingStep: '',
  loadingProgress: 0,
  loadingProgressPercent: 0,
  error: '',
  selectedDate: '',
  availableDates: [],
  selectedDirection: '0',
  selectedVariant: 1,
  selectedVariantFilter: 0,  // 0 = wszystkie, 1+ = specific variant
  showAllTrips: false,
  threshold: 10,
  currentWorker: null,
  // UI: group mode for routes list - 'route_id' or 'service_type'
  routeGroupMode: 'service_type',
  routesOptionsOpen: false,
  routesOptionsListenerAttached: false,
  // custom route type map can be injected/extended
  customRouteTypeMap: {},

  // NOWE:
  selectedRouteGroup: null,   // obecna logiczna grupa linii (dla listy linii)
  routeProfiles: {},          // profile tras (graf/core) per logical group + direction
  showStopsView: false,       // tryb „przystanki" vs „linie"
  routesListScrollPosition: 0, // scroll position for ROUTES_LIST view

  selectedStop: null,
  stopViewFilteredRoutes: [],
  
  // Stops list view state
  expandedStopGroup: null,
  stopsListMapState: null,
  stopsListSearchQuery: '',
  
  // Pagination state for stops list
  stopsListPage: 1,
  stopsListPageSize: 50,
  
  // Virtual scrolling state for large stop lists
  virtualListStartIndex: 0,
  virtualListItemHeight: 68, // px - height of stop-group element

  // Map layers for stop detail view
  stopDetailMapLayers: {},
  stopDetailMapInitialized: false,
  stopDetailMapInstance: null,
  stopDetailDepartures: [], // All departures for current stop

  // Cached timetable data for modal
  currentTimetableData: {
    allTrips: [],           // wszystkie trips (włącznie z ukrytymi)
    stopDepartures: {}      // mapa: stop_id -> lista odjazdów z trip_id i czasem
  },

  // Canonical master lists: stable row order per route/group + direction
  // Structure: canonicalMasterLists[key][direction] = { rows: [...], nodeTypeMap: {...} }
  // Rows are built from ALL trips (no date filter) and never reordered.
  // Only visibility is filtered at render time.
  canonicalMasterLists: {},

  // Column order cache: trips order per (key, dir, date, showAllTrips)
  // Structure: columnOrderCache[cacheKey] = [trip_id, ...]
  columnOrderCache: {},
  
  // Performance metrics from last load
  lastLoadMetrics: null
};

let stopsSearchIndex = null;
let cachedGroupsArray = null;
let lastStopsDataHash = null;
let stationNameToIdCache = null;

// Performance optimization: Shape simplification cache (lazy computation)
const simplifiedShapesCache = {};

// Performance optimization: Time parsing cache
const TIME_PARSE_CACHE = new Map();

// IndexedDB cache: preloaded stop_times for current route
let stopTimesCache = {};
let stopTimesCacheRouteKey = null;

// ═══════════════════════════════════════════════════════════════
// WORKER ORCHESTRATION LAYER (WRAPS EXISTING PARSERS)
// ═══════════════════════════════════════════════════════════════

const WORKER_THRESHOLD_MB = 25; // Use workers if file > 25MB
const WORKER_POOL_SIZE = 4;
const PROGRESS_THROTTLE_MS = 100; // 10 FPS
const PARALLEL_CHUNK_SIZE = 5 * 1024 * 1024; // 5MB chunks for parallel processing

// IndexedDB configuration for large feeds
const STOP_TIMES_DB_THRESHOLD = 12_000_000; // 12 million rows - switch to IndexedDB
let currentDbName = null; // Global DB name for cleanup

// Optional single worker (jeśli gdzieś jeszcze używany bez poola)
const worker = new Worker('src/worker.js');

worker.addEventListener('message', e => {
  if (e.data?.type === 'alive') {
    console.log('[Worker] alive');
  }
});

// Worker pool manager
class WorkerPool {
  constructor(size = WORKER_POOL_SIZE) {
    this.workers = [];
    this.queue = [];

    for (let i = 0; i < size; i++) {
      this.workers.push({
        id: i,
        worker: new Worker('src/worker.js'),
        busy: false
      });
    }
  }

  execute(task) {
    return new Promise((resolve, reject) => {
      const slot = this.workers.find(w => !w.busy);

      if (slot) {
        this.run(slot, task, resolve, reject);
      } else {
        this.queue.push({ task, resolve, reject });
      }
    });
  }
  
terminate() {
  for (const slot of this.workers) {
    slot.worker.terminate();
  }
  this.workers.length = 0;
  this.queue.length = 0;
}

  run(slot, task, resolve, reject) {
    slot.busy = true;

    const onMessage = (e) => {
      const msg = e.data;

      if (!msg || typeof msg !== 'object') {
        return;
      }

      if (msg.type === 'result') {
        cleanup();
        resolve(msg.data);
        this.next(slot);
      } else if (msg.type === 'error') {
        cleanup();
        reject(new Error(msg.error || 'Worker error'));
        this.next(slot);
      }
      // inne message (progress itp.) ignorujemy
    };

    const onError = (err) => {
      cleanup();
      reject(err);
      this.next(slot);
    };

    const cleanup = () => {
      slot.worker.removeEventListener('message', onMessage);
      slot.worker.removeEventListener('error', onError);
      slot.busy = false;
    };

    slot.worker.addEventListener('message', onMessage);
    slot.worker.addEventListener('error', onError);

    try {
      slot.worker.postMessage(task);
    } catch (err) {
      cleanup();
      reject(err);
      this.next(slot);
    }
  }

  next(slot) {
    if (this.queue.length === 0) return;
    const next = this.queue.shift();
    this.run(slot, next.task, next.resolve, next.reject);
  }
}

let globalWorkerPool = null;

function ensureWorkerPool() {
  if (!globalWorkerPool) {
    globalWorkerPool = new WorkerPool(WORKER_POOL_SIZE);
  }
  return globalWorkerPool;
}

function canUseWorkers() {
  return (
    globalWorkerPool &&
    typeof globalWorkerPool.execute === 'function'
  );
}

function parseStopTimesChunk(text, headers) {
  const index = Object.create(null);

  const get = (cols, i) =>
    i >= 0 && i < cols.length
      ? cols[i].replace(/^"|"$/g, '').trim()
      : '';

  let start = 0;

  for (let i = 0; i <= text.length; i++) {
    if (i === text.length || text.charCodeAt(i) === 10) {
      const line = text.slice(start, i);
      start = i + 1;

      if (!line) continue;

      const cols = line.split(',');

      const tripId = get(cols, headers.tripIdx);
      const stopId = get(cols, headers.stopIdx);
      if (!tripId || !stopId) continue;

      if (!index[tripId]) index[tripId] = [];

      index[tripId].push({
        stop_id: stopId,
        arrival_time: get(cols, headers.arrIdx),
        departure_time: get(cols, headers.depIdx),
        stop_sequence: parseInt(get(cols, headers.seqIdx) || '0', 10),
        pickup_type: get(cols, headers.pickupIdx) || '0',
        drop_off_type: get(cols, headers.dropoffIdx) || '0'
      });
    }
  }

  return index;
}

// Smart routing: workers for large files, sync for small
async function parseWithStrategy(text, fileName, onProgress) {
  const fileSize = new Blob([text]).size;
  const fileSizeMB = fileSize / (1024 * 1024);
  const fileType = fileName.replace('.txt', '');

  // === SYNC MODE ===
  if (fileSizeMB < WORKER_THRESHOLD_MB) {
    console.log('[Parse] ' + fileName + ': sync mode (' + fileSizeMB.toFixed(1) + 'MB)');

    if (fileType === 'stop_times') {
      const lines = text.split('\n');
      if (!lines.length || !lines[0]?.trim()) {
        return Object.create(null);
      }

      const headerLine = lines[0].replace(/^\uFEFF/, '');
      const rawHeaders = headerLine.split(',').map(h => h.replace(/^"|"$/g, '').trim());

      const headers = {
        tripIdx: -1,
        stopIdx: -1,
        seqIdx: -1,
        arrIdx: -1,
        depIdx: -1,
        pickupIdx: -1,
        dropoffIdx: -1
      };

      rawHeaders.forEach((h, i) => {
        const normalized = Utils.normalizeKey(h);
        if (normalized === 'trip_id') headers.tripIdx = i;
        else if (normalized === 'stop_id') headers.stopIdx = i;
        else if (normalized === 'stop_sequence') headers.seqIdx = i;
        else if (normalized === 'arrival_time') headers.arrIdx = i;
        else if (normalized === 'departure_time') headers.depIdx = i;
        else if (normalized === 'pickup_type') headers.pickupIdx = i;
        else if (normalized === 'drop_off_type') headers.dropoffIdx = i;
      });

      const bodyText = lines.slice(1).join('\n');
      return parseStopTimesChunk(bodyText, headers);
    }

    if (fileType === 'shapes') {
      return parseShapesChunk(text);
    }

    return parseCSV(text);
  }

  // === PARALLEL MODE ===
  console.log('[Parse] ' + fileName + ': candidate for worker mode (' + fileSizeMB.toFixed(1) + 'MB)');

  try {
    ensureWorkerPool();

    if (!canUseWorkers()) {
      console.warn('[Parse] Worker pool unavailable, forcing sync mode');
      return parseCSV(text);
    }

    if (fileType === 'stop_times') {
      return await parseStopTimesParallel(text, onProgress);
    }

    if (fileType === 'shapes') {
      return await parseShapesParallel(text, onProgress);
    }

    const result = await globalWorkerPool.execute({
      type: 'parse',
      text,
      fileType
    });

    console.log('[Parse] ' + fileName + ': ' + result.length.toLocaleString() + ' records');
    return result;

  } catch (error) {
    console.error('[Parse] ' + fileName + ': worker failed, falling back to sync', error);
    return parseCSV(text);
  }
}

// Parallel stop_times parsing using worker pool
async function parseStopTimesParallel(text, onProgress) {
  const startTime = performance.now();
  
    if (!globalWorkerPool) {
    globalWorkerPool = new WorkerPool(WORKER_POOL_SIZE);
  }
  
  // Parse header first
  const lines = text.split('\n');
  const headerLine = lines[0].replace(/^\uFEFF/, '');
  const rawHeaders = headerLine.split(',').map(h => h.replace(/^"|"$/g, '').trim());
  
  const headers = {
    tripIdx: -1,
    stopIdx: -1,
    seqIdx: -1,
    arrIdx: -1,
    depIdx: -1,
    pickupIdx: -1,
    dropoffIdx: -1
  };
  
  rawHeaders.forEach((h, i) => {
    const normalized = Utils.normalizeKey(h);
    if (normalized === 'trip_id') headers.tripIdx = i;
    else if (normalized === 'stop_id') headers.stopIdx = i;
    else if (normalized === 'stop_sequence') headers.seqIdx = i;
    else if (normalized === 'arrival_time') headers.arrIdx = i;
    else if (normalized === 'departure_time') headers.depIdx = i;
    else if (normalized === 'pickup_type') headers.pickupIdx = i;
    else if (normalized === 'drop_off_type') headers.dropoffIdx = i;
  });
  
  // Count total rows (excluding header and empty lines)
  let estimatedRowCount = 0;
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].trim()) estimatedRowCount++;
  }
  
  console.log('[Parse] stop_times: estimated ' + estimatedRowCount.toLocaleString() + ' rows');
  
  // Decision: Use IndexedDB for large feeds (≥12M rows)
  if (estimatedRowCount >= STOP_TIMES_DB_THRESHOLD) {
    console.log('[Parse] Large feed detected (≥12M rows) - switching to IndexedDB mode');
    try {
      return await parseStopTimesToIndexedDB(text, onProgress);
    } catch (error) {
      console.error('[IndexedDB] Failed to use IndexedDB:', error);
      throw new Error('Cache dysku niedostępny - spróbuj mniejszego feedu lub użyj przeglądarki desktopowej');
    }
  }
  
  // RAM mode for smaller feeds
  console.log('[Parse] Using RAM mode (< 12M rows)');
  
  // Split text into chunks for parallel processing
  const chunkSize = Math.ceil(lines.length / WORKER_POOL_SIZE);
  const chunks = [];
  
  for (let i = 1; i < lines.length; i += chunkSize) {
    const chunkLines = lines.slice(i, Math.min(i + chunkSize, lines.length));
    chunks.push(chunkLines.join('\n'));
  }
  
  console.log('[Parse] stop_times: splitting into ' + chunks.length + ' chunks for parallel processing');
  
  // Process chunks in parallel
  const chunkPromises = chunks.map((chunk, idx) => {
    return globalWorkerPool.execute({
      type: 'parse',
      text: chunk,
      fileType: 'stop_times',
      headers: headers,
      chunkId: idx
    });
  });
  
  const chunkResults = await Promise.all(chunkPromises);
  
  // Merge results (stop_times returns an index object)
const stopTimesCache = Object.create(null);
  
  for (const chunkResult of chunkResults) {
    if (chunkResult) {
      // Merge trip data
      Object.keys(chunkResult).forEach(tripId => {
        if (!stopTimesIndex[tripId]) {
          stopTimesIndex[tripId] = [];
        }
        stopTimesIndex[tripId].push(...chunkResult[tripId]);
      });
    }
  }
  
  // Sort each trip's stop times by sequence
  Object.keys(stopTimesIndex).forEach(tripId => {
    stopTimesIndex[tripId].sort((a, b) => a.stop_sequence - b.stop_sequence);
  });
  
  const duration = performance.now() - startTime;
  const totalRecords = Object.values(stopTimesIndex).reduce((sum, arr) => sum + arr.length, 0);
  console.log('[Parse] stop_times: ' + totalRecords.toLocaleString() + ' records in ' + duration.toFixed(0) + 'ms (parallel)');
  
  return stopTimesIndex;
}

// Parallel shapes parsing using worker pool
async function parseShapesParallel(text, onProgress) {
  const startTime = performance.now();
  
    if (!globalWorkerPool) {
    globalWorkerPool = new WorkerPool(WORKER_POOL_SIZE);
  }
  
  // Split text into chunks for parallel processing
  const lines = text.split('\n');
  const headerLine = lines[0]; // Keep header for each chunk
  const chunkSize = Math.ceil(lines.length / WORKER_POOL_SIZE);
  const chunks = [];
  
  for (let i = 1; i < lines.length; i += chunkSize) {
    const chunkLines = [headerLine, ...lines.slice(i, Math.min(i + chunkSize, lines.length))];
    chunks.push(chunkLines.join('\n'));
  }
  
  console.log('[Parse] shapes: splitting into ' + chunks.length + ' chunks for parallel processing');
  
  // Process chunks in parallel
  const chunkPromises = chunks.map((chunk, idx) => {
    return globalWorkerPool.execute({
      type: 'parse',
      text: chunk,
      fileType: 'shapes',
      chunkId: idx
    });
  });
  
  const chunkResults = await Promise.all(chunkPromises);
  
  // Merge results (shapes returns an index object with shape_id -> coordinates)
  const shapesIndex = {};
  
  for (const chunkResult of chunkResults) {
    if (chunkResult) {
      Object.keys(chunkResult).forEach(shapeId => {
        if (!shapesIndex[shapeId]) {
          shapesIndex[shapeId] = [];
        }
        shapesIndex[shapeId].push(...chunkResult[shapeId]);
      });
    }
  }
  
  // No need to sort - already sorted in worker
  
  const duration = performance.now() - startTime;
  const totalPoints = Object.values(shapesIndex).reduce((sum, arr) => sum + arr.length, 0);
  console.log('[Parse] shapes: ' + totalPoints.toLocaleString() + ' points in ' + duration.toFixed(0) + 'ms (parallel)');
  
  return shapesIndex;
}

// ═══════════════════════════════════════════════════════════════
// INDEXEDDB SUPPORT FOR LARGE FEEDS (≥12M stop_times rows)
// ═══════════════════════════════════════════════════════════════

// Open or create IndexedDB for stop_times
function openStopTimesDB(dbName) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(dbName, 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // Delete old object store if exists
      if (db.objectStoreNames.contains('stop_times')) {
        db.deleteObjectStore('stop_times');
      }
      
      // Create object store with auto-increment key
      const objectStore = db.createObjectStore('stop_times', { autoIncrement: true });
      
      // Create index on trip_id for fast lookups
      objectStore.createIndex('trip_id', 'trip_id', { unique: false });
    };
  });
}

// Write stop_times batch to IndexedDB
function writeStopTimesBatch(db, batch) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['stop_times'], 'readwrite');
    const objectStore = transaction.objectStore('stop_times');
    
    transaction.oncomplete = () => resolve();
    transaction.onerror = () => reject(transaction.error);
    
    for (const record of batch) {
      objectStore.add(record);
    }
  });
}

// Query stop_times from IndexedDB by trip_id
function queryStopTimesFromDB(db, tripId) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['stop_times'], 'readonly');
    const objectStore = transaction.objectStore('stop_times');
    const index = objectStore.index('trip_id');
    const request = index.getAll(tripId);
    
    request.onsuccess = () => {
      const results = request.result || [];
      // Sort by stop_sequence
      results.sort((a, b) => a.stop_sequence - b.stop_sequence);
      resolve(results);
    };
    request.onerror = () => reject(request.error);
  });
}

// Parse stop_times to IndexedDB for large feeds
async function parseStopTimesToIndexedDB(text, onProgress) {
  const startTime = performance.now();
  
  // Create unique DB name
  const timestamp = Date.now();
  const dbName = `gtfs_session_${timestamp}`;
  currentDbName = dbName;
  
  console.log('[IndexedDB] Creating database: ' + dbName);
  
  const db = await openStopTimesDB(dbName);
  
  // Parse header
  const lines = text.split('\n');
  const headerLine = lines[0].replace(/^\uFEFF/, '');
  const rawHeaders = headerLine.split(',').map(h => h.replace(/^"|"$/g, '').trim());
  
  const headers = {
    tripIdx: -1,
    stopIdx: -1,
    seqIdx: -1,
    arrIdx: -1,
    depIdx: -1,
    pickupIdx: -1,
    dropoffIdx: -1
  };
  
  rawHeaders.forEach((h, i) => {
    const normalized = Utils.normalizeKey(h);
    if (normalized === 'trip_id') headers.tripIdx = i;
    else if (normalized === 'stop_id') headers.stopIdx = i;
    else if (normalized === 'stop_sequence') headers.seqIdx = i;
    else if (normalized === 'arrival_time') headers.arrIdx = i;
    else if (normalized === 'departure_time') headers.depIdx = i;
    else if (normalized === 'pickup_type') headers.pickupIdx = i;
    else if (normalized === 'drop_off_type') headers.dropoffIdx = i;
  });
  
  const getCol = (cols, idx) => {
    if (idx === -1 || idx >= cols.length) return '';
    let val = cols[idx];
    if (!val) return '';
    if (val[0] === '"' && val[val.length-1] === '"') {
      val = val.substring(1, val.length - 1);
    }
    if (val[0] === ' ' || val[val.length-1] === ' ') {
      return val.trim();
    }
    return val;
  };
  
  // Process in batches
  const BATCH_SIZE = 1000;
  const PROGRESS_INTERVAL = 100000; // Report every 100k rows
  let batch = [];
  let rowCount = 0;
  
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    
    const cols = line.split(',');
    
    if (headers.tripIdx === -1 || headers.stopIdx === -1) continue;
    if (cols.length <= Math.max(headers.tripIdx, headers.stopIdx)) continue;
    
    const tripId = getCol(cols, headers.tripIdx);
    const stopId = getCol(cols, headers.stopIdx);
    
    if (!tripId || !stopId) continue;
    
    batch.push({
      trip_id: tripId,
      stop_id: stopId,
      arrival_time: getCol(cols, headers.arrIdx),
      departure_time: getCol(cols, headers.depIdx),
      stop_sequence: parseInt(getCol(cols, headers.seqIdx) || '0', 10),
      pickup_type: getCol(cols, headers.pickupIdx) || '0',
      drop_off_type: getCol(cols, headers.dropoffIdx) || '0'
    });
    
    rowCount++;
    
    // Write batch when full
    if (batch.length >= BATCH_SIZE) {
      await writeStopTimesBatch(db, batch);
      batch = [];
      
      // Report progress
      if (rowCount % PROGRESS_INTERVAL === 0 && onProgress) {
        const percent = Math.floor((i / lines.length) * 100);
        onProgress(rowCount, percent);
      }
    }
  }
  
  // Write remaining batch
  if (batch.length > 0) {
    await writeStopTimesBatch(db, batch);
  }
  
  const duration = performance.now() - startTime;
  console.log('[IndexedDB] Stored ' + rowCount.toLocaleString() + ' stop_times records in ' + duration.toFixed(0) + 'ms');
  
  if (onProgress) {
    onProgress(rowCount, 100);
  }
  
  return { db, dbName, rowCount };
}

// Adapter function to get stop times - works with both RAM and DB modes
async function getStopTimesForTrip(tripId) {
  if (state.gtfsData.stopTimesIndex) {
    // RAM mode (current)
    return getStopTimesIndexOrCache()[tripId] || [];
  } else if (state.gtfsData.stopTimesDB) {
    // DB mode - check cache first
    if (stopTimesCache[tripId]) {
      return stopTimesCache[tripId];
    }
    // Query from DB and cache
    const result = await queryStopTimesFromDB(state.gtfsData.stopTimesDB, tripId);
    stopTimesCache[tripId] = result;
    return result;
  }
  return [];
}

// Synchronous version for backward compatibility - returns empty if not in cache
function getStopTimesForTripSync(tripId) {
  if (state.gtfsData.stopTimesIndex) {
    // RAM mode
    return getStopTimesIndexOrCache()[tripId] || [];
  } else if (state.gtfsData.stopTimesDB) {
    // DB mode - return from cache only
    return stopTimesCache[tripId] || [];
  }
  return [];
}

// Helper to get the stopTimesIndex or cache (for backward compatibility)
function getStopTimesIndexOrCache() {
  if (state.gtfsData.stopTimesIndex) {
    return state.gtfsData.stopTimesIndex;
  } else if (state.gtfsData.stopTimesDB) {
    // Return the cache as if it were the index
    return stopTimesCache;
  }
  return {};
}

// Preload stop_times for a list of trips into cache
async function preloadStopTimesForTrips(tripIds, onProgress) {
  if (!state.gtfsData.stopTimesDB) return; // RAM mode doesn't need preloading
  
  const toLoad = tripIds.filter(id => !stopTimesCache[id]);
  if (toLoad.length === 0) return;
  
  console.log('[Cache] Preloading stop_times for ' + toLoad.length + ' trips...');
  
  const BATCH_SIZE = 50;
  for (let i = 0; i < toLoad.length; i += BATCH_SIZE) {
    const batch = toLoad.slice(i, Math.min(i + BATCH_SIZE, toLoad.length));
    await Promise.all(batch.map(async (tripId) => {
      const result = await queryStopTimesFromDB(state.gtfsData.stopTimesDB, tripId);
      stopTimesCache[tripId] = result;
    }));
    
    if (onProgress) {
      const percent = Math.floor(((i + batch.length) / toLoad.length) * 100);
      onProgress(i + batch.length, toLoad.length, percent);
    }
  }
  
  console.log('[Cache] Preloaded ' + toLoad.length + ' trips');
}

// Cleanup IndexedDB on page unload
window.addEventListener('beforeunload', () => {
  if (currentDbName) {
    console.log('[IndexedDB] Cleanup: deleting ' + currentDbName);
    indexedDB.deleteDatabase(currentDbName);
  }
});

// ═══════════════════════════════════════════════════════════════
// THROTTLED RENDERING (prevents UI thrashing)
// ═══════════════════════════════════════════════════════════════

let renderPending = false;

function throttledRender() {
  const now = performance.now();
  
  if (now - lastRenderTime >= PROGRESS_THROTTLE_MS) {
    lastRenderTime = now;
    render();
    renderPending = false;
  } else if (!renderPending) {
    renderPending = true;
    setTimeout(() => {
      lastRenderTime = performance.now();
      render();
      renderPending = false;
    }, PROGRESS_THROTTLE_MS);
  }
}

// ═══════════════════════════════════════════════════════════════
// LAZY VARIANT COMPUTATION (prevents UI freeze)
// ═══════════════════════════════════════════════════════════════

const variantCache = new Map();
const variantInProgress = new Set();

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function getVariantCacheKey() {
  if (!state.selectedRoute || !state.selectedDate) return null;
  
  const routeKey = state.selectedRouteGroup 
    ? getLogicalRouteKeyFromGroup(state.selectedRouteGroup)
    : state.selectedRoute.route_id;
  
  return routeKey + '_' + state.selectedDirection + '_' + state.selectedDate;
}

async function getVariantsDataAsync() {
  const cacheKey = getVariantCacheKey();
  if (!cacheKey) return null;
  
  // Cache hit
  if (variantCache.has(cacheKey)) {
    return variantCache.get(cacheKey);
  }
  
  // Already computing
  if (variantInProgress.has(cacheKey)) {
    while (variantInProgress.has(cacheKey)) {
      await sleep(50);
    }
    return variantCache.get(cacheKey);
  }
  
  // Compute asynchronously
  variantInProgress.add(cacheKey);
  
  // Yield to UI
  await sleep(0);
  
  const startTime = performance.now();
  
  // Call EXISTING computeVariantsForRoute (DO NOT CHANGE)
  const variantsData = computeVariantsForRoute();
  
  const duration = performance.now() - startTime;
  console.log('[Variant] Computed in ' + duration.toFixed(0) + 'ms');
  
  variantCache.set(cacheKey, variantsData);
  variantInProgress.delete(cacheKey);
  
  return variantsData;
}

function clearVariantCache() {
  variantCache.clear();
  variantInProgress.clear();
}

// ═══════════════════════════════════════════════════════════════
// 3. UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════

const $ = (id) => document.getElementById(id);
const $$ = (selector, root = document) => Array.from(root.querySelectorAll(selector));

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// ═══════════════════════════════════════════════════════════════
// 3.2. TIME AND DATE MODULE (GTFS-specific)
// ═══════════════════════════════════════════════════════════════

/**
 * Fast time parser with caching (no string split)
 * Handles GTFS time format: "HH:MM:SS" (including >24h times like "25:30:00")
 * @param {string} timeStr - Time string
 * @returns {number} - Minutes since midnight (can be >1440 for next-day service)
 */
function parseTimeFast(timeStr) {
  if (!timeStr) return 0;
  
  // Check cache first (many stop_times share same times like "08:00:00")
  if (TIME_PARSE_CACHE.has(timeStr)) {
    return TIME_PARSE_CACHE.get(timeStr);
  }
  
  // Fast parse using charCodeAt (no string allocation)
  // "08:30:00" → extract HH and MM directly
  // Handle edge cases for single digit or malformed times
  let h = 0, m = 0;
  const len = timeStr.length;
  
  if (len >= 5) {
    // Standard format "HH:MM" or "HH:MM:SS"
    h = (timeStr.charCodeAt(0) - 48) * 10 + (timeStr.charCodeAt(1) - 48);
    m = (timeStr.charCodeAt(3) - 48) * 10 + (timeStr.charCodeAt(4) - 48);
  } else {
    // Fallback for malformed times
    const parts = timeStr.split(':');
    h = parseInt(parts[0] || '0', 10);
    m = parseInt(parts[1] || '0', 10);
  }
  
  const result = h * 60 + m;
  
  // Cache for reuse
  TIME_PARSE_CACHE.set(timeStr, result);
  
  return result;
}
    function minutesToTime(minutes) {
      if (!minutes && minutes !== 0) return '';
      const h = Math.floor(minutes / 60);
      const m = minutes % 60;
      const s = 0;
      return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }
// ═══════════════════════════════════════════════════════════════
// TIME & DATE UTILITIES MODULE (Unified API)
// ═══════════════════════════════════════════════════════════════

Utils.TimeUtils = {
  toMinutes: Utils.timeToMinutes,
  fromMinutes: Utils.minutesToTime,
  format: Utils.formatTime,
  parseDate: Utils.parseGTFSDate,
  formatDate: Utils.formatDateToGTFS,
  
  addDays(dateStr, days) {
    const date = this.parseDate(dateStr);
    if (!date) return null;
    date.setDate(date.getDate() + days);
    return this.formatDate(date);
  },
  
  daysBetween(date1Str, date2Str) {
    const y1 = parseInt(date1Str.substring(0, 4), 10);
    const m1 = parseInt(date1Str.substring(4, 6), 10) - 1;
    const d1 = parseInt(date1Str.substring(6, 8), 10);
    const y2 = parseInt(date2Str.substring(0, 4), 10);
    const m2 = parseInt(date2Str.substring(4, 6), 10) - 1;
    const d2 = parseInt(date2Str.substring(6, 8), 10);
    
    const ms1 = new Date(y1, m1, d1).getTime();
    const ms2 = new Date(y2, m2, d2).getTime();
    return Math.floor((ms2 - ms1) / (1000 * 60 * 60 * 24));
  },
  
  getDayOfWeek(dateStr) {
    const date = this.parseDate(dateStr);
    return date ? date.getDay() : null;
  },
  
  calculateEaster(year) {
    const a = year % 19;
    const b = Math.floor(year / 100);
    const c = year % 100;
    const d = Math.floor(b / 4);
    const e = b % 4;
    const f = Math.floor((b + 8) / 25);
    const g = Math.floor((b - f + 1) / 3);
    const h = (19 * a + b - d - g + 15) % 30;
    const i = Math.floor(c / 4);
    const k = c % 4;
    const l = (32 + 2 * e + 2 * i - h - k) % 7;
    const m = Math.floor((a + 11 * h + 22 * l) / 451);
    const month = Math.floor((h + l - 7 * m + 114) / 31);
    const day = ((h + l - 7 * m + 114) % 31) + 1;
    return new Date(year, month - 1, day);
  },
  
  getPolishHolidays(year) {
    const holidays = [];
    holidays.push({ date: `${year}0101`, name: 'Nowy Rok' });
    holidays.push({ date: `${year}0501`, name: 'Święto Pracy' });
    holidays.push({ date: `${year}0815`, name: 'Wniebowzięcie NMP' });
    holidays.push({ date: `${year}1101`, name: 'Wszystkich Świętych' });
    holidays.push({ date: `${year}1225`, name: 'Boże Narodzenie' });
    holidays.push({ date: `${year}1226`, name: 'Drugi dzień Świąt' });
    
    const easter = this.calculateEaster(year);
    const easterMonday = new Date(easter);
    easterMonday.setDate(easter.getDate() + 1);
    holidays.push({ date: this.formatDate(easterMonday), name: 'Poniedziałek Wielkanocny' });
    
    const corpusChristi = new Date(easter);
    corpusChristi.setDate(easter.getDate() + 60);
    holidays.push({ date: this.formatDate(corpusChristi), name: 'Boże Ciało' });
    
    return holidays;
  },
  
  findUpcomingHolidays(referenceDateStr, daysAhead = 7) {
    const refYear = parseInt(referenceDateStr.substring(0, 4), 10);
    const holidays = [
      ...this.getPolishHolidays(refYear),
      ...this.getPolishHolidays(refYear + 1)
    ];
    
    const upcoming = [];
    holidays.forEach(holiday => {
      const days = this.daysBetween(referenceDateStr, holiday.date);
      if (days >= 0 && days <= daysAhead) {
        upcoming.push({ ...holiday, daysFromNow: days });
      }
    });
    
    return upcoming.sort((a, b) => a.daysFromNow - b.daysFromNow);
  }
};
Utils.TimeUtils = TimeUtils;

// ═══════════════════════════════════════════════════════════════
// 3.4. CACHE AND SERIALIZATION MODULE
// ═══════════════════════════════════════════════════════════════
    function compressCoordinates(coords) {
      if (!coords || coords.length === 0) return '';
      
      const deltas = [];
      let prevLat = 0, prevLon = 0;
      
      for (const [lat, lon] of coords) {
        const latInt = Math.round(lat * 1e6);
        const lonInt = Math.round(lon * 1e6);
        
        deltas.push(latInt - prevLat);
        deltas.push(lonInt - prevLon);
        
        prevLat = latInt;
        prevLon = lonInt;
      }
      
      return deltas.map(d => d.toString(36)).join(',');
    }

    function decompressCoordinates(compressed) {
      if (!compressed) return [];
      
      const deltas = compressed.split(',').map(s => parseInt(s, 36));
      const coords = [];
      let lat = 0, lon = 0;
      
      for (let i = 0; i < deltas.length; i += 2) {
        lat += deltas[i];
        lon += deltas[i + 1];
        
        // Divide by 1e6 to restore decimal coordinates
        coords.push([lat / 1e6, lon / 1e6]);
      }
      
      return coords;
    }

    function hashShapesData(shapesIndex) {
      const keys = Object.keys(shapesIndex).sort();
      const sample = keys.slice(0, 10).join(',') + keys.length;
      let hash = 0;
      for (let i = 0; i < sample.length; i++) {
        const char = sample.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return 'shapes_' + Math.abs(hash).toString(36);
    }

    function cacheShapes(shapesIndex, simplified) {
      try {
        const cacheKey = hashShapesData(shapesIndex);
        
        const compressed = {};
        Object.keys(simplified).forEach(shapeId => {
          compressed[shapeId] = compressCoordinates(simplified[shapeId]);
        });
        
        const cacheData = {
          version: 2, // version 2 uses compression
          timestamp: Date.now(),
          shapes: compressed
        };
        
        const jsonStr = JSON.stringify(cacheData);
        const originalSize = jsonStr.length;
        
        localStorage.setItem(cacheKey, jsonStr);
      } catch (e) {
        // If storage quota exceeded, try to clear old caches
        if (e.name === 'QuotaExceededError') {
          try {
            // Remove old shape caches
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('shapes_')) {
                localStorage.removeItem(key);
              }
            }
          } catch (e2) {
            // Ignore cache cleanup errors - they don't affect core functionality
          }
        }
      }
    }

    function loadCachedShapes(shapesIndex) {
      try {
        const cacheKey = hashShapesData(shapesIndex);
        const cached = localStorage.getItem(cacheKey);
        if (!cached) return null;
        
        const data = JSON.parse(cached);
        
        const age = Date.now() - data.timestamp;
        if (age > 30 * 24 * 60 * 60 * 1000) {
          localStorage.removeItem(cacheKey);
          return null;
        }
        
        const shapes = {};
        Object.keys(data.shapes).forEach(shapeId => {
          if (data.version === 2) {
            // Version 2 uses compression
            shapes[shapeId] = decompressCoordinates(data.shapes[shapeId]);
          } else {
            // Version 1 or unversioned - direct coordinates
            shapes[shapeId] = data.shapes[shapeId];
          }
        });
        
        return shapes;
      } catch (e) {
        return null;
      }
    }

    function simplifyShapes(shapesIndex, tolerance = 0.0001) {
      const simplified = {};
      let totalOriginal = 0;
      let totalSimplified = 0;
      
      Object.keys(shapesIndex).forEach(shapeId => {
        const points = shapesIndex[shapeId];
        totalOriginal += points.length;
        
        if (points.length <= 2) {
          simplified[shapeId] = points;
          totalSimplified += points.length;
        } else {
          const simplifiedPoints = Utils.simplifyDouglasPeucker(points, tolerance);
          simplified[shapeId] = simplifiedPoints;
          totalSimplified += simplifiedPoints.length;
        }
      });
      
      const reduction = totalOriginal > 0 
        ? Math.round((1 - totalSimplified / totalOriginal) * 100) 
        : 0;
      
      return simplified;
    }

/**
 * Get simplified shape (lazy computation with cache)
 * Only simplifies shapes when they're actually needed for rendering
 * @param {string} shapeId - Shape ID
 * @param {number} tolerance - Simplification tolerance (default 0.0001)
 * @returns {Array} - Simplified coordinates [[lat, lon], ...]
 */
function getSimplifiedShape(shapeId, tolerance = 0.0001) {
  const cacheKey = `${shapeId}_${tolerance}`;
  
  // Check cache
  if (simplifiedShapesCache[cacheKey]) {
    return simplifiedShapesCache[cacheKey];
  }
  
  // Get raw shape
  const rawShape = state.gtfsData.shapesIndex?.[shapeId];
  if (!rawShape || rawShape.length === 0) {
    return [];
  }
  
  // rawShape is already in coordinate array format [[lat, lon], ...]
  let simplified;
  
  // Simplify only if needed (many points)
  if (rawShape.length > 50) {
    simplified = Utils.simplifyDouglasPeucker(rawShape, tolerance);
  } else {
    simplified = rawShape;  // Don't simplify short shapes
  }
  
  // Cache result
  simplifiedShapesCache[cacheKey] = simplified;
  
  return simplified;
}

// ═══════════════════════════════════════════════════════════════
// 3.5. DATA QUALITY HEURISTICS MODULE
// ═══════════════════════════════════════════════════════════════
function mostCommonString(arr) {
  const counts = Object.create(null);
  for (const s of arr) {
    if (!s) continue;
    const t = String(s).trim();
    if (!t) continue;
    counts[t] = (counts[t] || 0) + 1;
  }
  let best = null, bestCount = 0;
  Object.keys(counts).forEach(k => { if (counts[k] > bestCount) { best = k; bestCount = counts[k]; }});
  return best;
}
function looksLikeGarbageLabel(s, shortName) {
  if (!s) return true;
  const t = String(s).trim();
  if (t.length < 2) return true;
  if (/^[0-9\-\s]+$/.test(t)) {
    if (!shortName) return true;
    if (t.replace(/\s+/g,'') === String(shortName).replace(/\s+/g,'')) return true;
  }
  return false;
}

// ═══════════════════════════════════════════════════════════════
// 3.6. DIRECTION_ID ENRICHMENT MODULE
// ═══════════════════════════════════════════════════════════════
const TO_RAD = Math.PI / 180;
const TO_DEG = 180 / Math.PI;
function getTripStopSequence(tripId, stopTimesIndex) {
  const stopTimes = stopTimesIndex[tripId];
  if (!stopTimes || stopTimes.length === 0) return [];
  return stopTimes.map(st => st.stop_id);
}
function isCircularRoute(stopSequence) {
  if (!stopSequence || stopSequence.length < 2) return false;
  return stopSequence[0] === stopSequence[stopSequence.length - 1];
}
// Helper: Exact array equality check
function arrayEquals(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
// Helper: Subsequence check (preserves order, allows missing stops)
function isSubsequence(small, big) {
  let j = 0;
  for (let i = 0; i < big.length && j < small.length; i++) {
    if (small[j] === big[i]) j++;
  }
  return j === small.length;
}
// Helper function to process a single route's direction enrichment
function enrichRouteDirections(routeTrips, stopTimesIndex, stopsIndex) {
  // Only process trips without direction_id
  const tripsToProcess = routeTrips.filter(t => 
    !t.direction_id || t.direction_id === ''
  );
  
  if (tripsToProcess.length === 0) return;
  
  // 1. Extract stop sequences for all trips
  const tripPatterns = tripsToProcess.map(trip => ({
    trip,
    seq: getTripStopSequence(trip.trip_id, stopTimesIndex)
  })).filter(p => p.seq.length > 0);

  if (tripPatterns.length === 0) {
    // No data: assign all to direction 0
    tripsToProcess.forEach(t => t.direction_id = '0');
    return;
  }

  // Check for circular routes (all trips are circular)
  const isCircular = tripPatterns.every(p => isCircularRoute(p.seq));
  if (isCircular) {
    tripsToProcess.forEach(t => t.direction_id = '0');
    return;
  }

  // 2. Find MOST POPULAR sequence as reference pattern (longest as tiebreaker)
  const patternCount = new Map();
  for (const p of tripPatterns) {
    const key = p.seq.join('|');
    patternCount.set(key, (patternCount.get(key) || 0) + 1);
  }
  
  let pattern = null, reversePattern = null, maxCount = 0, maxLength = 0;
  for (const [key, count] of patternCount) {
    const currentLength = key.split('|').length;
    
    // Priority: 1) highest count, 2) on tie → longest sequence
    if (count > maxCount || (count === maxCount && currentLength > maxLength)) {
      pattern = key.split('|');
      reversePattern = [...pattern].reverse();
      maxCount = count;
      maxLength = currentLength;
    }
  }

  // 3. FAST PATH: Exact match assignment for perfect forward/reverse sequences
  const needsFallback = [];
  for (const {trip, seq} of tripPatterns) {
    if (arrayEquals(seq, pattern)) {
      trip.direction_id = '0';
    } else if (arrayEquals(seq, reversePattern)) {
      trip.direction_id = '1';
    } else {
      // Mark for fallback processing
      needsFallback.push({trip, seq});
    }
  }

  // 4. FALLBACK: Subsequence matching for variants/shortcuts
  for (const {trip, seq} of needsFallback) {
    // Check if trip is a subsequence of pattern/reversePattern
    if (isSubsequence(seq, pattern)) {
      trip.direction_id = '0';
    } else if (isSubsequence(seq, reversePattern)) {
      trip.direction_id = '1';
    } else {
      // Default fallback
      trip.direction_id = '0';
    }
  }
}

// Async version with chunked processing to prevent UI freezes

/**
 * Assign direction_id based on trip_headsign distribution
 * Use the 2 most common headsigns as direction 0 and 1
 * @returns {boolean} - true if successful, false if headsigns not usable
 */
function tryAssignDirectionByHeadsign(trips) {
  // Count headsign occurrences
  const headsignCounts = {};
  let totalWithHeadsign = 0;
  
  trips.forEach(t => {
    const h = (t.trip_headsign || '').trim();
    if (h) {
      headsignCounts[h] = (headsignCounts[h] || 0) + 1;
      totalWithHeadsign++;
    }
  });
  
  // Need at least 80% of trips with headsigns to use this method
  if (totalWithHeadsign < trips.length * 0.8) {
    return false;
  }
  
  // Get top 2 headsigns
  const sortedHeadsigns = Object.entries(headsignCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 2);
  
  if (sortedHeadsigns.length < 2) {
    return false; // Need at least 2 distinct headsigns
  }
  
  const [headsign0, count0] = sortedHeadsigns[0];
  const [headsign1, count1] = sortedHeadsigns[1];
  
  // Top 2 headsigns should cover at least 60% of trips
  if ((count0 + count1) < trips.length * 0.6) {
    return false;
  }
  
  // Assign direction_id based on headsign
  trips.forEach(t => {
    const h = (t.trip_headsign || '').trim();
    if (h === headsign0) {
      t.direction_id = '0';
    } else if (h === headsign1) {
      t.direction_id = '1';
    }
    // Leave undefined for other headsigns - will be handled by fallback
  });
  
  console.log('[Enrichment] Used trip_headsign: "' + headsign0 + '" (dir 0), "' + headsign1 + '" (dir 1)');
  
  return true;
}

async function enrichTripsWithDirectionIdUsingWorker(trips, stopTimesIndex, stopsIndex, onProgress) {
  // PRIORITY 1: Try headsign-based detection (fast, reliable for quality feeds)
  const headsignSuccess = tryAssignDirectionByHeadsign(trips);
  if (headsignSuccess) {
    // Headsign method worked - skip geometry analysis
    // Report 100% progress (processed=1, total=1, percent=100)
    if (onProgress) onProgress(1, 1, 100);
    return;
  }
  
  console.log('[Enrichment] Headsign method failed - falling back to geometry analysis');
  
  // 1) trips do przetworzenia
  const tripsToProcess = trips.filter(t => t && t.trip_id && (t.direction_id === undefined || t.direction_id === null || String(t.direction_id).trim() === ''));
  if (!tripsToProcess.length) {
    if (onProgress) onProgress(0, 0, 100);
    return;
  }

  // 2) Zbuduj minimalny filteredStopTimesIndex oraz zbiór używanych stop_id
  const filteredStopTimesIndex = Object.create(null);
  const usedStopIds = new Set();

  for (const t of tripsToProcess) {
    const raw = stopTimesIndex[t.trip_id] || [];
    // Kopiujemy pełne info wymagane przez algorytm i normalizujemy seq na number
    const copy = raw.map(st => ({
      stop_id: st.stop_id,
      stop_sequence: Number(st.stop_sequence || 0),
      arrival_time: st.arrival_time || '',
      departure_time: st.departure_time || '',
      pickup_type: st.pickup_type || '0',
      drop_off_type: st.drop_off_type || '0'
    }));
    filteredStopTimesIndex[t.trip_id] = copy;
    copy.forEach(s => usedStopIds.add(s.stop_id));
  }

  // 3) Zbuduj mapę stop_id -> mały indeks (0..N-1) oraz stopsArray (minimalne dane)
  const stopIdToIndex = Object.create(null);
  const stopsArray = [];
  let idx = 0;
  usedStopIds.forEach(id => {
    stopIdToIndex[id] = idx++;
    const s = stopsIndex[id] || {};
    stopsArray.push({
      id,
      stop_lat: s.stop_lat !== undefined ? s.stop_lat : null,
      stop_lon: s.stop_lon !== undefined ? s.stop_lon : null,
      stop_name: s.stop_name || ''
    });
  });

  // 4) Zbuduj skompresowany stopTimesIndex: zastępuj stop_id przez indeks
  const stopTimesIndexCompressed = Object.create(null);
  for (const trip of tripsToProcess) {
    const arr = filteredStopTimesIndex[trip.trip_id] || [];
    // Nie sortujemy tu na zapas - worker to zrobi, ale możemy posortować dla mniejszego transferu niepotrzebnych permutacji
    arr.sort((a,b) => Number(a.stop_sequence || 0) - Number(b.stop_sequence || 0));
    stopTimesIndexCompressed[trip.trip_id] = arr.map(st => ({
      si: stopIdToIndex[st.stop_id],   // stop index
      seq: Number(st.stop_sequence || 0),
      arr: st.arrival_time || '',
      dep: st.departure_time || '',
      pu: st.pickup_type || '0',
      do: st.drop_off_type || '0'
    }));
  }

  // 5) Minimal trips array
  const minimalTrips = tripsToProcess.map(t => ({ trip_id: t.trip_id, route_id: t.route_id }));

  // 6) Worker code string (rozumie compressed format)
  const workerCode = `
    const TO_RAD = Math.PI / 180;
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const dLon = (lon2 - lon1) * TO_RAD;
      const y = Math.sin(dLon) * Math.cos(lat2 * TO_RAD);
      const x = Math.cos(lat1 * TO_RAD) * Math.sin(lat2 * TO_RAD) -
                Math.sin(lat1 * TO_RAD) * Math.cos(lat2 * TO_RAD) * Math.cos(dLon);
      let bearing = Math.atan2(y, x) * 180 / Math.PI;
      return (bearing + 360) % 360;
    }
    function tripSequenceScore(tripSeq, pattern) {
      if (!Array.isArray(tripSeq) || !Array.isArray(pattern) || tripSeq.length === 0) return 0;
      const patternSet = new Set(pattern);
      const relevant = tripSeq.filter(s => patternSet.has(s));
      if (relevant.length === 0) return 0;
      let match = 0, idx = 0;
      for (let i = 0; i < relevant.length; i++) {
        const val = relevant[i];
        while (idx < pattern.length && pattern[idx] !== val) idx++;
        if (idx < pattern.length) { match++; idx++; }
      }
      return match / relevant.length;
    }

    self.onmessage = function(ev) {
      try {
        const { trips, stopTimesIndex, stopsArray } = ev.data;
        // Build stopsIndexLocal by index for quick lookup
        const stopsIndexLocal = stopsArray; // array indexed by small ints
        // Group trips by route
        const tripsByRoute = {};
        for (const t of trips) {
          const rid = t.route_id || 'unknown';
          if (!tripsByRoute[rid]) tripsByRoute[rid] = [];
          tripsByRoute[rid].push(t.trip_id);
        }

        const routeKeys = Object.keys(tripsByRoute);
        const totalRoutes = routeKeys.length;
        const resultMap = {};
        let processedRoutes = 0;

        for (let ri = 0; ri < routeKeys.length; ri++) {
          const routeId = routeKeys[ri];
          const tripIds = tripsByRoute[routeId] || [];

          // Build pattern map: compressed seq -> { seqIndexed: [...], trips: [] }
          const patternMap = {};
          const patternOrder = [];

          for (const tid of tripIds) {
            const stArr = (stopTimesIndex[tid] || []).slice();
            // sort by seq
            stArr.sort((a,b)=> (Number(a.seq||0) - Number(b.seq||0)));
            // seq as array of stopIndices (numbers)
            const seqIndexed = stArr.map(x => x.si);
            const key = seqIndexed.join(',');
            if (!patternMap[key]) { patternMap[key] = { seq: seqIndexed, trips: [] }; patternOrder.push(key); }
            patternMap[key].trips.push(tid);
          }

          if (patternOrder.length === 0) { processedRoutes++; continue; }

          if (patternOrder.length === 1) {
            const only = patternMap[patternOrder[0]];
            let inferred = '0';
            const seq = only.seq;
            if (seq.length >= 2) {
              const sf = stopsIndexLocal[seq[0]], sl = stopsIndexLocal[seq[seq.length-1]];
              if (sf && sl && sf.stop_lat !== null && sl.stop_lat !== null) {
                const b = calculateBearing(parseFloat(sf.stop_lat), parseFloat(sf.stop_lon), parseFloat(sl.stop_lat), parseFloat(sl.stop_lon));
                inferred = (b < 180) ? '0' : '1';
              }
            }
            for (const tid of only.trips) resultMap[tid] = inferred;
            processedRoutes++;
            if (processedRoutes % 5 === 0) self.postMessage({ type:'progress', processed: processedRoutes, total: totalRoutes, percent: Math.round(processedRoutes/totalRoutes*100) });
            continue;
          }

          let refKey = null, maxCount = -1, maxLen = -1;
          for (const k of patternOrder) {
            const info = patternMap[k];
            if (info.trips.length > maxCount || (info.trips.length === maxCount && info.seq.length > maxLen)) {
              maxCount = info.trips.length; maxLen = info.seq.length; refKey = k;
            }
          }
          const refPattern = patternMap[refKey].seq;
          const refPatternRev = [...refPattern].reverse();

          let refBearing = null;
          if (refPattern.length >= 2) {
            const sf = stopsIndexLocal[refPattern[0]], sl = stopsIndexLocal[refPattern[refPattern.length-1]];
            if (sf && sl && sf.stop_lat !== null && sl.stop_lat !== null) {
              refBearing = calculateBearing(parseFloat(sf.stop_lat), parseFloat(sf.stop_lon), parseFloat(sl.stop_lat), parseFloat(sl.stop_lon));
            }
          }

          for (const k of patternOrder) {
            const info = patternMap[k];
            const seq = info.seq;
            if (!seq || seq.length === 0) { info.direction = '0'; continue; }
            if (k === refKey) { info.direction = '0'; }
            else {
              const scoreFwd = tripSequenceScore(seq, refPattern);
              const scoreRev = tripSequenceScore(seq, refPatternRev);
              if (scoreFwd > scoreRev + 0.1) info.direction = '0';
              else if (scoreRev > scoreFwd + 0.1) info.direction = '1';
              else {
                if (refBearing !== null && seq.length >= 2) {
                  const sf = stopsIndexLocal[seq[0]], sl = stopsIndexLocal[seq[seq.length-1]];
                  if (sf && sl && sf.stop_lat !== null && sl.stop_lat !== null) {
                    const b = calculateBearing(parseFloat(sf.stop_lat), parseFloat(sf.stop_lon), parseFloat(sl.stop_lat), parseFloat(sl.stop_lon));
                    let diff = Math.abs(b - refBearing); if (diff > 180) diff = 360 - diff;
                    info.direction = diff < 90 ? '0' : '1';
                  } else info.direction = '0';
                } else info.direction = '0';
              }
            }
            for (const tid of info.trips) resultMap[tid] = info.direction;
          }

          processedRoutes++;
          if (processedRoutes % 5 === 0) self.postMessage({ type:'progress', processed: processedRoutes, total: totalRoutes, percent: Math.round(processedRoutes/totalRoutes*100) });
        }

        self.postMessage({ type:'done', map: resultMap });
      } catch (err) {
        self.postMessage({ type:'error', message: (err && err.message) ? err.message : String(err) });
      }
    };
  `;

  // 7) Uruchom worker i wyślij skompresowane struktury
  let worker;
  try {
    const blob = new Blob([workerCode], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    worker = new Worker(url);
    state.currentWorker = worker;

    const resultPromise = new Promise((resolve, reject) => {
      worker.onmessage = (ev) => {
        const msg = ev.data;
        if (!msg) return;
        if (msg.type === 'progress') {
          if (onProgress) onProgress(msg.processed, msg.total, msg.percent);
        } else if (msg.type === 'done') {
          resolve(msg.map || {});
        } else if (msg.type === 'error') {
          reject(new Error(msg.message || 'worker error'));
        }
      };
      worker.onerror = (err) => reject(err || new Error('worker runtime error'));
    });

    // Post compressed payload
    worker.postMessage({
      trips: minimalTrips,
      stopTimesIndex: stopTimesIndexCompressed,
      stopsArray: stopsArray
    });

    const mapResult = await resultPromise;

    // Apply results
    for (const t of trips) {
      if (!t || !t.trip_id) continue;
      if (mapResult && Object.prototype.hasOwnProperty.call(mapResult, t.trip_id)) {
        t.direction_id = String(mapResult[t.trip_id]);
      }
    }

    if (onProgress) onProgress(1,1,100);
    try { worker.terminate(); } catch(e){}
    state.currentWorker = null;
    return;
  } catch (err) {
    // No fallback - cleanup and propagate error
    if (worker) try { worker.terminate(); } catch(e){}
    state.currentWorker = null;
    throw err; // Let caller handle error (same as parseStopTimesStreamWithWorker)
  }
}	  
// ═══════════════════════════════════════════════════════════════
// 4. DATA PARSING & LOADING
// ═══════════════════════════════════════════════════════════════
// Helper function to parse a single CSV line (handles quoted fields)
function parseCSVLine(line) {
  if (!line) return [];
  
  // Fast path: no quotes = simple split (much faster)
  if (!line.includes('"')) {
    return line.split(',');
  }
  
  // Slow path: handle quoted fields
  const result = [];
  const chars = [];
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        // Escaped quote ("")
        chars.push('"');
        i++; // Skip next quote
      } else {
        // Toggle quote mode
        inQuotes = !inQuotes;
      }
    } else if (char === ',' && !inQuotes) {
      // Field separator (outside quotes)
      result.push(chars.join(''));
      chars.length = 0; // Clear array (faster than creating new)
    } else {
      chars.push(char);
    }
  }
  
  // Add last field
  result.push(chars.join(''));
  
  // Warn if quotes are still open (malformed CSV)
  if (inQuotes) {
    console.warn('parseCSVLine: Unclosed quotes in line:', line.substring(0, 50) + '...');
  }
  
  return result;
}

// CSV parser - used for all files
function parseCSV(text) {
  if (!text || typeof text !== 'string') {
    console.warn('parseCSV: Invalid input, expected non-empty string');
    return [];
  }
  
  // Optimize: Replace \r\n with \n first (one-time operation), then simple split
  const normalized = text.includes('\r') ? text.replace(/\r\n/g, '\n').replace(/\r/g, '\n') : text;
  const lines = normalized.split('\n');
  if (lines.length === 0) return [];
  
  const headerLine = lines[0].replace(/^\uFEFF/, '');
  const headers = parseCSVLine(headerLine).map(h => h.trim());
  
  const result = [];
  
  // Parse data rows - optimized for speed
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    if (!line || !line.trim()) continue; // Skip empty lines
    
    const values = parseCSVLine(line);
    const row = {};
    
    // Use for loop instead of forEach (faster)
    for (let j = 0; j < headers.length; j++) {
      const value = values[j] || '';
      row[headers[j]] = value.trim();
    }
    
    result.push(Utils.normalizeRecord(row));
  }
  
  return result;
}

async function handleFileUpload(e) {
  // Prevent default if called from event
  if (e && e.preventDefault) {
    e.preventDefault();
  }
  
  // Check if we're in Electron
  if (!window.electronAPI) {
    alert('This feature requires Electron. Please use the desktop app.');
    return;
  }
  
  // Cleanup from previous upload
  if (globalWorkerPool) {
    globalWorkerPool.terminate();
    globalWorkerPool = null;
  }
  clearVariantCache();
  
  try {
    // Open file dialog
    const filePath = await window.electronAPI.openFileDialog();
    if (!filePath) {
      console.log('[App] User cancelled file selection');
      return;
    }
    
    console.log('[App] Selected file:', filePath);
    
    state.loading = true;
    state.loadingStep = 'Preparing to load GTFS...';
    state.loadingProgress = 0;
    state.loadingProgressPercent = 0;
    state.error = '';
    render();
    
    // Setup progress listener
    const cleanupProgress = window.electronAPI.onLoadProgress((progress) => {
      state.loadingStep = progress.step;
      state.loadingProgressPercent = progress.percent;
      
      if (progress.error) {
        state.error = progress.step;
        state.loading = false;
      }
      
      throttledRender();
    });
    
    // Load file in main process
    console.log('[App] Starting GTFS load...');
    
    const result = await window.electronAPI.loadGTFSFile(filePath);
    
    console.log('[App] Raw result from main:', result);
    
    // Cleanup progress listener
    cleanupProgress();
    
    if (!result) {
      throw new Error('No response from main process');
    }
    
    if (!result.success) {
      throw new Error(result.error || 'Unknown error loading GTFS');
    }
    
    console.log('[App] GTFS data loaded from', result.fromCache ? 'cache' : 'scratch');
    
    // Initialize state with database reference
    state.gtfsData = { loaded: true, stats: result.stats, fromCache: result.fromCache };
    
    // Load routes and dates from database
    await loadRoutesForUI();
    await loadAvailableDates();
    
    // Clear caches
    stationNameToIdCache = null;
    clearStopsSearchIndex();
    clearStopToRoutesCache();
    cachedGroupsArray = null;
    lastStopsDataHash = null;
    state.routeProfiles = {};
    state.canonicalMasterLists = {};
    
    state.loading = false;
    state.loadingStep = '';
    state.loadingProgress = 0;
    state.loadingProgressPercent = 0;
    
    console.log('[App] GTFS loaded successfully!');
    render();
    
  } catch (err) {
    console.error('[App] Error loading GTFS:', err);
    state.error = 'Błąd ładowania GTFS: ' + err.message;
    state.loading = false;
    state.loadingProgress = 0;
    state.loadingProgressPercent = 0;
    render();
  }
}

async function loadRoutesForUI() {
  const routes = await window.electronAPI.queryRoutes();
  const grouped = {};
  routes.forEach(r => {
    const key = r.agency_name || 'Unknown';
    if (!grouped[key]) grouped[key] = [];
    r.colorStyle = r.route_color ? `background: #${r.route_color}` : '';
    grouped[key].push(r);
  });
  state.gtfsData.logicalRoutes = grouped;
  state.gtfsData.routes = routes;
}

async function loadAvailableDates() {
  const ranges = await window.electronAPI.queryAvailableDates();
  const dates = new Set();
  ranges.forEach(r => {
    let cur = String(r.start_date || '');
    const endDate = String(r.end_date || '');
    
    if (!cur || cur.length !== 8 || !endDate || endDate.length !== 8) return;
    
    while (cur <= endDate) {
      dates.add(cur);
      const d = new Date(
        parseInt(cur.substring(0, 4)),
        parseInt(cur.substring(4, 6)) - 1,
        parseInt(cur.substring(6, 8))
      );
      d.setDate(d.getDate() + 1);
      cur = d.toISOString().substring(0, 10).replace(/-/g, '');
    }
  });
  const availableDatesArray = Array.from(dates).sort();
  state.availableDates = availableDatesArray.map(d => ({ value: d, label: formatDateLabel(d) }));
  const today = new Date().toISOString().substring(0, 10).replace(/-/g, '');
  state.selectedDate = dates.has(today) ? today : availableDatesArray[0];
}

function formatDateLabel(dateStr) {
  if (!dateStr || dateStr.length !== 8) return dateStr;
  const year = dateStr.substring(0, 4);
  const month = dateStr.substring(4, 6);
  const day = dateStr.substring(6, 8);
  return `${day}.${month}.${year}`;
}

    function cancelParsing() {
      if (state.currentWorker) {
        try { state.currentWorker.terminate(); } catch(e){}
        state.currentWorker = null;
      }
      state.loading=false; state.loadingStep=''; state.loadingProgress=0; state.loadingProgressPercent=0;
      state.error = 'Parsowanie anulowane przez użytkownika';
      render();
    }

// ═══════════════════════════════════════════════════════════════
// 5. GTFS DATA PROCESSING
// ═══════════════════════════════════════════════════════════════
function canonicalFromCode(t) {
  if (t === null || t === undefined || t === '') return null;
  const n = parseInt(t, 10);
  if (isNaN(n)) return null;

  if (n === 0) return 'tram';
  if (n === 1) return 'metro';
  if (n === 2) return 'rail';
  if (n === 3) return 'bus';
  if (n === 4) return 'ferry';
  if (n === 5) return 'cable';
  if (n === 6) return 'gondola';
  if (n === 7) return 'funicular';
  if (n === 11) return 'trolleybus';
  if (n === 12) return 'monorail';
  if (n === 300) return 'rail';
  if (n >= 100 && n < 200) return 'rail';
  if (n >= 200 && n < 300) return 'coach';
  if (n >= 301 && n < 500) return 'metro';
  if (n >= 500 && n < 600) return 'ferry';
  if (n >= 700 && n < 800) return 'bus';
  if (n >= 800 && n < 900) return 'bus';
  if (n >= 900 && n < 1000) return 'tram';
  if (n >= 1100 && n < 1200) return 'air';
  if (n >= 1300 && n < 1400) return 'cable';
  return null;
}

function collectRouteType(route) {
  const reasons = [];
  if (!route || typeof route !== 'object') return { canonical: 'other', reasons: ['no-route'] };

  const rt = (route.route_type !== undefined && route.route_type !== '') ? route.route_type
           : (route.route_type_id !== undefined && route.route_type_id !== '') ? route.route_type_id
           : (route.type !== undefined && route.type !== '') ? route.type
           : '';

  if (rt !== '') {
    const byCode = canonicalFromCode(rt);
    if (byCode) {
      reasons.push(`code:${rt}->${byCode}`);
      return { canonical: byCode, reasons };
    } else {
      reasons.push(`code:${rt}`);
    }
  } else {
    reasons.push('no-code');
  }

  reasons.push('fallback:other');
  return { canonical: 'other', reasons: reasons };
}

    function getRouteTypeMeta(routeType) {
      const t = (routeType === null || routeType === undefined || routeType === '') ? null : parseInt(routeType, 10);
      const cm = state.customRouteTypeMap || {};
      if (t !== null && !isNaN(t)) {
        if (cm[t]) return cm[t];
        if (ROUTE_TYPE_META_EXTENDED[t]) return ROUTE_TYPE_META_EXTENDED[t];
        if (ROUTE_TYPE_META_BASIC[t]) return ROUTE_TYPE_META_BASIC[t];
      }
      return cm[3] || ROUTE_TYPE_META_BASIC[3] || { label:'Other', color:'#6b7280', weight:2 };
    }

function buildLogicalRoutes(routes, agenciesIndex) {
  const groupsMap = new Map();

  for (const r of routes) {
    if (!r) continue;

    const agencyKey = (r.agency_id || '').trim().toLowerCase();
    const shortRaw = (r.route_short_name || r.route_id || '').trim();
    const shortKey = shortRaw.toLowerCase();

    const catInfo = collectRouteType(r);
    const cat = (catInfo && catInfo.canonical) ? catInfo.canonical : 'other';

    const key = agencyKey + '||' + cat + '||' + shortKey;

    if (!groupsMap.has(key)) {
      groupsMap.set(key, {
        id: key,
        agency_id: r.agency_id || '',
        route_short_name: shortRaw || r.route_id || '',
        canonical_type: cat,
        members: [],
      });
    }
    groupsMap.get(key).members.push(r);
  }

  const logicalRoutes = Array.from(groupsMap.values());

  logicalRoutes.sort((a, b) => {
    const ca = CANONICAL_CATEGORIES[a.canonical_type]?.order ?? 999;
    const cb = CANONICAL_CATEGORIES[b.canonical_type]?.order ?? 999;
    if (ca !== cb) return ca - cb;

    const na = String(a.route_short_name || '').trim();
    const nb = String(b.route_short_name || '').trim();
    return na.localeCompare(nb, undefined, { numeric: true, sensitivity: 'base' });
  });

  return logicalRoutes;
}

function getLogicalRouteKeyFromGroup(group) {
  if (!group) return null;
  return group.id || (group.agency_id || '') + '::' + (group.route_short_name || '');
}

function generateAvailableDates(calendar, calendarDates) {
  // Helper: get day of week from GTFS date
  const getDayOfWeek = (gtfsDate) => {
    const y = parseInt(gtfsDate.substring(0, 4));
    const m = parseInt(gtfsDate.substring(4, 6)) - 1;
    const d = parseInt(gtfsDate.substring(6, 8));
    return DAY_NAMES[new Date(y, m, d).getDay()];
  };
  
  // Helper: increment GTFS date by 1 day
  const incrementGTFSDate = (gtfsDate) => {
    const y = parseInt(gtfsDate.substring(0, 4));
    const m = parseInt(gtfsDate.substring(4, 6)) - 1;
    const d = parseInt(gtfsDate.substring(6, 8));
    const date = new Date(y, m, d);
    date.setDate(date.getDate() + 1);
    return Utils.formatDateToGTFS(date);
  };
  
  // Build index: date -> array of calendar_date records (performance optimization)
  const calendarDatesByDate = new Map();
  calendarDates.forEach(cd => {
    if (!cd.date) return;
    if (!calendarDatesByDate.has(cd.date)) {
      calendarDatesByDate.set(cd.date, []);
    }
    calendarDatesByDate.get(cd.date).push(cd);
  });
  
  // 🆕 KROK 1: Zbierz WSZYSTKIE możliwe daty (z calendar.txt)
  const allPossibleDates = new Set();
  
  calendar.forEach(cal => {
    if (!cal.start_date || !cal.end_date) return;
    
    let current = cal.start_date;
    while (current <= cal.end_date) {
      const dayOfWeek = getDayOfWeek(current);
      if (cal[dayOfWeek] === '1') {
        allPossibleDates.add(current);
      }
      current = incrementGTFSDate(current);
    }
  });
  
  // 🆕 KROK 2: Dla każdej daty, policz finalne serwisy
  const dateServiceCounts = new Map();
  
  allPossibleDates.forEach(dateStr => {
    const dayOfWeek = getDayOfWeek(dateStr);
    
    // Bazowe serwisy z calendar.txt
    const services = new Set();
    calendar.forEach(cal => {
      if (dateStr >= cal.start_date && dateStr <= cal.end_date && cal[dayOfWeek] === '1') {
        services.add(cal.service_id);
      }
    });
    
    // Zastosuj wyjątki z calendar_dates.txt (using indexed lookup)
    const exceptionsForDate = calendarDatesByDate.get(dateStr);
    if (exceptionsForDate) {
      exceptionsForDate.forEach(cd => {
        if (cd.exception_type === '1') services.add(cd.service_id);
        else if (cd.exception_type === '2') services.delete(cd.service_id);
      });
    }
    
    // Zapisz liczbę serwisów
    dateServiceCounts.set(dateStr, services.size);
  });
  
// 🆕 KROK 3: Dodaj daty z calendar_dates.txt (exception_type=1)
// OPTYMALIZACJA: iteruj przez unikalne daty zamiast wszystkie wiersze
calendarDatesByDate.forEach((exceptions, dateStr) => {
  if (!dateServiceCounts.has(dateStr)) {
    const services = new Set();
    exceptions.forEach(cd => {
      if (cd.exception_type === '1') services.add(cd.service_id);
    });
    if (services.size > 0) {
      dateServiceCounts. set(dateStr, services.size);
    }
  }
});
  
  // 🆕 KROK 4: Filtruj - zostaw tylko daty z > 0 serwisów
  const finalDates = Array.from(dateServiceCounts.entries())
    .filter(([date, count]) => count > 0)
    .map(([date, count]) => date)
    .sort();
  
  // KROK 5: Formatuj do UI
  return finalDates.map(dateStr => {
    const date = Utils.parseGTFSDate(dateStr);
    if (!date) return { value: dateStr, label: dateStr };
    const dd = String(date.getDate()).padStart(2, '0');
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const yyyy = String(date.getFullYear());
    return { value: dateStr, label: `${dd}-${mm}-${yyyy}` };
  });
}
	  
function getServicesForDate(dateStr) {
  if (!state.gtfsData) return [];
  
  // Helper: get day of week from GTFS date string (YYYYMMDD)
  const getDayOfWeek = (gtfsDate) => {
    const y = parseInt(gtfsDate.substring(0, 4));
    const m = parseInt(gtfsDate.substring(4, 6)) - 1;
    const d = parseInt(gtfsDate.substring(6, 8));
    return new Date(y, m, d).getDay();
  };
  
  const dayOfWeek = DAY_NAMES[getDayOfWeek(dateStr)];
  const services = new Set();
  
  // Bazowe serwisy z calendar. txt
  state.gtfsData.calendar.forEach(cal => {
    if (dateStr >= cal.start_date && dateStr <= cal.end_date && cal[dayOfWeek] === '1') {
      services.add(cal.service_id);
    }
  });
  
  // ✅ FIXED: Use indexed lookup (requires calendarDatesByDateIndex in state)
  if (state.gtfsData.calendarDatesByDateIndex) {
    const exceptionsForDate = state.gtfsData.calendarDatesByDateIndex.get(dateStr);
    if (exceptionsForDate) {
      exceptionsForDate.forEach(cd => {
        if (cd.exception_type === '1') services.add(cd.service_id);
        else if (cd.exception_type === '2') services.delete(cd.service_id);
      });
    }
  }
  
  return Array.from(services);
}

    /**
     * Get a representative weekday date (Monday-Friday)
     * Prefers FUTURE dates, falls back to PAST if no future weekday exists
     */
    function getWeekdayDate() {
      const today = Utils.parseGTFSDate(state.selectedDate);
      if (!today) return findDateForDayOfWeek(3); // Wednesday as fallback
      const currentDayOfWeek = today.getDay();
      
      // If today is a weekday (Mon-Fri), use it
      if (currentDayOfWeek >= 1 && currentDayOfWeek <= 5) return state.selectedDate;
      
      // Otherwise find nearest future or past weekday (prefer Wednesday)
      return findDateForDayOfWeek(3); // Wednesday
    }

    /**
     * Find a date for a specific day of week
     * Strategy: prefer FUTURE dates, fallback to PAST
     * @param {number} targetDayOfWeek - 0=Sunday, 1=Monday, ..., 6=Saturday
     * @returns {string|null} - GTFS date string (YYYYMMDD)
     */
function findDateForDayOfWeek(targetDayOfWeek) {
  if (!state.selectedDate) return null;
  
  // Helper: get day of week from GTFS date
  const getDayOfWeek = (gtfsDate) => {
    const y = parseInt(gtfsDate.substring(0, 4));
    const m = parseInt(gtfsDate.substring(4, 6)) - 1;
    const d = parseInt(gtfsDate.substring(6, 8));
    return new Date(y, m, d).getDay();
  };
  
  // Helper: add days to GTFS date
  const addDays = (gtfsDate, days) => {
    const y = parseInt(gtfsDate.substring(0, 4));
    const m = parseInt(gtfsDate.substring(4, 6)) - 1;
    const d = parseInt(gtfsDate.substring(6, 8));
    const date = new Date(y, m, d);
    date.setDate(date.getDate() + days);
    return Utils.formatDateToGTFS(date);
  };
  
  const currentDayOfWeek = getDayOfWeek(state.selectedDate);
  
  // If today matches, use it
  if (currentDayOfWeek === targetDayOfWeek) return state.selectedDate;
  
  // Try FUTURE dates first (next 7 days)
  for (let i = 1; i <= 7; i++) {
    const testDate = addDays(state.selectedDate, i);
    if (getDayOfWeek(testDate) === targetDayOfWeek) {
      return testDate;
    }
  }
  
  // Fallback to PAST dates (previous 7 days)
  for (let i = 1; i <= 7; i++) {
    const testDate = addDays(state.selectedDate, -i);
    if (getDayOfWeek(testDate) === targetDayOfWeek) {
      return testDate;
    }
  }
  
  return null;
}

function buildStationNameCache(stopsIndex) {
  if (stationNameToIdCache) return stationNameToIdCache;
  
  stationNameToIdCache = new Map();
  
  const parentStationIds = new Set();
  Object.values(stopsIndex).forEach(stop => {
    if (stop.parent_station && stop.parent_station.trim()) {
      parentStationIds.add(stop.parent_station.trim());
    }
  });
  
  // For each parent station, save the mapping name → stop_id
  parentStationIds.forEach(parentId => {
    const parentStop = stopsIndex[parentId];
    if (parentStop?.stop_name) {
      const normalizedName = parentStop.stop_name.trim().replace(/\s+/g, ' ');
      stationNameToIdCache.set(normalizedName, parentId);
    }
  });
  
  return stationNameToIdCache;
}

function getStationId(stopId, stopsIndex) {
  const stop = stopsIndex[stopId];
  if (!stop) return stopId;
  
  const parent = stop.parent_station;
  if (parent && parent.trim() !== '') {
    return parent.trim();
  }
  
  // PRIORYTET 2: Sprawdź czy nazwa pasuje do znanej stacji głównej
  if (stop.stop_name) {
    const normalizedName = stop.stop_name.trim().replace(/\s+/g, ' ');
    const cache = buildStationNameCache(stopsIndex);
    
    if (cache.has(normalizedName)) {
      return cache.get(normalizedName);
    }
    
    // Fallback: zwróć znormalizowaną nazwę
    return normalizedName;
  }
  
  return stopId;
}

function getStationIdWithPolicy(stopId, stopsIndex, allowedStationSet) {
  const stationId = getStationId(stopId, stopsIndex);
  if (!allowedStationSet || allowedStationSet.has(stationId)) return stationId;
  return stopId; // no merge if not allowed
}

// ═══════════════════════════════════════════════════════════════
// 6. ROUTE PROFILE & ANALYSIS
// ═══════════════════════════════════════════════════════════════
// === KROK 1: Budowa grafu trasy i profilu core dla logical route ===

// Note: This is used during classification to treat on-demand (2,3) as regular passenger (0)
function normalizePickupDropoffType(value) {
  const normalized = String(value || '0').trim();
  // 2 = phone agency, 3 = coordinate with driver → treat as 0 (passenger)
  if (normalized === '2' || normalized === '3') return '0';
  return normalized;
}

function calculateStopEdgeFrequency(trips, tripStopMaps, stopsIndex) {
  const edgeFrequency = {};
  const totalTrips = trips.length;
  
  if (totalTrips === 0) {
    return edgeFrequency;
  }
  
  trips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    
    // Convert stops to stations first
    const stationIds = stops.map(st => getStationId(st.stop_id, stopsIndex));
    
    // Count STATION-level edges
    for (let i = 0; i < stationIds.length - 1; i++) {
      const edge = stationIds[i] + '->' + stationIds[i + 1];
      edgeFrequency[edge] = (edgeFrequency[edge] || 0) + 1;
    }
  });
  
  // Normalize to frequencies (0-1 range)
  Object.keys(edgeFrequency).forEach(key => {
    edgeFrequency[key] = edgeFrequency[key] / totalTrips;
  });
  
  return edgeFrequency;
}

function computeCoreBoundaryFrequency(edgeFrequency, coreStops) {
  // For each non-core stop, compute max frequency of edges connecting to any core stop
  const boundaryFreq = new Map();
  const coreSet = new Set(coreStops);
  
  Object.entries(edgeFrequency).forEach(([edge, freq]) => {
    const [from, to] = edge.split('->');
    
    const fromIsCore = coreSet.has(from);
    const toIsCore = coreSet.has(to);
    
    if (fromIsCore && !toIsCore) {
      const current = boundaryFreq.get(to) || 0;
      boundaryFreq.set(to, Math.max(current, freq));
    } else if (!fromIsCore && toIsCore) {
      const current = boundaryFreq.get(from) || 0;
      boundaryFreq.set(from, Math.max(current, freq));
    }
  });
  
  return boundaryFreq;
}

function findLowFrequencyCandidates(edgeFrequency, allStationIds, threshold = 0.10) {
  const tier1 = new Set();  // <6%
  const tier2 = new Set();  // 6-10%
  
  allStationIds.forEach(stationId => {
    const edges = Object.keys(edgeFrequency).filter(e => 
      e.startsWith(stationId + '->') || e.endsWith('->' + stationId)
    );
    
    const allLowFreq = edges.every(e => edgeFrequency[e] < threshold);
    
    // Skip if not a low-frequency candidate or has no edges
    if (!allLowFreq || edges.length === 0) return;
    
    const maxEdgeFreq = Math.max(...edges.map(e => edgeFrequency[e]));
    
    // Classify into tiers
    if (maxEdgeFreq < 0.06) {
      tier1.add(stationId);
    } else if (maxEdgeFreq < threshold) {
      tier2.add(stationId);
    }
  });
  
  return { tier1, tier2 };
}

function isStopBetweenCore(stopId, trip, coreStart, coreEnd, stopsIndex) {
  let stopIdx = -1;
  let coreStartIdx = -1;
  let coreEndIdx = -1;
  
  // Convert to station IDs for comparison
  const stationId = getStationId(stopId, stopsIndex);
  
  for (let i = 0; i < trip.length; i++) {
    const tripStationId = getStationId(trip[i].stop_id, stopsIndex);
    if (tripStationId === stationId) stopIdx = i;
    if (tripStationId === coreStart) coreStartIdx = i;
    if (tripStationId === coreEnd) coreEndIdx = i;
  }
  
  // If stop is between coreStart and coreEnd → it's a passenger branch
  // Handle both forward and reverse directions
  if (coreStartIdx !== -1 && coreEndIdx !== -1 && stopIdx !== -1) {
    const minCoreIdx = Math.min(coreStartIdx, coreEndIdx);
    const maxCoreIdx = Math.max(coreStartIdx, coreEndIdx);
    return stopIdx > minCoreIdx && stopIdx < maxCoreIdx;
  }
  
  return false;
}

function classifyTailStopsRecursive(candidateTiers, trips, tripStopMaps, stopTimesIndex, coreStations, stopsIndex) {
  const nodeTypes = {};
  const coreSet = new Set(coreStations);
  
  if (!coreStations || coreStations.length === 0) {
    return nodeTypes;
  }
  
  const coreStart = coreStations[0];
  const coreEnd = coreStations[coreStations.length - 1];
  
  const tier1Candidates = candidateTiers.tier1 || new Set();
  const tier2Candidates = candidateTiers.tier2 || new Set();
  
  let changed = true;
  let iterations = 0;
  const MAX_ITERATIONS = 10;
  
  // Initialize core stations with 'core' classification
  coreStations.forEach(stationId => {
    nodeTypes[stationId] = 'core';
  });
  
  const classifyCandidate = (candidateId, fallbackType) => {
    // Skip if already classified
    if (nodeTypes[candidateId]) return false;
    
    let appearsBetweenCore = false;
    
    for (const trip of trips) {
      const stops = tripStopMaps[trip.trip_id] || [];
      if (isStopBetweenCore(candidateId, stops, coreStart, coreEnd, stopsIndex)) {
        appearsBetweenCore = true;
        break;
      }
    }
    
    if (appearsBetweenCore) {
      // Appears between core → passenger branch
      nodeTypes[candidateId] = 'passenger';
      return true;
    }
    
    let hasPickup1 = false;
    let hasDropoff1 = false;
    let hasNormalFlags = false;
    
    // Check all stops that belong to this station
    trips.forEach(trip => {
      const stopTimes = stopTimesIndex[trip.trip_id] || [];
      stopTimes.forEach(st => {
        const stationId = getStationId(st.stop_id, stopsIndex);
        if (stationId === candidateId) {
          const pickup = normalizePickupDropoffType(st.pickup_type);
          const dropoff = normalizePickupDropoffType(st.drop_off_type);
          
          if (pickup === '1' || dropoff === '1') {
            if (pickup === '1') hasPickup1 = true;
            if (dropoff === '1') hasDropoff1 = true;
          } else {
            hasNormalFlags = true;
          }
        }
      });
    });
    
    // If ANY occurrence has pickup=1 OR dropoff=1 → tail
    if (hasPickup1 || hasDropoff1) {
      nodeTypes[candidateId] = 'tail';
      return true;
    }
    
    // TEST 3: If all flags are 0/0 (after normalization) → recursive test
    if (hasNormalFlags) {
      const tripsWithCandidate = trips.filter(trip => {
        const stops = tripStopMaps[trip.trip_id] || [];
        return stops.some(s => getStationId(s.stop_id, stopsIndex) === candidateId);
      });
      
      let allTripsHaveOtherTails = true;
      
      for (const trip of tripsWithCandidate) {
        const stops = tripStopMaps[trip.trip_id] || [];
        
        const stopsOutsideCore = stops.filter(s => !coreSet.has(getStationId(s.stop_id, stopsIndex)));
        
        const hasTailOnRoute = stopsOutsideCore.some(s => {
          const stationId = getStationId(s.stop_id, stopsIndex);
          return stationId !== candidateId && nodeTypes[stationId] === 'tail';
        });
        
        if (!hasTailOnRoute) {
          allTripsHaveOtherTails = false;
          break;
        }
      }
      
      if (allTripsHaveOtherTails && tripsWithCandidate.length > 0) {
        // All trips with this stop have a tail → this is part of depot route
        nodeTypes[candidateId] = 'tail';
        return true;
      }
    }
    
    // FALLBACK: Apply tier-specific default
    if (!nodeTypes[candidateId]) {
      nodeTypes[candidateId] = fallbackType;
      return true; // Count as changed when we make any classification
    }
    
    return false;
  };
  
  while (changed && iterations < MAX_ITERATIONS) {
    changed = false;
    iterations++;
    
    // Process TIER 1 first (ultra-low, bias: TAIL)
    tier1Candidates.forEach(candidateId => {
      if (classifyCandidate(candidateId, 'tail')) {
        changed = true;
      }
    });
    
    // Then process TIER 2 (low, bias: PASSENGER)
    tier2Candidates.forEach(candidateId => {
      if (classifyCandidate(candidateId, 'passenger')) {
        changed = true;
      }
    });
  }
  
  return nodeTypes;
}

function getCurrentRouteProfile() {
  if (!state.selectedRoute || !state.gtfsData) return null;

  const dir = state.selectedDirection || '0';

  let key;
  if (state.selectedRouteGroup) {
    key = getLogicalRouteKeyFromGroup(state.selectedRouteGroup);
    if (!key) return null;
  } else {
    key = 'raw::' + (state.selectedRoute.route_id || '');
  }

  // Sprawdź czy pełny profile już istnieje (cache)
  if (state.routeProfiles[key] && state.routeProfiles[key][dir]) {
    return state.routeProfiles[key][dir];
  }

  // NIE MA - zbuduj teraz (lazy loading)
  return buildRouteProfileForCurrentSelection();
}

function buildRouteProfileForCurrentSelection() {
  if (!state.selectedRoute || !state.gtfsData) return null;

  const dir = state.selectedDirection || '0';

  // 1. Ustal klucz logicznej linii
  let key;
  let memberRoutes = [];

  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    key = getLogicalRouteKeyFromGroup(state.selectedRouteGroup);
    memberRoutes = state.selectedRouteGroup.members;
  } else {
    key = 'raw::' + (state.selectedRoute.route_id || '');
    memberRoutes = [state.selectedRoute];
  }

  if (!key) return null;

  // 2. Cache
  if (state.routeProfiles[key] && state.routeProfiles[key][dir]) {
    return state.routeProfiles[key][dir];
  }

  const { tripsIndex, stopsIndex } = state.gtfsData;
  const stopTimesIndex = getStopTimesIndexOrCache();
  if (!stopTimesIndex || !tripsIndex || !stopsIndex) return null;

  // 3. Zbierz trips tej logical linii + kierunku (bez filtra daty)
  let routeIds = memberRoutes.map(r => r.route_id).filter(Boolean);
  if (!routeIds.length) return null;

  let allTrips = [];
  routeIds.forEach(rid => {
    const ts = tripsIndex[rid] || [];
    allTrips = allTrips.concat(ts);
  });

  allTrips = allTrips.filter(t => (t.direction_id || '0') === dir);
  if (!allTrips.length) return null;

  const CORE_THRESHOLD = 0.10; // 10%

  const stationEdgeFrequency = {};
  const allTripStationData = []; // będziemy potrzebować później

  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];
    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));
    
    const stationIds = sts.map(st => getStationId(st.stop_id, stopsIndex));
    const stopIds = sts.map(st => st.stop_id);
    
    // Zapisz dane tripu do późniejszego użycia
    allTripStationData.push({
      tripId: trip.trip_id,
      stationIds: stationIds,
      stopIds: stopIds
    });
    
    // Zlicz krawędzie
    for (let i = 0; i < stationIds.length - 1; i++) {
      const edge = stationIds[i] + '→' + stationIds[i + 1];
      stationEdgeFrequency[edge] = (stationEdgeFrequency[edge] || 0) + 1;
    }
  });

  const totalTripsCount = allTrips.length;
  const coreStationsSet = new Set();

  Object.entries(stationEdgeFrequency).forEach(([edge, count]) => {
    if (count / totalTripsCount >= CORE_THRESHOLD) {
      const [from, to] = edge.split('→');
      coreStationsSet.add(from);
      coreStationsSet.add(to);
    }
  });

  const tripCoreIndices = {};
  allTripStationData.forEach(({ tripId, stationIds, stopIds }) => {
    const isCore = stationIds.map(sid => coreStationsSet.has(sid));
    const firstCoreIdx = isCore.indexOf(true);
    const lastCoreIdx = isCore.lastIndexOf(true);
    
    tripCoreIndices[tripId] = {
      firstCoreIdx,
      lastCoreIdx,
      stationIds,
      stopIds
    };
  });

  // 4. Graf z stop_sequence + pickup/drop_off (pasażerski)
  const nodes = {}; // stationId → info
  const edges = {}; // "A->B" → info
  const tripCount = allTrips.length;
  const stationToStopIds = new Map(); // stationId → Set of stop_ids

  function edgeKey(a, b) {
    return a + '->' + b;
  }

  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];

    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => (parseInt(a.stop_sequence || '0', 10) - parseInt(b.stop_sequence || '0', 10)));

    // First pass: track all stop IDs for each station (for core expansion later)
    sts.forEach(st => {
      const stationId = getStationId(st.stop_id, stopsIndex);
      if (!stationToStopIds.has(stationId)) {
        stationToStopIds.set(stationId, new Set());
      }
      stationToStopIds.get(stationId).add(st.stop_id);
    });

    // Second pass: build passenger graph
    const passengerStops = [];
    sts.forEach(st => {
      const pickup = st.pickup_type;
      const dropoff = st.drop_off_type;

      // GTFS: 1 = no pickup/dropoff; 0 = normal
      if (pickup === '1' && dropoff === '1') {
        return; // stricte techniczne – pomijamy
      }

      // Use station_id for classification (merge platforms)
      const stationId = getStationId(st.stop_id, stopsIndex);
      
      passengerStops.push({ ...st, stationId });
      
      if (!nodes[stationId]) {
        const stop = stopsIndex[st.stop_id] || {};
        nodes[stationId] = {
          id: stationId,
          name: stop.stop_name || stationId,
          visitCount: 0,
          inDegree: 0,
          outDegree: 0,
        };
      }
      nodes[stationId].visitCount++;
    });

    for (let i = 0; i < passengerStops.length - 1; i++) {
      const a = passengerStops[i].stationId;
      const b = passengerStops[i + 1].stationId;
      const k = edgeKey(a, b);
      if (!edges[k]) {
        edges[k] = {
          from: a,
          to: b,
          count: 0,
          trips: new Set(),
        };
      }
      edges[k].count++;
      edges[k].trips.add(trip.trip_id);
      if (nodes[a]) nodes[a].outDegree++;
      if (nodes[b]) nodes[b].inDegree++;
    }
  });

  // 5. Wstępne „mocne” krawędzie jako kandydaci kręgosłupa
  const coreEdges = new Set();
  const minCoreFraction = 0.4; // heurystyka: ≥ 40% trips

  Object.values(edges).forEach(e => {
    const frac = e.count / tripCount;
    if (frac >= minCoreFraction) {
      coreEdges.add(edgeKey(e.from, e.to));
    }
  });

  // 6. Z coreEdges spróbuj zbudować najdłuższą ścieżkę
  const coreAdj = {};
  const coreInDeg = {};
  coreEdges.forEach(k => {
    const e = edges[k];
    if (!e) return;
    if (!coreAdj[e.from]) coreAdj[e.from] = [];
    coreAdj[e.from].push(e.to);
    coreInDeg[e.to] = (coreInDeg[e.to] || 0) + 1;
    if (!coreInDeg[e.from]) coreInDeg[e.from] = coreInDeg[e.from] || 0;
  });

  const coreStartCandidates = Object.keys(coreInDeg).filter(sid => (coreInDeg[sid] || 0) === 0);
  const visitedCore = new Set();
  let bestCorePath = [];

  function dfsCore(startId, path) {
    path.push(startId);
    visitedCore.add(startId);
    const nexts = coreAdj[startId] || [];
    if (!nexts.length) {
      if (path.length > bestCorePath.length) {
        bestCorePath = path.slice();
      }
    } else {
      nexts.forEach(nid => {
        if (!visitedCore.has(nid)) {
          dfsCore(nid, path);
        } else {
          if (path.length > bestCorePath.length) {
            bestCorePath = path.slice();
          }
        }
      });
    }
    path.pop();
    visitedCore.delete(startId);
  }

  if (coreStartCandidates.length) {
    coreStartCandidates.forEach(sid => dfsCore(sid, []));
  } else {
    Object.keys(coreAdj).forEach(sid => dfsCore(sid, []));
  }

  // bestCorePath contains station IDs; expand to stop IDs for backward compatibility
  const coreStationIds = bestCorePath.filter(sid => nodes[sid]);
  const coreStops = coreStationIds.flatMap(stationId => 
    Array.from(stationToStopIds.get(stationId) || [])
  );

  const coreStationIdsSet = new Set(coreStationIds);

  const edgeTypes = {};
  Object.keys(edges).forEach(k => {
    const e = edges[k];
    if (coreStationIdsSet.has(e.from) && coreStationIdsSet.has(e.to) && coreEdges.has(k)) {
      edgeTypes[k] = 'core';
    } else {
      edgeTypes[k] = 'noncore';
    }
  });

// --- 7. NEW: Recursive Tail Detection Algorithm ---
  
  // 7.1: Build tripStopMaps for the helper functions
  const tripStopMaps = {};
  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];
    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));
    tripStopMaps[trip.trip_id] = sts;
  });
  
  // 7.2: Calculate edge frequency at STATION level
  const edgeFrequency = calculateStopEdgeFrequency(allTrips, tripStopMaps, stopsIndex);
  
  // 7.3: Find all STATION IDs (not stop IDs)
  const allStationIds = new Set();
  allTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(st => {
      const stationId = getStationId(st.stop_id, stopsIndex);
      allStationIds.add(stationId);
    });
  });
  
  // 7.4: Find low-frequency candidates at STATION level
  const candidateTiers = findLowFrequencyCandidates(edgeFrequency, Array.from(allStationIds), 0.10);
  
  // 7.4b: Core-boundary frequency gating
  const boundaryFreq = computeCoreBoundaryFrequency(edgeFrequency, coreStationIds);
  const tier1Boundary = new Set();
  const tier2Boundary = new Set();
  
  boundaryFreq.forEach((freq, stationId) => {
    if (freq < 0.06) {
      tier1Boundary.add(stationId);
    } else if (freq < 0.10) {
      tier2Boundary.add(stationId);
    }
  });
  
  const mergedTiers = {
    tier1: new Set([...candidateTiers.tier1, ...tier1Boundary]),
    tier2: new Set([...candidateTiers.tier2, ...tier2Boundary])
  };
  
  // 7.5: Classify stations recursively with tier-specific fallbacks
  const stationNodeTypes = classifyTailStopsRecursive(
    mergedTiers,
    allTrips,
    tripStopMaps,
    stopTimesIndex,
    coreStationIds,
    stopsIndex
  );
  
  // 7.6: Expand station-level classifications to individual stops
  const nodeTypes = {};
  allTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(st => {
      const stationId = getStationId(st.stop_id, stopsIndex);
      const classification = stationNodeTypes[stationId] || 'passenger';
      nodeTypes[st.stop_id] = classification;
    });
  });
  
  // 7.7: Ensure all stops have a classification (fallback to 'passenger' for safety)
  // Using 'passenger' instead of 'noncore' ensures unclassified stops are visible
  allTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(st => {
      if (!nodeTypes[st.stop_id]) {
        nodeTypes[st.stop_id] = 'passenger';
      }
    });
  });

  // 8. Collect detailed stop metadata (pickup/drop_off types, positions in routes)
  const stopMetadata = {}; // stop_id → { hasPickup1: bool, hasDropOff1: bool, isOnDemand: bool, isFirstWithNoPickup: bool, isLastWithNoDropOff: bool }
  
  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];
    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => (parseInt(a.stop_sequence || '0', 10) - parseInt(b.stop_sequence || '0', 10)));
    
    sts.forEach((st, i) => {
      const stId = st.stop_id;
      const pType = String(st.pickup_type || '0').trim();
      const dType = String(st.drop_off_type || '0').trim();
      
      if (!stopMetadata[stId]) {
        stopMetadata[stId] = {
          hasPickup1: false,
          hasDropOff1: false,
          isStrictlyTechnical: false,
          isOnDemand: false,
          isFirstWithNoPickup: false,
          isLastWithNoDropOff: false,
        };
      }
      
      const meta = stopMetadata[stId];
      
      // Zbierz informacje o pickup/drop_off types
      if (pType === '1') meta.hasPickup1 = true;
      if (dType === '1') meta.hasDropOff1 = true;
      if (pType === '1' && dType === '1') meta.isStrictlyTechnical = true;
      if (pType === '2' || pType === '3' || dType === '2' || dType === '3') {
        meta.isOnDemand = true;
      }
      
      // Sprawdź czy to pierwszy przystanek z pickup_type=1
      if (i === 0 && pType === '1') {
        meta.isFirstWithNoPickup = true;
      }
      
      // Sprawdź czy to ostatni przystanek z drop_off_type=1
      if (i === sts.length - 1 && dType === '1') {
        meta.isLastWithNoDropOff = true;
      }
    });
  });

  // 10. Process trips: detect passenger stops, classify service vs depot
  const processedTrips = {};
  
  // Threshold for short trip classification: trips with ≤2 passenger stops
  // use simpler classification (just check if any passenger stops exist)
  const SHORT_TRIP_THRESHOLD = 2;
  
  allTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    let pStops = [];
    let firstCoreIdx = -1;
    let lastCoreIdx = -1;
    
    // Find core boundaries (in RAW stops, not filtered)
    if (coreStops && coreStops.length > 0) {
      const coreStopsSet = new Set(coreStops);
      for (let i = 0; i < stops.length; i++) {
        if (coreStopsSet.has(stops[i].stop_id)) {
          if (firstCoreIdx === -1) firstCoreIdx = i;
          lastCoreIdx = i;
        }
      }
    }
    
    let hasPassenger = false;
    let hasPassengerInsideCore = false;
    
    // Filter stops: remove tail stops, build pStops
    for (let i = 0; i < stops.length; i++) {
      const st = stops[i];
      const sId = st.stop_id;
      
      // Use nodeTypes from profile (already computed at station-level!)
      const profileNodeType = nodeTypes[sId];
      
      let isStopTech = false;
      
      if (profileNodeType === 'tail') {
        // Depot/technical stop
        isStopTech = true;
      } else {
        // 'passenger' or 'core' or undefined → show as passenger
        isStopTech = false;
      }
      
      if (!isStopTech) {
        // Check for on-demand service
        const pType = st.pickup_type ? String(st.pickup_type).trim() : "0";
        const dType = st.drop_off_type ? String(st.drop_off_type).trim() : "0";
        const isOnDemand = (pType === "2" || pType === "3" || dType === "2" || dType === "3");
        
        pStops.push({ ...st, isOnDemand });
        hasPassenger = true;
        
        // Check if inside core segment
        if (firstCoreIdx !== -1 && lastCoreIdx !== -1 && i >= firstCoreIdx && i <= lastCoreIdx) {
          hasPassengerInsideCore = true;
        }
      }
    }
    
    // Classify as service or depot trip
    // Business rule:
    // - For trips with ≤SHORT_TRIP_THRESHOLD passenger stops: if ANY passenger stops exist, it's a service trip
    // - For trips with 3+ passenger stops: requires passenger stops BETWEEN first and last core stops
    //   (this distinguishes regular service from depot/yard movements that only touch core at endpoints)
    const isServiceTrip = pStops.length <= SHORT_TRIP_THRESHOLD 
      ? hasPassenger 
      : hasPassengerInsideCore;
    
    processedTrips[trip.trip_id] = {
      pStops: pStops,
      hasPassenger: hasPassenger,
      hasPassengerInsideCore: hasPassengerInsideCore,
      isServiceTrip: isServiceTrip,
      firstCoreIdx: firstCoreIdx,
      lastCoreIdx: lastCoreIdx
    };
  });
 
  const stationsWithConsecutiveStops = new Set();
  const allStations = new Set();
  
  Object.entries(processedTrips).forEach(([tripId, tripData]) => {
    const pStops = tripData.pStops || [];
    
    // Filter pStops the same way the table does:
    // 1. Exclude strictly technical stops (pickup_type=1 AND drop_off_type=1)
    // 2. Exclude on-demand-only stops in some cases (though we'll keep them for now)
    const visibleStops = pStops.filter(st => {
      const meta = stopMetadata[st.stop_id];
      if (!meta) return true; // If no metadata, assume visible
      
      // Exclude strictly technical stops (no pickup AND no drop-off)
      if (meta.isStrictlyTechnical) {
        return false;
      }
      
      return true;
    });
    
    // Get station IDs for the visible stops
    const visibleStationIds = visibleStops.map(st => getStationId(st.stop_id, stopsIndex));
    const visibleStopIds = visibleStops.map(st => st.stop_id);
       
    // Collect all stations
    visibleStationIds.forEach(stationId => allStations.add(stationId));
    
    // Check for consecutive stops in the VISIBLE sequence
    for (let i = 0; i < visibleStationIds.length - 1; i++) {
      if (visibleStationIds[i] === visibleStationIds[i + 1]) {
        stationsWithConsecutiveStops.add(visibleStationIds[i]);
      }
    }
  });
   
  // Only allow merging for stations without consecutive stops in visible sequences
  const stationMergeAllowed = new Set();
  allStations.forEach(stationId => {
    if (!stationsWithConsecutiveStops.has(stationId)) {
      stationMergeAllowed.add(stationId);
    }
  });

  // 11. Save profile to state
  if (!state.routeProfiles[key]) state.routeProfiles[key] = {};
  const profile = {
    key,
    direction: dir,
    tripCount,
    nodes,
    edges: Object.fromEntries(
      Object.entries(edges).map(([k, e]) => [k, { ...e, trips: Array.from(e.trips), type: edgeTypes[k] }])
    ),
    coreStops,
    nodeTypes,
    stopMetadata,
    coreStationsSet,
    tripCoreIndices,
    stationMergeAllowed,
    processedTrips,
    version: 3,
  };
  state.routeProfiles[key][dir] = profile;
  return profile;
}


function createTripMappings(sortedTrips, tripStopMaps, masterList) {
  return sortedTrips.map(trip => {
    const mapping = {}; let lastM = -1;
    const tripStops = tripStopMaps[trip.trip_id] || [];
    tripStops.forEach(s => {
      const sId = s.stop_id;
      for (let i = lastM+1;i<masterList.length;i++){
if ((masterList[i].stopIds && masterList[i].stopIds.includes(sId)) || 
    (!masterList[i].stopIds && masterList[i].id === sId)) {
  mapping[i] = s;
  lastM = i;
  break;
}
      }
    });
    return mapping;
  });
}

// ═══════════════════════════════════════════════════════════════
// 6B. CANONICAL MASTER LIST (STABLE ROW ORDER)
// ═══════════════════════════════════════════════════════════════
// 
// PURPOSE: Create a stable, canonical master list of stops (rows) per route/group and direction.
// The canonical list is built ONCE from ALL trips (no date filter, tail included) and cached.
// At render time, only row VISIBILITY is filtered - rows are never reordered.
// 
// ALGORITHM:
// 1. Use route profile's coreStops to define segments:
//    - Pre-core: stops before first core (variant starting points)
//    - Windows: stops between consecutive core stations (branches)
//    - Post-core: stops after last core (variant ending points)
// 2. For each segment, collect all stations that appear in that segment
// 3. Rank stations by median normalized position within the segment
// 4. Stable tie-breaking: name (alphabetical), then stop_id
// 5. Build canonical rows: pre-core, first core, [windows with branches], last core, post-core
// 6. Preserve nodeType (tail/passenger/core) from profile for each row
// 
// RENDERING:
// - Rows are filtered by: (a) tail toggle, (b) date (no departures = hidden)
// - Row order NEVER changes - only visibility
// - Columns (trips) are reordered separately using adjacent-swaps algorithm for chronological order
// 
// CACHE INVALIDATION:
// - On GTFS load (new data)
// - On route/group change
// - On direction change
// ═══════════════════════════════════════════════════════════════
function getCanonicalKeyForCurrentSelection() {
  if (!state.selectedRoute) return null;
  
  let key;
  if (state.selectedRouteGroup) {
    key = getLogicalRouteKeyFromGroup(state.selectedRouteGroup);
  } else {
    key = 'raw::' + (state.selectedRoute.route_id || '');
  }
  return key;
}

function buildCanonicalMasterList(profile, allTrips, stopTimesIndex, stopsIndex) {
  if (!profile || !profile.coreStops || profile.coreStops.length === 0) {
    return null; // Fallback to old behavior
  }

  const coreStops = profile.coreStops;
  const nodeTypes = profile.nodeTypes || {};
  const allowedSet = profile.stationMergeAllowed;
  
  const getStationDisplayName = (stationId, stopIds) => {
    if (stopsIndex[stationId]?.stop_name) {
      return stopsIndex[stationId].stop_name;
    }
    const firstStop = stopsIndex[stopIds[0]];
    return firstStop?.stop_name || stationId;
  };

  // Sort and prepare trips
  const sortedTrips = allTrips.slice();
  const tripStopMaps = {};
  sortedTrips.forEach(trip => {
    const stopTimes = stopTimesIndex[trip.trip_id] || [];
    const sortedStops = stopTimes
      .filter(st => st && st.stop_id)
      .sort((a, b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));
    tripStopMaps[trip.trip_id] = sortedStops;
  });

  // Step 0: Collect all platforms for each station
  const stationToAllStopIds = new Map();
  
  console.log(`[DEBUG] Masterlist building - collecting platforms:`);
  sortedTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    
    stops.forEach(stopTime => {
      const stopId = stopTime.stop_id;
      const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
      
      // Debug first occurrence
      if (!stationToAllStopIds.has(stationId)) {
        console.log(`  New station: "${stationId}" (from stopId "${stopId}")`);
      }
      
      // Collect all platforms globally
      if (!stationToAllStopIds.has(stationId)) {
        stationToAllStopIds.set(stationId, new Set());
      }
      stationToAllStopIds.get(stationId).add(stopId);
    });
  });
  
  // Convert Sets to Arrays once for efficiency
  stationToAllStopIds.forEach((stopIdsSet, stationId) => {
    const stopIdsArray = Array.from(stopIdsSet);
    stationToAllStopIds.set(stationId, stopIdsArray);

  });


  // Step 1: Build trip sequences with occurrence tracking
  const tripSequences = new Map();

  sortedTrips.forEach(trip => {
    const occurrenceCount = new Map();
    const stops = tripStopMaps[trip.trip_id] || [];
    
    const sequence = stops.map((stopTime, idx) => {
      const stopId = stopTime.stop_id;
      const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
      
      // Determine if we're entering a different station (new or returning after visiting others)
      // This enables proper occurrence counting for loops (e.g., A→B→A becomes occurrence 1 and 2)
      const prevStationId = idx > 0 
        ? getStationIdWithPolicy(stops[idx - 1].stop_id, stopsIndex, allowedSet)
        : null;
      
      // Increment occurrence counter when transitioning to a different station
      if (prevStationId !== stationId) {
        occurrenceCount.set(stationId, (occurrenceCount.get(stationId) || 0) + 1);
      }
      
      return {
        stopId,
        stationId,
        occurrence: occurrenceCount.get(stationId)
      };
    });
    
    tripSequences.set(trip.trip_id, sequence);
  });

  // Step 2: Build masterlist with conditional merging
  const masterList = [];
  const masterListMap = new Map(); // String key → index for O(1) lookup

  // === Step 1.5 - Build core stations skeleton FIRST ===
  // This ensures core stations appear in correct topological order
  const seenCoreStations = new Set();

  coreStops.forEach(stopId => {
    const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
    
    if (!seenCoreStations.has(stationId)) {
      seenCoreStations.add(stationId);
      
      // Get all stop IDs for this station
      const stopIdsForStation = stationToAllStopIds.get(stationId) || [stopId];
      
      const coreEntry = {
        id: stopIdsForStation[0],
        name: getStationDisplayName(stationId, [stopId]),
        stopIds: stopIdsForStation,
        stationId,
        occurrence: 1, // Core stations always occurrence 1
        nodeType: nodeTypes[stopId] || 'passenger'
      };
      
      masterList.push(coreEntry);
      
      // Add to map
      const key = `${stationId}::1`;
      masterListMap.set(key, masterList.length - 1);
    }
  });

  // === THEN Step 2: Process trip sequences for branches and loops ===
  tripSequences.forEach((sequence, tripId) => {
    let lastMasterIdx = -1;
    
    sequence.forEach(({stopId, stationId, occurrence}) => {
      // Create lookup key - just use stationId and occurrence
      const lookupKey = `${stationId}::${occurrence}`;
      
      const existingIdx = masterListMap.get(lookupKey);
      
      if (existingIdx !== undefined) {
        lastMasterIdx = existingIdx;
      } else {
        // Create new entry
        const baseName = getStationDisplayName(stationId, [stopId]);
        const displayName = occurrence > 1 ? `${baseName} (${occurrence})` : baseName;
        
        // Get all stop IDs for this station
        const stopIdsForEntry = stationToAllStopIds.get(stationId) || [stopId];
        
        const newEntry = {
          id: stopIdsForEntry[0],
          name: displayName,
          stopIds: stopIdsForEntry,
          stationId,
          occurrence,
          nodeType: nodeTypes[stopId] || 'passenger'
        };
        
        const insertPos = lastMasterIdx + 1;
        masterList.splice(insertPos, 0, newEntry);
        masterListMap.set(lookupKey, insertPos);
        
        // Update all indices in map that are >= insertPos
        masterListMap.forEach((idx, key) => {
          if (idx >= insertPos && key !== lookupKey) {
            masterListMap.set(key, idx + 1);
          }
        });
        
        lastMasterIdx = insertPos;
      }
    });
  });

  return masterList;
}
function ensureCanonicalMasterListForCurrentSelection() {
  const key = getCanonicalKeyForCurrentSelection();
  if (!key) return null;
  
  const dir = state.selectedDirection || '0';
  
  // Check cache
  if (state.canonicalMasterLists[key] && state.canonicalMasterLists[key][dir]) {
    return state.canonicalMasterLists[key][dir];
  }

  const profile = getCurrentRouteProfile();
  if (!profile || !profile.coreStops || profile.coreStops.length === 0) {
    return null; // Fallback
  }

  const { tripsIndex, stopsIndex } = state.gtfsData;
  const stopTimesIndex = getStopTimesIndexOrCache();
  if (!stopTimesIndex || !tripsIndex || !stopsIndex) return null;

  let routeIds = [];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members.map(r => r.route_id).filter(Boolean);
  } else if (state.selectedRoute) {
    routeIds = [state.selectedRoute.route_id];
  }

  if (!routeIds.length) return null;

  let allTrips = [];
  routeIds.forEach(rid => {
    const ts = tripsIndex[rid] || [];
    allTrips = allTrips.concat(ts);
  });

  allTrips = allTrips.filter(t => (t.direction_id || '0') === dir);
  if (!allTrips.length) return null;

  const rows = buildCanonicalMasterList(profile, allTrips, stopTimesIndex, stopsIndex);
  
  if (!rows) return null;

  // Cache it
  if (!state.canonicalMasterLists[key]) {
    state.canonicalMasterLists[key] = {};
  }
  state.canonicalMasterLists[key][dir] = rows;

  return rows;
}
function invalidateCanonicalCacheForCurrentSelection() {
  const key = getCanonicalKeyForCurrentSelection();
  if (key && state.canonicalMasterLists[key]) {
    delete state.canonicalMasterLists[key];
  }
  // Also clear column order cache
  state.columnOrderCache = {};
}

// ═══════════════════════════════════════════════════════════════
// 7. TRIP & VARIANT PROCESSING
// ═══════════════════════════════════════════════════════════════
function getAllTripsForRoute() {
  if (!state.selectedRoute || !state.gtfsData || !state.selectedDate) return [];

  // With DuckDB approach, trips are loaded via selectRoute into state.currentTrips
  return state.currentTrips || [];
}

    function computeVariantsForRoute() {
      if (!state.selectedRoute || !state.gtfsData || !state.selectedDate) return null;
      const trips = getAllTripsForRoute();
      if (trips.length === 0) return null;
      const tripStopMaps = {};
      trips.forEach(trip => {
        const stopTimes = getStopTimesIndexOrCache()[trip.trip_id] || [];
        stopTimes.sort((a,b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));
        tripStopMaps[trip.trip_id] = stopTimes;
      });
      const patternToVariant = {}, tripToVariant = {}; let variantNum = 1;
      trips.forEach(trip => {
        const stops = tripStopMaps[trip.trip_id] || [];
        const patternKey = stops.map(st => st.stop_id).join(',');
        if (!patternToVariant[patternKey]) patternToVariant[patternKey] = variantNum++;
        tripToVariant[trip.trip_id] = patternToVariant[patternKey];
      });
      const variantDetails = {};
      Object.keys(patternToVariant).forEach(patternKey => {
        const vNum = patternToVariant[patternKey];
        const stopIds = patternKey ? patternKey.split(',') : [];
        variantDetails[vNum] = { stops: stopIds, stopDetails: stopIds.map(id => state.gtfsData.stopsIndex[id]) };
      });
      return { trips, tripStopMaps, tripToVariant, patternToVariant, variantDetails };
    }

function sortTripsByMostFrequentStop(trips, tripStopMaps, stopsIndex) {
  if (!trips || trips.length === 0) return trips;
  if (!stopsIndex) {
    // Fallback: chronological sort
    return trips.sort((a, b) => {
      const aStops = tripStopMaps[a.trip_id] || [];
      const bStops = tripStopMaps[b.trip_id] || [];
      let aTime = aStops[0]?.departure_time || "99:99:99";
      let bTime = bStops[0]?.departure_time || "99:99:99";
      if (String(aTime).match(/^\d:/)) aTime = "0" + aTime;
      if (String(bTime).match(/^\d:/)) bTime = "0" + bTime;
      return Utils.timeToMinutes(aTime) - Utils.timeToMinutes(bTime);
    });
  }
  
  // 1. Znajdź most frequent STATION (merged stop aware)
  const stationCounts = new Map();
  
  trips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(s => {
      const stationId = getStationId(s.stop_id, stopsIndex);
      stationCounts.set(stationId, (stationCounts.get(stationId) || 0) + 1);
    });
  });
  
  let maxCount = 0;
  let anchorStationId = null;
  stationCounts.forEach((count, stId) => {
    if (count > maxCount) {
      maxCount = count;
      anchorStationId = stId;
    }
  });
  
  if (!anchorStationId) {
    // Fallback: chronological
    return trips.sort((a, b) => {
      const aStops = tripStopMaps[a.trip_id] || [];
      const bStops = tripStopMaps[b.trip_id] || [];
      let aTime = aStops[0]?.departure_time || "99:99:99";
      let bTime = bStops[0]?.departure_time || "99:99:99";
      if (String(aTime).match(/^\d:/)) aTime = "0" + aTime;
      if (String(bTime).match(/^\d:/)) bTime = "0" + bTime;
      return Utils.timeToMinutes(aTime) - Utils.timeToMinutes(bTime);
    });
  }
  
  // 2. Znajdź wszystkie stop_ids dla anchor station (wszystkie perony, etc.)
  const anchorStopIds = [];
  Object.values(stopsIndex).forEach(stop => {
    if (getStationId(stop.stop_id, stopsIndex) === anchorStationId) {
      anchorStopIds.push(stop.stop_id);
    }
  });
  
  // 3. Podziel tripy na core (przez anchor) i non-core (bez anchor)
  const coreTrips = [];
  const nonCoreTrips = [];
  
  trips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    const hasAnchor = stops.some(s => anchorStopIds.includes(s.stop_id));
    
    if (hasAnchor) {
      coreTrips.push(trip);
    } else {
      nonCoreTrips.push(trip);
    }
  });
  
  // 4. Zbierz wszystkie stop_ids z core trips (wspólne przystanki)
  const coreStopIds = new Set();
  coreTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(s => {
      coreStopIds.add(s.stop_id);
    });
  });
  
  // 5. Sort core trips by anchorTime (ascending)
  const coreData = coreTrips.map(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    
    let anchorTime = null;
    for (let i = 0; i < stops.length; i++) {
      if (anchorStopIds.includes(stops[i].stop_id)) {
        anchorTime = stops[i].departure_time || stops[i].arrival_time;
        break;
      }
    }
    
    // Normalize time
    if (anchorTime && String(anchorTime).match(/^\d:/)) {
      anchorTime = "0" + anchorTime;
    }
    
    if (!anchorTime) {
      anchorTime = "99:99:99";
    }
    
    return {
      trip,
      anchorTime,
      totalStops: stops.length
    };
  });
  
  // Sort core trips by anchor time
  coreData.sort((a, b) => {
    const timeDiff = Utils.timeToMinutes(a.anchorTime) - Utils.timeToMinutes(b.anchorTime);
    if (timeDiff !== 0) return timeDiff;
    return b.totalStops - a.totalStops;
  });
  
  // 6. Inject non-core trips into sorted core list chronologically
  const result = [...coreData.map(cd => cd.trip)]; // Start with sorted core trips
  
  nonCoreTrips.forEach(nonCoreTrip => {
    const nonCoreStops = tripStopMaps[nonCoreTrip.trip_id] || [];
    
    let insertionTime = null;
    let commonStopId = null;
    for (let i = 0; i < nonCoreStops.length; i++) {
      if (coreStopIds.has(nonCoreStops[i].stop_id)) {
        insertionTime = nonCoreStops[i].departure_time || nonCoreStops[i].arrival_time;
        commonStopId = nonCoreStops[i].stop_id;
        break;
      }
    }
    
    // Normalize time
    if (insertionTime && String(insertionTime).match(/^\d:/)) {
      insertionTime = "0" + insertionTime;
    }
    
    // Fallback: if no common stop, use first stop time
    if (!insertionTime) {
      insertionTime = nonCoreStops[0]?.departure_time || "99:99:99";
      if (String(insertionTime).match(/^\d:/)) {
        insertionTime = "0" + insertionTime;
      }
    }
    
    let insertIdx = result.length; // Default: append at end
    
    for (let i = 0; i < result.length; i++) {
      const coreTrip = result[i];
      const coreStops = tripStopMaps[coreTrip.trip_id] || [];
      
      let coreTimeAtCommon = null;
      if (commonStopId) {
        const coreStop = coreStops.find(s => s.stop_id === commonStopId);
        if (coreStop) {
          coreTimeAtCommon = coreStop.departure_time || coreStop.arrival_time;
          if (String(coreTimeAtCommon).match(/^\d:/)) {
            coreTimeAtCommon = "0" + coreTimeAtCommon;
          }
        }
      }
      
      // If core trip doesn't have the common stop, use its anchor time as fallback
      if (!coreTimeAtCommon) {
        for (let j = 0; j < coreStops.length; j++) {
          if (anchorStopIds.includes(coreStops[j].stop_id)) {
            coreTimeAtCommon = coreStops[j].departure_time || coreStops[j].arrival_time;
            if (String(coreTimeAtCommon).match(/^\d:/)) {
              coreTimeAtCommon = "0" + coreTimeAtCommon;
            }
            break;
          }
        }
      }
      
      // Insert before this core trip if non-core comes earlier
      if (coreTimeAtCommon && Utils.timeToMinutes(insertionTime) < Utils.timeToMinutes(coreTimeAtCommon)) {
        insertIdx = i;
        break;
      }
    }
    
    // Insert at found position
    result.splice(insertIdx, 0, nonCoreTrip);
  });
  
  return result;
}
const adjacentSwapOrderConfig = {
  voteThreshold: 4,
  marginMinutes: 2,
  maxPasses: 8
};
function adjacentSwapOrder(trips, tripMappings, visiblePassengerRowIndices, params) {
  if (!trips || trips.length <= 1) return trips;
  
  const { voteThreshold, marginMinutes, maxPasses } = params;
  
  const orderedTrips = trips.slice();
  const orderedMappings = tripMappings.slice();
  
  // Perform multiple passes of adjacent comparisons
  for (let pass = 0; pass < maxPasses; pass++) {
    let swapped = false;
    
    // Compare each adjacent pair
    for (let i = 0; i < orderedTrips.length - 1; i++) {
      let votesSwap = 0;
      let votesKeep = 0;
      
      // Count votes across visible passenger rows
      for (const rowIdx of visiblePassengerRowIndices) {
        const stopL = orderedMappings[i][rowIdx];
        const stopR = orderedMappings[i + 1][rowIdx];
        
        // Skip if either trip doesn't stop at this row
        if (!stopL || !stopR) continue;
        
        const timeL = stopL.departure_time || stopL.arrival_time;
        const timeR = stopR.departure_time || stopR.arrival_time;
        
        // Skip if either time is missing
        if (!timeL || !timeR) continue;
        
        const minutesL = Utils.timeToMinutes(timeL);
        const minutesR = Utils.timeToMinutes(timeR);
        
        // Vote to swap if left is significantly later than right
        if (minutesL > minutesR + marginMinutes) {
          votesSwap++;
        } else if (minutesR > minutesL + marginMinutes) {
          votesKeep++;
        }
        // Within margin: no vote
      }
      
      // Swap if we have enough votes
      if (votesSwap >= voteThreshold) {
        // Swap trips
        [orderedTrips[i], orderedTrips[i + 1]] = [orderedTrips[i + 1], orderedTrips[i]];
        // Swap corresponding mappings to stay in sync
        [orderedMappings[i], orderedMappings[i + 1]] = [orderedMappings[i + 1], orderedMappings[i]];
        swapped = true;
      }
    }
    
    // Early exit if no swaps were made in this pass
    if (!swapped) break;
  }
  
  return orderedTrips;
}
function findMostFrequentTripPattern(trips, stopTimesIndex, stopId, activeServices) {
  const patternCounts = new Map(); // klucz: "stop1,stop2,stop3...", wartość: count
  const patternToTrip = new Map(); // mapowanie pattern → przykładowy trip_id
  
  trips.forEach(trip => {
    if (!activeServices.includes(trip.service_id)) return;
    
    const stopTimes = stopTimesIndex[trip.trip_id] || [];
    // Sprawdź czy trip przechodzi przez nasz przystanek
    if (!stopTimes.some(st => st.stop_id === stopId)) return;
    
    const sorted = [...stopTimes].sort((a, b) => 
      parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0')
    );
    const pattern = sorted.map(st => st.stop_id).join(',');
    
    patternCounts.set(pattern, (patternCounts.get(pattern) || 0) + 1);
    if (!patternToTrip.has(pattern)) {
      patternToTrip.set(pattern, trip.trip_id);
    }
  });
  
  let maxCount = 0;
  let mostFrequentPattern = null;
  
  patternCounts.forEach((count, pattern) => {
    if (count > maxCount) {
      maxCount = count;
      mostFrequentPattern = pattern;
    }
  });
  
  if (!mostFrequentPattern) return null;
  
  const representativeTripId = patternToTrip.get(mostFrequentPattern);
  return {
    tripId: representativeTripId,
    stopIds: mostFrequentPattern.split(','),
    frequency: maxCount
  };
}

// ═══════════════════════════════════════════════════════════════
// 8. DIRECTION & HEADSIGN LOGIC
// ═══════════════════════════════════════════════════════════════
function getAvailableDirections() {
  if (!state.selectedRoute || !state.gtfsData) return [];

  let routeIds = [state.selectedRoute.route_id];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members
      .map(r => r.route_id)
      .filter(Boolean);
  }

  let routeTripsAll = [];
  routeIds.forEach(rid => {
    const arr = state.gtfsData.tripsIndex[rid] || [];
    routeTripsAll = routeTripsAll.concat(arr);
  });

  const dirs = Object.create(null);
  for (const t of routeTripsAll) {
    const dirId = String(t.direction_id === undefined || t.direction_id === null ? '0' : t.direction_id);
    if (!dirs[dirId]) dirs[dirId] = { id: dirId, rows: 0, tripIds: new Set(), byFinalStop: Object.create(null), trips: [] };
    dirs[dirId].rows++;
    if (t.trip_id) dirs[dirId].tripIds.add(t.trip_id);
    
    // Extract final stop name from stop_times
    const stopTimes = getStopTimesIndexOrCache()[t.trip_id] || [];
    const sorted = stopTimes.slice().sort((a, b) => a.stop_sequence - b.stop_sequence);
    const lastStopId = sorted[sorted.length - 1]?.stop_id;
    const lastStop = state.gtfsData.stopsIndex[lastStopId];
    const directionName = lastStop?.stop_name || '';
    
    if (directionName) dirs[dirId].byFinalStop[directionName] = (dirs[dirId].byFinalStop[directionName] || 0) + 1;
    dirs[dirId].trips.push(t);
  }

  const perDir = Object.keys(dirs).map(id => {
    const info = dirs[id];
    const finalStopEntries = Object.entries(info.byFinalStop).sort((a,b) => b[1] - a[1]);
    const top1Count = finalStopEntries.length ? finalStopEntries[0][1] : 0;
    const top1Label = finalStopEntries.length ? finalStopEntries[0][0] : '';
    const top2Count = finalStopEntries.length > 1 ? finalStopEntries[1][1] : 0;
    const top2Label = finalStopEntries.length > 1 ? finalStopEntries[1][0] : '';

    const commonFinalStop = finalStopEntries.length ? finalStopEntries[0][0] : '';
    let termini = '';
    let bestStops = null, bestLen = 0;
    for (const t of info.trips) {
      const sts = getStopTimesIndexOrCache()[t.trip_id] || [];
      if (sts.length > bestLen) { bestLen = sts.length; bestStops = sts; }
    }
    if (bestStops && bestStops.length > 0) {
      const first = state.gtfsData.stopsIndex[bestStops[0].stop_id];
      const last  = state.gtfsData.stopsIndex[bestStops[bestStops.length - 1].stop_id];
      const firstName = first?.stop_name || bestStops[0].stop_id;
      const lastName  = last?.stop_name  || bestStops[bestStops.length - 1].stop_id;
      termini = (firstName && lastName && firstName !== lastName) ? `${firstName} – ${lastName}` : (lastName || firstName || '');
    }
    const fullName = commonFinalStop || termini || `Direction ${id}`;
    const score = (top1Count || 0) * 3 + (info.rows || 0);

    return {
      dir: id,
      rows: info.rows,
      distinctTripIds: info.tripIds.size,
      top1Count,
      top1Label,
      top2Count,
      top2Label,
      fullName,
      score,
      trips: info.trips
    };
  });

  perDir.sort((a,b) => (b.top1Count - a.top1Count) || (b.rows - a.rows));
  const heuristicResult = applyDirectionHeuristic(perDir, 1, 0.30);
  const labelsMap = heuristicResult.labels || {};

  const result = perDir.map((d, idx) => {
    const l = labelsMap[d.dir];
    const displayName = (l && l.display) ? l.display : (d.top1Label || d.fullName || d.dir);
    const safeDisplay = (displayName && String(displayName).trim()) ? displayName : (d.fullName || d.top1Label || d.dir);
    return { id: d.dir, name: safeDisplay, fullName: d.fullName, score: d.score };
  });

  return result;
}

function applyDirectionHeuristic(perDir, absDiff = 1, relRatio = 0.30) {
  const num = v => (typeof v === 'number' && !Number.isNaN(v)) ? v : 0;
  function closeEnough(x, y, absD, relR) {
    x = num(x); y = num(y);
    const diff = Math.abs(x - y);
    if (diff <= absD) return true;
    const denom = Math.max(Math.abs(x), Math.abs(y), 1);
    return (diff / denom) <= relR;
  }
  const list = Array.isArray(perDir) ? perDir.slice() : [];
  list.sort((a,b) => num(b.top1Count) - num(a.top1Count));
  const labels = {};
  const reason = { text: '', matched: null };
  if (list.length === 0) {
    reason.text = 'no directions';
    reason.matched = 'none';
    return { labels, reason };
  }
  if (list.length === 1) {
    const d = list[0];
    labels[d.dir] = { display: d.top1Label || '', mode: 'single' };
    reason.text = 'single direction';
    reason.matched = 'single';
    return { labels, reason };
  }
  const A = list[0];
  const B = list[1];
  const A_top1 = num(A.top1Count);
  const B_top1 = num(B.top1Count);
  const A_top2sum = A_top1 + num(A.top2Count);
  const B_top2sum = B_top1 + num(B.top2Count);
  if (closeEnough(A_top1, B_top1, absDiff, relRatio)) {
    labels[A.dir] = { display: A.top1Label || '', mode: 'top1-equal' };
    labels[B.dir] = { display: B.top1Label || '', mode: 'top1-equal' };
    reason.text = 'top1 equal';
    reason.matched = 'top1-equal';
    return { labels, reason };
  }
  function combinedLabel(d) {
    const left = d.top1Label || '';
    const right = d.top2Label || '';
    if (!left && !right) return '';
    if (!right) return left;
    if (!left) return right;
    return `${left} / ${right}`;
  }
  if (closeEnough(B_top2sum, A_top1, absDiff, relRatio)) {
    labels[A.dir] = { display: A.top1Label || '', mode: 'top1' };
    labels[B.dir] = { display: combinedLabel(B), mode: 'B_top2≈A_top1' };
    reason.text = 'B top2sum ≈ A top1';
    reason.matched = 'B_top2≈A_top1';
    return { labels, reason };
  }
  if (closeEnough(A_top2sum, B_top1, absDiff, relRatio)) {
    labels[A.dir] = { display: combinedLabel(A), mode: 'A_top2≈B_top1' };
    labels[B.dir] = { display: B.top1Label || '', mode: 'top1' };
    reason.text = 'A top2sum ≈ B top1';
    reason.matched = 'A_top2≈B_top1';
    return { labels, reason };
  }
  labels[A.dir] = { display: A.top1Label || '', mode: 'top1' };
  labels[B.dir] = { display: B.top1Label || '', mode: 'top1' };
  reason.text = 'default top1';
  reason.matched = 'default';
  return { labels, reason };
}

// ═══════════════════════════════════════════════════════════════
// 9. MAP RENDERING
// ═══════════════════════════════════════════════════════════════
    function resetMap() {
      if (window.leafletMap) {
        try { window.leafletMap.remove(); } catch(e) {}
        window.leafletMap = null;
        window.leafletFeatureGroup = null;
      }
    }

    function ensureMap(containerId = 'map-container', center=[51.94,13.88], zoom=11) {
      const mapContainer = $(containerId);
      if (!mapContainer) return null;
      if (!window.leafletMap) {
        mapContainer.innerHTML = '';
        const map = window.L.map(mapContainer).setView(center, zoom);
        window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'© OpenStreetMap contributors', maxZoom:19 }).addTo(map);
        window.leafletMap = map;
        window.leafletFeatureGroup = window.L.featureGroup().addTo(map);
      }
      return window.leafletMap;
    }

    // Helper function to create SVG icon with dynamic color
    function createSvgIcon(color, baseSize = 96) {
      const width = baseSize;
      const height = Math.round(baseSize * 1.41);
      
      const svgIcon = `
        <svg version="1.2" width="${width}" height="${height}" viewBox="0 0 21000 29700" preserveAspectRatio="xMidYMid" fill-rule="evenodd" xmlns="http://www.w3.org/2000/svg">
          <g>
            <path fill="#FFF" d="M10913 16775H8225v-5375h5375v5375h-2687z"/>
            <path fill="${color}" d="M10913 16098H8908v-4020h4009v4020h-2004z"/>
            <path fill="#FFF" d="M11460 13253c0 95-25 188-73 272-47 82-117 150-200 198-29 17-60 31-91 42v1520c0 31-9 62-25 89s-38 51-66 66c-28 16-61 24-92 24-32 0-63-8-91-24-28-15-51-39-67-66-15-27-24-58-24-89v-1520c-31-12-62-25-91-42-83-48-152-116-200-198-48-84-73-177-73-272s25-188 73-272c48-82 117-150 200-198 84-47 178-73 274-73s190 26 273 73c83 48 153 116 200 198 48 84 73 177 73 272z"/>
          </g>
        </svg>
      `;
      return window.L.divIcon({
        html: svgIcon,
        className: 'custom-svg-icon',
        iconSize: [width, height],
        iconAnchor: [width/2, height/2],
        popupAnchor: [0, -height/2 - 5]  // Popup appears above icon with 5px offset
      });
    }
    
    // Helper function to create circle marker (scales automatically with zoom)
    function createCircleMarker(lat, lon, color, radius = 6) {
      return window.L.circleMarker([lat, lon], {
        radius: radius,
        fillColor: color,
        color: '#fff',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.8
      });
    }

async function generateLineGeometry(stopDetails, routeType) {
  // Generate straight line route from stops
  if (!Array.isArray(stopDetails) || stopDetails.length < 2) return [];
  
  const coordinates = stopDetails
    .map(s => [parseFloat(s.lat || s.stop_lat), parseFloat(s.lon || s.stop_lon)])
    .filter(([lat, lon]) => !isNaN(lat) && !isNaN(lon));
  
  return coordinates;
}

async function generateHybridLineGeometry(stops, shapeId, routeType) {
  if (!stops || stops.length < 2) return [];
  
  const shapesIndex = state.gtfsData?.shapesIndex;
  
  // If no shapes.txt, use straight lines
  if (!shapeId || !shapesIndex || !shapesIndex[shapeId]) {
    return await generateLineGeometry(stops, routeType);
  }
  
  const shapePoints = getSimplifiedShape(shapeId);
  
  const coverage = Utils.calculateShapeCoverage(stops, shapePoints);
  
  // If good coverage (>70%), use hybrid approach
  if (coverage.percentage >= 0.7) {
    return Utils.fillShapeGaps(stops, shapePoints, coverage.nearbyStops);
  }
  
  // Poor coverage - use straight lines
  return await generateLineGeometry(stops, routeType);
}

async function updateMap() {
  const mapContainer = $('map-container');
  if (!mapContainer || !state.selectedRoute) return;
  
  const variantsData = state._lastVariants || computeVariantsForRoute();

  let routeIds = [state.selectedRoute.route_id];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members
      .map(r => r.route_id)
      .filter(Boolean);
  }

  let routeTripsAll = [];
  routeIds.forEach(rid => {
    const arr = state.gtfsData.tripsIndex[rid] || [];
    routeTripsAll = routeTripsAll.concat(arr);
  });

  let initialCenter = [51.94, 13.88]; // Default fallback
  let initialZoom = 11;
  
  if (variantsData && variantsData.variantDetails) {
    let variantId = state.selectedVariant;
    if (!variantsData.variantDetails[variantId]) {
      const keys = Object.keys(variantsData.variantDetails);
      variantId = keys.length ? keys[0] : variantId;
    }
    const sel = variantsData.variantDetails[variantId];
    if (sel && Array.isArray(sel.stopDetails) && sel.stopDetails.length > 0) {
      const validStops = sel.stopDetails.filter(s => s && s.stop_lat && s.stop_lon && !isNaN(parseFloat(s.stop_lat)) && !isNaN(parseFloat(s.stop_lon)));
      if (validStops.length > 0) {
        const lats = validStops.map(s => parseFloat(s.stop_lat));
        const lons = validStops.map(s => parseFloat(s.stop_lon));
        const centerLat = (Math.min(...lats) + Math.max(...lats)) / 2;
        const centerLon = (Math.min(...lons) + Math.max(...lons)) / 2;
        initialCenter = [centerLat, centerLon];
        initialZoom = 13;
      }
    }
  }
  
  ensureMap('map-container', initialCenter, initialZoom);
  const map = window.leafletMap;
  const fg = window.leafletFeatureGroup;
  
  // Wyczyść tylko warstwy
  fg.clearLayers();

  const routeColor = getRouteTypeMeta(state.selectedRoute?.route_type).color || '#3b82f6';
  const routeType = state.selectedRoute.route_type;
  
const addMarker = (lat, lon, name, color) => {
  if (isNaN(lat) || isNaN(lon)) return;
  fg.addLayer(window.L.marker([lat, lon], { 
      icon: createSvgIcon(color || '#3b82f6')
    }).bindPopup(name || ''));
  };
  
  let drawnVariantCoords = [];
  if (variantsData && variantsData.variantDetails) {
    let variantId = state.selectedVariant;
    if (!variantsData.variantDetails[variantId]) {
      const keys = Object.keys(variantsData.variantDetails);
      variantId = keys.length ? keys[0] : variantId;
    }
const sel = variantsData.variantDetails[variantId];
if (sel && Array.isArray(sel.stopDetails) && sel.stopDetails.length > 0) {
  let lineGeometry = null;
  
  // ===== HIERARCHY FOR ROUTE DRAWING =====
  // 1. Try shapes.txt (best quality - from GTFS)
  if (state.gtfsData. shapesIndex && Object.keys(state.gtfsData.shapesIndex).length > 0) {
    const variantTrips = variantsData.trips.filter(t => variantsData.tripToVariant[t.trip_id] === variantId);
    
    if (variantTrips. length > 0) {
      const shapeId = variantTrips[0].shape_id;
      
      if (shapeId && state.gtfsData. shapesIndex[shapeId]) {
        lineGeometry = getSimplifiedShape(shapeId);
      }
    }
  }
  
  // 2. Final fallback: Simple straight lines between stops
  if (!lineGeometry) {
    lineGeometry = sel.stopDetails
      .map(s => [parseFloat(s.stop_lat), parseFloat(s.stop_lon)])
      .filter(([lat, lon]) => !isNaN(lat) && !isNaN(lon));
  }

  if (lineGeometry && lineGeometry.length > 1) {
    fg.addLayer(window.L.polyline(lineGeometry, { 
      color: routeColor, 
      weight: 5,
      opacity: 0.9,
      smoothFactor: 0.5 
    }));
  }

  // Dodaj markery przystanków...
      sel.stopDetails.forEach(s => {
        if (s && s.stop_lat && s.stop_lon) {
          const lat = parseFloat(s.stop_lat), lon = parseFloat(s.stop_lon);
          if (!isNaN(lat) && !isNaN(lon)) {
            addMarker(lat, lon, s.stop_name, routeColor);
            drawnVariantCoords.push([lat, lon]);
          }
        }
      });
    }
  }
  
  // Fallback jeśli nie ma wariantu
  if (drawnVariantCoords.length < 2) {
    const allStopIds = new Set();
    routeTripsAll.forEach(trip => {
      const sts = getStopTimesIndexOrCache()[trip.trip_id] || [];
      sts.forEach(st => { if (st && st.stop_id) allStopIds.add(st.stop_id); });
    });
    const allCoords = [];
    allStopIds.forEach(stopId => {
      const stop = state.gtfsData.stopsIndex[stopId];
      if (stop && stop.stop_lat && stop.stop_lon) {
        const lat = parseFloat(stop.stop_lat), lon = parseFloat(stop.stop_lon);
        if (!isNaN(lat) && !isNaN(lon)) {
          addMarker(lat, lon, stop.stop_name, routeColor);
          allCoords.push([lat, lon]);
        }
      }
    });
    if (allCoords.length > 1) fg.addLayer(window.L.polyline(allCoords, { color:'#9ca3af', weight:2, opacity:0.6 }));
  }
  
  if (fg.getLayers().length === 0) {
    map.remove();
    resetMap();
    mapContainer.innerHTML = '<div class="p-4 text-gray-500">No map data available for this route</div>';
    return;
  }
  
  let bounds = fg.getBounds();
  if (!bounds || !bounds.isValid || (bounds.getNorthEast && bounds.getSouthWest &&
      Math.abs(bounds.getNorthEast().lat - bounds.getSouthWest().lat) < 0.0005 &&
      Math.abs(bounds.getNorthEast().lng - bounds.getSouthWest().lng) < 0.0005)) {
    const firstLayer = fg.getLayers()[0];
    let p = null;
    if (firstLayer && firstLayer.getLatLng) p = firstLayer.getLatLng();
    if (p) {
      const delta = 0.005;
      bounds = window.L.latLngBounds([[p.lat - delta, p.lng - delta], [p.lat + delta, p.lng + delta]]);
    }
  }
  
  try {
    if (bounds && bounds.isValid && !(bounds.getNorthEast().equals(bounds.getSouthWest()))) {
      map.fitBounds(bounds, { padding: [20,20], maxZoom: 18 });
    } else {
      const layer = fg.getLayers()[0];
      if (layer && layer.getLatLng) map.setView(layer.getLatLng(), 13);
    }
  } catch (err) {
    // Ignore map fit errors - they don't prevent map from displaying
  }
}

async function renderStopDetailMap(stopId, selectedDate, filteredRouteIds = []) {
  const mapContainer = $('stop-detail-map');
  if (!mapContainer) return;
  
  const stop = state.gtfsData.stopsIndex[stopId];
  if (!stop || !stop.stop_lat || !stop.stop_lon) {
    mapContainer.innerHTML = '<div class="p-4 text-gray-500">Brak danych lokalizacyjnych dla przystanku</div>';
    return;
  }
  
  const lat = parseFloat(stop.stop_lat);
  const lon = parseFloat(stop.stop_lon);
  if (isNaN(lat) || isNaN(lon)) {
    mapContainer.innerHTML = '<div class="p-4 text-gray-500">Nieprawidłowe współrzędne przystanku</div>';
    return;
  }
  
  const result = collectRoutesForStop(stopId, selectedDate, []);
  
  const routesData = result.routes || [];
  
  // Initialize map only once
  if (!state.stopDetailMapInitialized) {
    mapContainer.innerHTML = '';
    const map = window.L.map(mapContainer).setView([lat, lon], 14);
    window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);
    
    state.stopDetailMapInstance = map;
    state.stopDetailMapLayers = {};
    
    const allBounds = [];
    
    // Create layers for each route
    for (const routeData of routesData) {
      const { route, stops, color, direction, shapeId } = routeData;
      const layerKey = `${route.route_id}_${direction}`;
      
      const layer = window.L.featureGroup();
      
      const mainRouteStops = stops.filter(s => s.type === 'core' || s.type === 'branch');
      
      if (mainRouteStops.length > 1) {
        let lineGeometry = null;
        
        // Use hybrid approach: shapes.txt + gap filling, or straight lines
        lineGeometry = await generateHybridLineGeometry(mainRouteStops, shapeId, route.route_type);

        // Draw polyline if we have at least 2 points
        if (Array.isArray(lineGeometry) && lineGeometry.length > 1) {
          window.L.polyline(lineGeometry, {
            color: color,
            weight: 3,
            opacity: 0.7,
            smoothFactor: 0.5
          }).addTo(layer);
        }
      }

      // Add main route stops as small markers and collect bounds
      mainRouteStops.forEach(s => {
        if (!s || isNaN(parseFloat(s.lat)) || isNaN(parseFloat(s.lon))) return;
        const sLat = parseFloat(s.lat);
        const sLon = parseFloat(s.lon);
        window.L.marker([sLat, sLon], {
          icon: createSvgIcon(color)
        }).addTo(layer).bindPopup(s.name);

        allBounds.push([sLat, sLon]);
      });
      
      // Store layer and add to map
      state.stopDetailMapLayers[layerKey] = layer;
      layer.addTo(map);
    }
    
    // Add main stop (selected) as larger marker
    window.L.marker([lat, lon], {
      icon: createSvgIcon('#ef4444')
    }).addTo(map).bindPopup(`<b>${stop.stop_name}</b>`).openPopup();
    
    allBounds.push([lat, lon]);
    
    // Fit view to all points once
    if (allBounds.length > 0) {
      map.fitBounds(allBounds, { padding: [30, 30], maxZoom: 16 });
    }
    
    state.stopDetailMapInitialized = true;
  }
} // << zamknięcie funkcji renderującej mapę szczegółową

function filterStopDetailMapLayers(filteredRouteIds = []) {
  if (!state.stopDetailMapInstance || !state.stopDetailMapInitialized) {
    return;
  }

  const filterIds = (filteredRouteIds || []).map(String);
  const map = state.stopDetailMapInstance;

  Object.entries(state.stopDetailMapLayers).forEach(([layerKey, layer]) => {
    const routeId = layerKey.split('_')[0]; // Extract route_id from "route_id_direction"
    const shouldShow = filterIds.length === 0 || filterIds.includes(routeId);

    if (shouldShow) {
      if (!map.hasLayer(layer)) {
        layer.addTo(map);
      }
    } else {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      }
    }
  });
}

// ═══════════════════════════════════════════════════════════════
// 10. SHARED UI HELPERS
// ═══════════════════════════════════════════════════════════════
    function findRouteById(routeId) {
      return (state.gtfsData && state.gtfsData.routes || []).find(r => String(r.route_id) === String(routeId));
    }

    function routeBadgeHtml(route, meta) {
      const label = Utils.escapeHtml(route.route_short_name || route.route_id || '');
      const color = (meta && meta.color) || '#3b82f6';
      return `<a href="#" class="route-link" data-route-id="${Utils.escapeHtml(route.route_id)}" style="text-decoration:none;">
        <span
          style="
            display:inline-block;
            padding:2px 8px;
            font-weight:600;
            border-radius:4px;
            background:${color}20;
            color:${color};
            border-left:3px solid ${color};
          "
        >
          ${label}
        </span>
      </a>`;
    }

// ═══════════════════════════════════════════════════════════════
// 11. UI RENDERING - ROUTES VIEW
// ═══════════════════════════════════════════════════════════════
function renderRouteTable() {
  const container = $('routes-tbody');
  if (!container || !state.gtfsData) return;
  container.innerHTML = '';

  const logicalRoutes = state.gtfsData.logicalRoutes || [];
  const baseRoutes = (state.gtfsData.routes || []).slice();

  function reprOf(group) {
    return (group && group.members && group.members[0]) || null;
  }

function labelOf(group) {
    const r = reprOf(group);
    if (!r) return group?.route_short_name || '';
    return r.route_short_name || r.route_id || group.route_short_name || '';
}

  function sortGroupsByRouteId(arr) {
    return arr.slice().sort((a, b) => {
      const la = String(labelOf(a) || '').trim();
      const lb = String(labelOf(b) || '').trim();
      return la.localeCompare(lb, undefined, { numeric: true, sensitivity: 'base' });
    });
  }

  function sortRoutesById(routes) {
    return routes.slice().sort((a, b) => {
      const la = String(a.route_short_name || a.route_id || '').trim();
      const lb = String(b.route_short_name || b.route_id || '').trim();
      return la.localeCompare(lb, undefined, { numeric: true, sensitivity: 'base' });
    });
  }

  // === TRYB 1: LOGICAL (DOMYŚLNY) – jedna siatka z logicznymi liniami ===
  if (state.routeGroupMode === 'logical') {
    if (!logicalRoutes.length) return;

    const grid = document.createElement('div');
    grid.className = 'routes-grid';

    sortGroupsByRouteId(logicalRoutes).forEach(group => {
      const repr = reprOf(group);
      if (!repr) return;
      const metaRt = getRouteTypeMeta(repr.route_type);
      const btn = document.createElement('button');
      btn.className = 'route-card';
      btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

const label = labelOf(group);

btn.innerHTML = `
  <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
    <div style="font-weight:700;">${Utils.escapeHtml(label)}</div>
  </div>
`;

      btn.onclick = () => {
        state.selectedRouteGroup = group;
        selectRoute(repr.route_id, '0');
      };

      grid.appendChild(btn);
    });

    container.appendChild(grid);
    return;
  }

  // === TRYB 2: SERVICE_TYPE – logiczne linie zgrupowane wg canonical_type ===
  if (state.routeGroupMode === 'service_type') {
    if (!logicalRoutes.length) return;

    const groupsByCat = new Map();

    logicalRoutes.forEach(group => {
      const repr = reprOf(group);
      const cat = repr ? (collectRouteType(repr).canonical || 'other') : 'other';
      if (!groupsByCat.has(cat)) groupsByCat.set(cat, []);
      groupsByCat.get(cat).push(group);
    });

    const catKeys = Array.from(groupsByCat.keys()).sort((a, b) => {
      const oa = (CANONICAL_CATEGORIES[a] && CANONICAL_CATEGORIES[a].order) || 999;
      const ob = (CANONICAL_CATEGORIES[b] && CANONICAL_CATEGORIES[b].order) || 999;
      if (oa !== ob) return oa - ob;
      const la = (CANONICAL_CATEGORIES[a] && CANONICAL_CATEGORIES[a].label) || String(a);
      const lb = (CANONICAL_CATEGORIES[b] && CANONICAL_CATEGORIES[b].label) || String(b);
      return la.localeCompare(lb, undefined, { sensitivity: 'base' });
    });

    catKeys.forEach(cat => {
      const titleEl = document.createElement('div');
      titleEl.className = 'agency-title';
      titleEl.textContent = (CANONICAL_CATEGORIES[cat] && CANONICAL_CATEGORIES[cat].label) || cat || 'Other';
      container.appendChild(titleEl);

      const grid = document.createElement('div');
      grid.className = 'routes-grid';

      const list = sortGroupsByRouteId(groupsByCat.get(cat) || []);
      list.forEach(group => {
        const repr = reprOf(group);
        if (!repr) return;
        const metaRt = getRouteTypeMeta(repr.route_type);
        const btn = document.createElement('button');
        btn.className = 'route-card';
        btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

const label = labelOf(group);

btn.innerHTML = `
  <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
    <div style="font-weight:700;">${Utils.escapeHtml(label)}</div>
  </div>
`;

        btn.onclick = () => {
          state.selectedRouteGroup = group;
          selectRoute(repr.route_id, '0');
        };

        grid.appendChild(btn);
      });

      grid.style.marginBottom = '28px';
      container.appendChild(grid);
    });

    return;
  }

  // === TRYB 3: AGENCY – logiczne linie zgrupowane wg przewoźnika ===
  if (state.routeGroupMode === 'agency') {
    if (!logicalRoutes.length) return;

    const byAgency = new Map();

    logicalRoutes.forEach(group => {
      const repr = reprOf(group);
      const agencyId = repr?.agency_id || group.agency_id || '';
      const agencyName = agencyId && state.gtfsData.agenciesIndex[agencyId]
        ? (state.gtfsData.agenciesIndex[agencyId].agency_name || agencyId)
        : 'Nieznany przewoźnik';

      if (!byAgency.has(agencyName)) byAgency.set(agencyName, []);
      byAgency.get(agencyName).push(group);
    });

    const agencyKeys = Array.from(byAgency.keys()).sort((a, b) =>
      a.localeCompare(b, undefined, { sensitivity: 'base' })
    );

    agencyKeys.forEach(agencyName => {
      const titleEl = document.createElement('div');
      titleEl.className = 'agency-title';
      titleEl.textContent = agencyName;
      container.appendChild(titleEl);

      const grid = document.createElement('div');
      grid.className = 'routes-grid';

      const list = sortGroupsByRouteId(byAgency.get(agencyName) || []);
      list.forEach(group => {
        const repr = reprOf(group);
        if (!repr) return;
        const metaRt = getRouteTypeMeta(repr.route_type);
        const btn = document.createElement('button');
        btn.className = 'route-card';
        btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

    const label = labelOf(group);

    btn.innerHTML = `
      <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <div style="font-weight:700;">${Utils.escapeHtml(label)}</div>
      </div>
    `;

        btn.onclick = () => {
          state.selectedRouteGroup = group;
          selectRoute(repr.route_id, '0');
        };

        grid.appendChild(btn);
      });

      grid.style.marginBottom = '28px';
      container.appendChild(grid);
    });

    return;
  }

  // === TRYB 4: RAW_ROUTES – awaryjny: każdy rekord routes osobno, sort po numerze ===
  if (state.routeGroupMode === 'raw_routes') {
    const routes = sortRoutesById(baseRoutes);
    const grid = document.createElement('div');
    grid.className = 'routes-grid';

    routes.forEach(route => {
      const btn = document.createElement('button');
      btn.className = 'route-card';
      btn.textContent = route.route_short_name || route.route_id || '';
      const metaRt = getRouteTypeMeta(route.route_type);
      btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

      btn.onclick = () => {
        state.selectedRouteGroup = null; // w tym trybie świadomie patrzymy na pojedynczy route_id
        selectRoute(route.route_id, '0');
      };

      grid.appendChild(btn);
    });

    container.appendChild(grid);
    return;
  }

  // fallback – jeśli coś poszło nie tak, wracamy do logical
  state.routeGroupMode = 'logical';
  renderRouteTable();
}

async function selectRoute(routeId, directionId) {
  if (!state.selectedDate) return;
  state.loading = true;
  render();
  try {
    const trips = await window.electronAPI.queryTrips({ routeId, date: state.selectedDate, directionId: directionId || '0' });
    state.currentTrips = trips;
    state.selectedRoute = state.gtfsData.routes.find(r => r.route_id === routeId);
    state.selectedDirection = directionId || '0';
    
    // Load stop times for all trips to populate cache
    state.loadingStep = 'Loading stop times...';
    render();
    
    if (!state.gtfsData.stopTimesIndex) state.gtfsData.stopTimesIndex = {};
    for (const trip of trips) {
      if (!state.gtfsData.stopTimesIndex[trip.trip_id]) {
        const stopTimes = await window.electronAPI.queryStopTimes(trip.trip_id);
        state.gtfsData.stopTimesIndex[trip.trip_id] = stopTimes;
        
        // Also populate stopsIndex from stop times
        if (!state.gtfsData.stopsIndex) state.gtfsData.stopsIndex = {};
        stopTimes.forEach(st => {
          if (st.stop_id && !state.gtfsData.stopsIndex[st.stop_id]) {
            state.gtfsData.stopsIndex[st.stop_id] = {
              stop_id: st.stop_id,
              stop_name: st.stop_name,
              stop_lat: st.stop_lat,
              stop_lon: st.stop_lon
            };
          }
        });
      }
    }
    
    state.loading = false;
    state.loadingStep = '';
    render();
  } catch (err) {
    state.error = err.message;
    state.loading = false;
    render();
  }
}

async function selectTrip(tripId) {
  state.loading = true;
  render();
  try {
    const stopTimes = await window.electronAPI.queryStopTimes(tripId);
    state.selectedTrip = state.currentTrips.find(t => t.trip_id === tripId);
    state.currentStopTimes = stopTimes;
    if (state.selectedTrip?.shape_id) {
      state.currentShape = await window.electronAPI.queryShape(state.selectedTrip.shape_id);
    }
    state.loading = false;
    render();
    updateMap();
  } catch (err) {
    state.error = err.message;
    state.loading = false;
    render();
  }
}

// ═══════════════════════════════════════════════════════════════
// 12. UI RENDERING - STOPS VIEW
// ═══════════════════════════════════════════════════════════════
// Search index for fast stop name filtering

function buildStopsSearchIndex(groupsArray) {
  if (stopsSearchIndex) return stopsSearchIndex;
  
  stopsSearchIndex = groupsArray.map(group => ({
    id: group.id,
    name: group.name,
    searchText: group.name.toLowerCase().trim(), // pre-normalized
    routeCount: group.routeCount,
    stops: group.stops,
    routeSet: group.routeSet
  }));
  
  return stopsSearchIndex;
}

function clearStopsSearchIndex() {
  stopsSearchIndex = null;
}

// Async search with chunked processing to prevent UI freeze on large datasets
async function searchStopsInIndexAsync(query, groupsArray, onProgress) {
  if (!query || query.trim() === '') return groupsArray;
  
  const index = buildStopsSearchIndex(groupsArray);
  const lowerQuery = query.toLowerCase().trim();
  const results = [];
  
  const CHUNK_SIZE = 200; // Process 200 items at a time
  
  for (let i = 0; i < index.length; i += CHUNK_SIZE) {
    const chunk = index.slice(i, i + CHUNK_SIZE);
    
    chunk.forEach(item => {
      if (item.searchText.includes(lowerQuery)) {
        results.push({
          id: item.id,
          name: item.name,
          routeCount: item.routeCount,
          stops: item.stops,
          routeSet: item.routeSet
        });
      }
    });
    
    // Report progress for very large datasets
    if (onProgress && index.length > 1000) {
      const percent = Math.round(((i + chunk.length) / index.length) * 100);
      onProgress(percent);
    }
    
    // Yield to browser every 200 items to keep UI responsive
    if (i + CHUNK_SIZE < index.length) {
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
  
  return results;
}

function getOrBuildGroupsArray(stopsData) {
  // Better hash - includes first AND last stop
  const len = stopsData.length;
  const currentHash = `${len}_${stopsData[0]?.stop_id || ''}_${stopsData[len-1]?.stop_id || ''}`;
  
  if (cachedGroupsArray && lastStopsDataHash === currentHash) {
    return cachedGroupsArray;
  }
  
  const stopGroups = new Map();
  stopsData.forEach(stop => {
    const stopName = stop.stop_name || '';
    const baseName = stopName.replace(/\s+\d+[A-Za-z]?$/, '').trim();
    
    if (!stopGroups.has(baseName)) {
      stopGroups.set(baseName, {
        id: baseName,
        name: baseName,
        stops: [],
        routeSet: new Set()
      });
    }
    
    const group = stopGroups.get(baseName);
    group.stops.push(stop);
    stop.routes.forEach(route => group.routeSet.add(route.route_id));
  });
  
  const groupsArray = Array.from(stopGroups.values()).map(group => ({
    ...group,
    routeCount: group.routeSet.size,
    // Mark if this is a single-stop group (no grouping needed)
    isSingleStop: group.stops.length === 1
  }));
  
  groupsArray.sort((a, b) => a.name.localeCompare(b.name));
  
  cachedGroupsArray = groupsArray;
  lastStopsDataHash = currentHash;
  
  return groupsArray;
}

function measureStopItemHeight() {
  const firstItem = document.querySelector('.stop-group');
  if (firstItem) {
    const height = firstItem.offsetHeight;
    if (height > 0 && height !== state.virtualListItemHeight) {
      state.virtualListItemHeight = height;
    }
  }
}

function renderVirtualStopsList(groupsToRender) {
  const stopsList = $('stops-list');
  if (!stopsList) return;
  
  const container = stopsList.parentElement; // scrollable container
  if (!container) return;
  
  const containerHeight = container.clientHeight || 600;
  const scrollTop = container.scrollTop || 0;
  const itemHeight = state.virtualListItemHeight;
  
  const bufferSize = 5;
  const visibleCount = Math.ceil(containerHeight / itemHeight) + bufferSize * 2;
  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - bufferSize);
  const endIndex = Math.min(startIndex + visibleCount, groupsToRender.length);
  
  state.virtualListStartIndex = startIndex;
  
  const visibleGroups = groupsToRender.slice(startIndex, endIndex);
  const totalHeight = groupsToRender.length * itemHeight;
  const offsetY = startIndex * itemHeight;
  
  let html = `<div style="height: ${totalHeight}px;position:relative;">`;
  html += `<div style="position:absolute;top:${offsetY}px;left:0;right:0;">`;
  
  visibleGroups.forEach((group, idx) => {
    const actualIndex = startIndex + idx;
    const isGroupExpanded = state.expandedStopGroup === group.id;
    const pluralForm = group.routeCount === 1 ? 'linia' : 
      (group.routeCount % 10 >= 2 && group.routeCount % 10 <= 4 && (group.routeCount % 100 < 10 || group.routeCount % 100 >= 20)) 
      ? 'linie' : 'linii';
    
    // For single-stop groups, make them directly clickable
    if (group.isSingleStop) {
      const stop = group.stops[0];
      html += `
        <div class="stop-group p-3 border-b hover:bg-blue-50 cursor-pointer" 
             data-stop-id="${stop.stop_id}" 
             data-index="${actualIndex}">
          <div class="font-semibold">${Utils.escapeHtml(group.name)}</div>
          <div class="text-xs text-gray-600">${group.routeCount} ${pluralForm}</div>
        </div>
      `;
    } else {
      // Multi-stop groups: show as expandable
      html += `
        <div class="stop-group p-3 border-b hover:bg-blue-50 cursor-pointer ${isGroupExpanded ? 'bg-blue-50' : ''}" 
             data-group-id="${Utils.escapeHtml(group.id)}" 
             data-index="${actualIndex}">
          <div class="font-semibold">${Utils.escapeHtml(group.name)}</div>
          <div class="text-xs text-gray-600">${group.routeCount} ${pluralForm}</div>
        </div>
      `;
      
      // Expanded stops (non-virtualized for simplicity)
      if (isGroupExpanded) {
        group.stops.forEach(stop => {
          const stopPluralForm = stop.routeCount === 1 ? 'linia' : 
            (stop.routeCount % 10 >= 2 && stop.routeCount % 10 <= 4 && (stop.routeCount % 100 < 10 || stop.routeCount % 100 >= 20)) 
            ? 'linie' : 'linii';
          
          html += `
            <div class="stop-item p-2 pl-6 border-b hover:bg-blue-100 cursor-pointer bg-white" data-stop-id="${stop.stop_id}">
              <div class="font-medium text-sm">${Utils.escapeHtml(stop.stop_name)}</div>
              <div class="text-xs text-gray-600">${stop.routeCount} ${stopPluralForm}</div>
            </div>
          `;
        });
      }
    }
  });
  
  html += `</div></div>`;
  stopsList.innerHTML = html;
  
  // Measure height on first render
  if (state.virtualListItemHeight === 68) {
    setTimeout(measureStopItemHeight, 50);
  }
}

// Cached stop-to-routes mapping to avoid rebuilding
let cachedStopToRoutesMap = null;
let cachedStopToRoutesHash = null;

// Build stop-to-routes mapping with chunked processing to prevent UI freeze
async function buildStopToRoutesMapAsync(routes, tripsIndex, stopTimesIndex, onProgress) {
  const stopToRoutes = new Map();
  const CHUNK_SIZE = 20; // Process 20 routes at a time
  
  for (let i = 0; i < routes.length; i += CHUNK_SIZE) {
    const routeChunk = routes.slice(i, i + CHUNK_SIZE);
    
    routeChunk.forEach(route => {
      const trips = tripsIndex[route.route_id] || [];
      const stopIds = new Set();
      
      trips.forEach(trip => {
        const stopTimes = stopTimesIndex[trip.trip_id] || [];
        stopTimes.forEach(st => stopIds.add(st.stop_id));
      });
      
      stopIds.forEach(stopId => {
        if (!stopToRoutes.has(stopId)) stopToRoutes.set(stopId, []);
        stopToRoutes.get(stopId).push(route);
      });
    });
    
    // Report progress
    if (onProgress) {
      const percent = Math.round(((i + routeChunk.length) / routes.length) * 100);
      onProgress(i + routeChunk.length, routes.length, percent);
    }
    
    // Yield to browser to keep UI responsive
    if (i + CHUNK_SIZE < routes.length) {
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
  
  return stopToRoutes;
}

// Get or build stop-to-routes mapping with caching
async function getStopToRoutesMap(routes, tripsIndex, stopTimesIndex, onProgress) {
  const currentHash = routes.length + '_' + Object.keys(tripsIndex).length;
  
  if (cachedStopToRoutesMap && cachedStopToRoutesHash === currentHash) {
    return cachedStopToRoutesMap;
  }
  
  const stopToRoutes = await buildStopToRoutesMapAsync(routes, tripsIndex, stopTimesIndex, onProgress);
  
  cachedStopToRoutesMap = stopToRoutes;
  cachedStopToRoutesHash = currentHash;
  
  return stopToRoutes;
}

function clearStopToRoutesCache() {
  cachedStopToRoutesMap = null;
  cachedStopToRoutesHash = null;
}

async function renderStopsView() {
  if (!state.gtfsData || !state.showStopsView) return;
  
  const stopsList = $('stops-list');
  const stopsMap = $('stops-map');
  if (!stopsList || !stopsMap) return;
  
  // Show loading indicator for initial data preparation
  const isInitialLoad = !cachedStopToRoutesMap;
  if (isInitialLoad) {
    stopsList.innerHTML = '<div class="p-4 text-center text-gray-600">Przygotowywanie danych przystanków...</div>';
  }
  
  const stopToRoutes = await getStopToRoutesMap(
    state.gtfsData.routes,
    state.gtfsData.tripsIndex,
    getStopTimesIndexOrCache(),
    isInitialLoad ? (processed, total, percent) => {
      stopsList.innerHTML = `<div class="p-4 text-center text-gray-600">Przygotowywanie danych przystanków... ${percent}%</div>`;
    } : null
  );
  
  const stopsData = [];
  Object.values(state.gtfsData.stopsIndex).forEach(stop => {
    const routes = stopToRoutes.get(stop.stop_id) || [];
    if (routes.length > 0) {
      stopsData.push({
        ...stop,
        routeCount: routes.length,
        routes: routes
      });
    }
  });
  
  // Sortuj alfabetycznie
  stopsData.sort((a, b) => (a.stop_name || '').localeCompare(b.stop_name || ''));
  
  const groupsArray = getOrBuildGroupsArray(stopsData);
  
  const searchQuery = state.stopsListSearchQuery;
  
  // Use async search for large datasets to prevent UI freeze
  let filteredGroups;
  const useAsyncSearch = groupsArray.length > 1000 && searchQuery && searchQuery.trim() !== '';
  
  if (useAsyncSearch) {
    // Show searching indicator
    stopsList.innerHTML = '<div class="p-4 text-center text-gray-600">Wyszukiwanie...</div>';
    filteredGroups = await searchStopsInIndexAsync(searchQuery, groupsArray, (percent) => {
      stopsList.innerHTML = `<div class="p-4 text-center text-gray-600">Wyszukiwanie... ${percent}%</div>`;
    });
  } else {
    // For smaller datasets, also use async search for consistency
    filteredGroups = searchQuery && searchQuery.trim() !== '' 
      ? await searchStopsInIndexAsync(searchQuery, groupsArray)
      : groupsArray;
  }
  
  const useVirtualList = filteredGroups.length > 100; // Threshold

  if (useVirtualList) {
    renderVirtualStopsList(filteredGroups);
  } else {
    const groupsPerPage = state.stopsListPageSize;
    const totalGroups = filteredGroups.length;
    const groupsToShow = filteredGroups.slice(0, state.stopsListPage * groupsPerPage);

    let html = '';

    groupsToShow.forEach(group => {
      const isExpanded = state.expandedStopGroup === group.id;
      const pluralForm = group.routeCount === 1 ? 'linia' : 
        (group.routeCount % 10 >= 2 && group.routeCount % 10 <= 4 && (group.routeCount % 100 < 10 || group.routeCount % 100 >= 20)) 
        ? 'linie' : 'linii';
      
      // For single-stop groups, make them directly clickable
      if (group.isSingleStop) {
        const stop = group.stops[0];
        html += `
          <div class="stop-group p-3 border-b hover:bg-blue-50 cursor-pointer" data-stop-id="${stop.stop_id}">
            <div class="font-semibold">${Utils.escapeHtml(group.name)}</div>
            <div class="text-xs text-gray-600">${group.routeCount} ${pluralForm}</div>
          </div>
        `;
      } else {
        // Multi-stop groups: show as expandable
        html += `
          <div class="stop-group p-3 border-b hover:bg-blue-50 cursor-pointer ${isExpanded ? 'bg-blue-50' : ''}" data-group-id="${Utils.escapeHtml(group.id)}">
            <div class="font-semibold">${Utils.escapeHtml(group.name)}</div>
            <div class="text-xs text-gray-600">${group.routeCount} ${pluralForm}</div>
          </div>
        `;
        
        // Poziom 2: Konkretne przystanki w grupie (tylko jeśli rozwinięta)
        if (isExpanded) {
          group.stops.forEach(stop => {
            const stopPluralForm = stop.routeCount === 1 ? 'linia' : 
              (stop.routeCount % 10 >= 2 && stop.routeCount % 10 <= 4 && (stop.routeCount % 100 < 10 || stop.routeCount % 100 >= 20)) 
              ? 'linie' : 'linii';
            
            html += `
              <div class="stop-item p-2 pl-6 border-b hover:bg-blue-100 cursor-pointer bg-white" data-stop-id="${stop.stop_id}">
                <div class="font-medium text-sm">${Utils.escapeHtml(stop.stop_name)}</div>
                <div class="text-xs text-gray-600">${stop.routeCount} ${stopPluralForm}</div>
              </div>
            `;
          });
        }
      }
    });

    // Add "Load More" button if there are more groups to display
    if (groupsToShow.length < totalGroups) {
      const remaining = totalGroups - groupsToShow.length;
      html += `
        <div class="p-4 text-center">
          <button id="load-more-stops" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">
            Pokaż więcej (${remaining} pozostało)
          </button>
        </div>
      `;
    }

    stopsList.innerHTML = html;

    const loadMoreBtn = $('load-more-stops');
    if (loadMoreBtn) {
      loadMoreBtn.addEventListener('click', () => {
        state.stopsListPage++;
        renderStopsView();
      });
    }
  }

  // Setup scroll listener for virtual list rendering
  if (useVirtualList) {
    const container = stopsList.parentElement;
    if (container) {
      // Remove old listener if exists
      if (container._virtualScrollHandler) {
        container.removeEventListener('scroll', container._virtualScrollHandler);
      }
      
      const scrollHandler = debounce(() => {
        renderVirtualStopsList(filteredGroups);
      }, 50);
      
      container._virtualScrollHandler = scrollHandler;
      container.addEventListener('scroll', scrollHandler);
    }
  }

  const searchInput = $('stops-search-input-header');
  if (searchInput) {
    // Update value to match current state
    searchInput.value = state.stopsListSearchQuery;
    
    const oldHandler = searchInput._searchHandler;
    if (oldHandler) {
      searchInput.removeEventListener('input', oldHandler);
    }
    
    const debouncedSearch = debounce((value) => {
      state.stopsListSearchQuery = value;
      state.stopsListPage = 1; // Reset pagination on new search
      renderStopsView();
    }, 500); // Debounce delay: 500ms for better UX
    
    const newHandler = (e) => {
      debouncedSearch(e.target.value);
    };
    searchInput._searchHandler = newHandler;
    searchInput.addEventListener('input', newHandler);
  }

  // Inicjalizuj mapę
  stopsMap.innerHTML = '';
  
  // Store reference to map in window for reuse
  if (window.stopsListMap) {
    try {
      window.stopsListMap.remove();
    } catch (e) {}
    window.stopsListMap = null;
  }
  
  // Initialize map immediately (removed setTimeout for better responsiveness)
  if (!stopsMap || stopsMap.offsetParent === null) return;
  
  let initialCenter = [52.23, 21.01];
  let initialZoom = 12;
  
  if (state.stopsListMapState) {
    initialCenter = [state.stopsListMapState.center.lat, state.stopsListMapState.center.lng];
    initialZoom = state.stopsListMapState.zoom;
  }
  
  const map = window.L.map(stopsMap).setView(initialCenter, initialZoom);
  window.stopsListMap = map;
	
    window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);
    
    const markers = window.L.markerClusterGroup({
      maxClusterRadius: 30,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      disableClusteringAtZoom: 17,
      iconCreateFunction: function(cluster) {
        const count = cluster.getChildCount();
        let c = ' marker-cluster-';
        if (count < 10) {
          c += 'small';
        } else if (count < 100) {
          c += 'medium';
        } else {
          c += 'large';
        }
        
        return new window.L.DivIcon({ 
          html: '<div><span>' + count + '</span></div>',
          className: 'marker-cluster marker-cluster-neutral' + c,
          iconSize: new window.L.Point(40, 40)
        });
      }
    });
    
    const bounds = [];
    
    // Always show all stops as markers
    stopsData.forEach(stop => {
      if (!stop.stop_lat || !stop.stop_lon) return;
      const lat = parseFloat(stop.stop_lat);
      const lon = parseFloat(stop.stop_lon);
      if (isNaN(lat) || isNaN(lon)) return;
      
      const marker = window.L.marker([lat, lon], {
        icon: createSvgIcon('#3b82f6')
      });
      
      // Popup behavior depends on whether a group is expanded
      if (state.expandedStopGroup === null) {
        // State 1: Lista pokazuje grupy - popup z klikalnym linkiem
        marker.bindPopup(`
          <a href="#" onclick="event.preventDefault(); 
            state.selectedStop = state.gtfsData.stopsIndex['${stop.stop_id}']; 
            state.stopViewFilteredRoutes = []; 
			state.stopsListMapState = null;
            render(); 
            return false;" 
            style="text-decoration: none; color:inherit;">
            <strong>${Utils.escapeHtml(stop.stop_name)}</strong><br>
            ${stop.routeCount} ${stop.routeCount === 1 ? 'linia' : 
              (stop.routeCount % 10 >= 2 && stop.routeCount % 10 <= 4 && (stop.routeCount % 100 < 10 || stop.routeCount % 100 >= 20)) 
              ? 'linie' : 'linii'}
          </a>
        `, { 
          closeButton: false  // Usuń "x"
        });
      } else {
        // State 2: Lista pokazuje przystanki - bezpośrednie przejście do STOP_DETAIL
        marker.on('click', () => {
          state.selectedStop = stop;
          state.stopViewFilteredRoutes = [];
          render();
        });
      }
      
      markers.addLayer(marker);
      bounds.push([lat, lon]);
    });
    
    map.addLayer(markers);
    
    // Center map on expanded group if any
    if (state.expandedStopGroup && !state.stopsListMapState) {
      const expandedGroup = groupsArray.find(g => g.id === state.expandedStopGroup);
      if (expandedGroup && expandedGroup.stops.length > 0) {
        const groupBounds = window.L.latLngBounds();
        expandedGroup.stops.forEach(stop => {
          if (stop.stop_lat && stop.stop_lon) {
            const lat = parseFloat(stop.stop_lat);
            const lon = parseFloat(stop.stop_lon);
            if (!isNaN(lat) && !isNaN(lon)) {
              groupBounds.extend([lat, lon]);
            }
          }
        });
        
        if (groupBounds.isValid()) {
          map.fitBounds(groupBounds, { padding: [50, 50], maxZoom: 20 });
        }
      }
    } else if (bounds.length > 0 && !state.stopsListMapState) {
      map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
    }
  
  const stopsListContainer = stopsList.parentElement || stopsList;
  
  if (stopsListContainer) {
    // Remove old handler
    if (stopsListContainer._stopGroupHandler) {
      stopsListContainer.removeEventListener('click', stopsListContainer._stopGroupHandler);
    }
    
    const groupHandler = (e) => {
      const stopGroup = e.target.closest('.stop-group');
      if (!stopGroup) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      const groupId = stopGroup.getAttribute('data-group-id');
      const stopId = stopGroup.getAttribute('data-stop-id');
      
      // Handle single-stop groups (they have data-stop-id instead of data-group-id)
      if (!groupId && stopId) {
        const stop = state.gtfsData.stopsIndex[stopId];
        
        if (stop) {
          // Set map to selected stop
          if (window.stopsListMap && stop.stop_lat && stop.stop_lon) {
            window.stopsListMap.setView(
              [parseFloat(stop.stop_lat), parseFloat(stop.stop_lon)],
              17
            );
          }
          
          state.selectedStop = stop;
          state.stopViewFilteredRoutes = [];
          render();
        }
        return;
      }
      
      const groupsArray = getOrBuildGroupsArray(stopsData);
      const group = groupsArray.find(g => g.id === groupId);
      
      // Always zoom map to clicked group
      if (group && group.stops.length > 0 && window.stopsListMap) {
        const groupBounds = window.L.latLngBounds();
        group.stops.forEach(stop => {
          if (stop.stop_lat && stop.stop_lon) {
            const lat = parseFloat(stop.stop_lat);
            const lon = parseFloat(stop.stop_lon);
            if (!isNaN(lat) && !isNaN(lon)) {
              groupBounds.extend([lat, lon]);
            }
          }
        });
        
        if (groupBounds.isValid()) {
          window.stopsListMap.flyToBounds(groupBounds, { 
            padding: [50, 50], 
            maxZoom: 17,
            duration: 0.5
          });
        }
      }
      
      // Toggle expansion
      if (state.expandedStopGroup === groupId) {
        state.expandedStopGroup = null;
      } else {
        state.expandedStopGroup = groupId;
      }
      
      renderStopsView();
    };
    
    stopsListContainer._stopGroupHandler = groupHandler;
    stopsListContainer.addEventListener('click', groupHandler);
  }

  const stopsList_el = $('stops-list');
  if (stopsList_el) {
    // Remove old handler if exists
    if (stopsList_el._stopItemHandler) {
      stopsList_el.removeEventListener('click', stopsList_el._stopItemHandler);
    }
    
    const handler = (e) => {
      const stopItem = e.target.closest('.stop-item');
      if (!stopItem) return;
      
      const stopId = stopItem.getAttribute('data-stop-id');
      const stop = state.gtfsData.stopsIndex[stopId];
      
if (stop) {
  // USTAW MAPĘ na wybrany przystanek
  if (window.stopsListMap && stop.stop_lat && stop.stop_lon) {
    window.stopsListMap.setView(
      [parseFloat(stop.stop_lat), parseFloat(stop.stop_lon)],
      17 // lub twój ulubiony zoom
    );
  }

  // NIE mroź stanu mapy tutaj!

  state.selectedStop = stop;
  state.stopViewFilteredRoutes = [];
  render();
}
    };
    
    stopsList_el._stopItemHandler = handler;
    stopsList_el.addEventListener('click', handler);
  }
}

function collectRoutesForStop(stopId, selectedDate, filteredRouteIds = []) {
  if (!state.gtfsData || !stopId) return [];
  
  const activeServices = getServicesForDate(selectedDate);
  const routesData = [];
  
  const routesAtStop = new Map();
  
  state.gtfsData.routes.forEach(route => {
    const trips = state.gtfsData.tripsIndex[route.route_id] || [];
    let passesThrough = false;
    let tripCount = 0;
    
    trips.forEach(trip => {
      if (! activeServices.includes(trip.service_id)) return;
      const stopTimes = getStopTimesIndexOrCache()[trip.trip_id] || [];
      if (stopTimes.some(st => st.stop_id === stopId)) {
        passesThrough = true;
        tripCount++;
      }
    });
    
    if (passesThrough) {
      routesAtStop.set(route. route_id, { route, tripCount });
    }
  });
  
  let routesToProcess = Array. from(routesAtStop.values());
  if (filteredRouteIds.length > 0) {
    routesToProcess = routesToProcess.filter(rd => filteredRouteIds.includes(rd.route.route_id));
  }
  
  // No limit on number of routes - removed artificial 20 route limit
  
  // UPROSZCZONA LOGIKA - jedna linia = jedna trasa (najpopularniejsza sekwencja)
  routesToProcess.forEach(({ route, tripCount }) => {
    const trips = state.gtfsData.tripsIndex[route.route_id] || [];
    const activeTrips = trips.filter(t => activeServices.includes(t.service_id));
    
    // UPROSZCZENIE: dla przystanku jest tylko jeden kierunek tej linii
    const representative = findMostFrequentTripPattern(
      activeTrips, 
      getStopTimesIndexOrCache(),
      stopId,
      activeServices
    );
    
    if (!representative) return; // Brak tripów przez ten przystanek
    
    const stopsToDraw = [];
    representative.stopIds.forEach(sid => {
      const stop = state.gtfsData.stopsIndex[sid];
      if (stop && stop.stop_lat && stop.stop_lon) {
        const lat = parseFloat(stop.stop_lat);
        const lon = parseFloat(stop.stop_lon);
        if (!isNaN(lat) && !isNaN(lon)) {
          stopsToDraw.push({
            id: sid,
            lat,
            lon,
            name: stop.stop_name || sid,
            type: 'core'
          });
        }
      }
    });
    
    if (stopsToDraw.length > 1) {
      const meta = getRouteTypeMeta(route.route_type);
      
      const representativeTrip = activeTrips.find(t => t.trip_id === representative.tripId);
      const shapeId = representativeTrip?.shape_id || null;
      const direction = representativeTrip?.direction_id || '0';
      
      routesData.push({
        route,
        direction: direction,
        directionName: `Direction ${direction}`,
        stops: stopsToDraw,
        color: meta.color || '#3b82f6',
        tripCount: representative.frequency,
        shapeId: shapeId
      });
    }
  });
  
  return { routes: routesData };
}

function updateRouteFilterButtons() {
  const allBtn = $('filter-all-routes');
  if (allBtn) {
    if (state.stopViewFilteredRoutes.length === 0) {
      allBtn.className = allBtn.className.replace(/bg-white hover:bg-gray-50/g, 'bg-blue-500 text-white');
    } else {
      allBtn.className = allBtn.className.replace(/bg-blue-500 text-white/g, 'bg-white hover:bg-gray-50');
    }
  }
  
  $$('.route-filter-btn').forEach(btn => {
    const routeId = btn.getAttribute('data-route-id');
    const isSelected = state.stopViewFilteredRoutes.includes(routeId);
    if (isSelected) {
      btn.className = btn.className.replace(/bg-white hover:bg-gray-50/g, 'bg-blue-500 text-white');
    } else {
      btn.className = btn.className.replace(/bg-blue-500 text-white/g, 'bg-white hover:bg-gray-50');
    }
  });
}

// Helper function to get trip destination (headsign or last stop name)
function getTripDestination(dep) {
  // 1. Prefer trip_headsign if available
  if (dep.headsign && dep.headsign.trim().length > 0) {
    return dep.headsign;
  }
  
  // 2. Fallback: last stop_name from stop_times sequence
  const stopTimes = getStopTimesIndexOrCache()[dep.trip.trip_id] || [];
  if (stopTimes.length > 0) {
    const sorted = stopTimes.slice().sort((a, b) => {
      const seqA = parseInt(a.stop_sequence || '0', 10);
      const seqB = parseInt(b.stop_sequence || '0', 10);
      return seqA - seqB;
    });
    const lastStopId = sorted[sorted.length - 1]?.stop_id;
    const lastStop = state.gtfsData.stopsIndex[lastStopId];
    if (lastStop?.stop_name) {
      return lastStop.stop_name;
    }
  }
  
  // 3. Final fallback
  return "-";
}

function updateDeparturesTable() {
  const tableContainer = document.querySelector('#stop-detail-departures-table');
  if (!tableContainer || !state.stopDetailDepartures) return;
  
  let filteredDepartures = state.stopDetailDepartures;
  if (state.stopViewFilteredRoutes.length > 0) {
    filteredDepartures = state.stopDetailDepartures.filter(d => 
      state.stopViewFilteredRoutes.includes(d.route.route_id)
    );
  }
  
  // Generate table HTML
  if (filteredDepartures.length === 0) {
    tableContainer.innerHTML = '<div class="text-gray-700 p-4">No departures found</div>';
  } else {
    const tableHtml = `
<table
  class="text-sm border w-full"
  style="border-collapse: collapse; table-layout: fixed;"
>
  <colgroup>
    <col style="width:4.5em">
    <col style="width:max-content">
    <col style="width:100%">
  </colgroup>

  <thead class="bg-gray-50 sticky top-0 z-10">
    <tr>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Czas
      </th>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Linia
      </th>
      <th class="text-left p-3 font-semibold border">
        Kierunek
      </th>
    </tr>
  </thead>

  <tbody>
    ${filteredDepartures.map(dep => {
      const meta = getRouteTypeMeta(dep.route.route_type);

      return '<tr class="border-b hover:bg-gray-50">' +
        '<td class="p-1 font-bold border whitespace-nowrap text-center">' +
          Utils.formatTime(dep.time) +
        '</td>' +
        '<td class="p-1 border whitespace-nowrap">' +
          '<div class="flex justify-center">' +
            routeBadgeHtml(dep.route, meta) +
          '</div>' +
        '</td>' +
        '<td class="p-1 border break-words">' +
          Utils.escapeHtml(getTripDestination(dep)) +
        '</td>' +
      '</tr>';
    }).join("")}
  </tbody>
</table>
`;
    tableContainer.innerHTML = tableHtml;
  }
}

// ═══════════════════════════════════════════════════════════════
// 13. UI RENDERING - TIMETABLE
// ═══════════════════════════════════════════════════════════════
async function renderTimetable() {
  const container = $('timetable-container'); 
  if (!container) return;
  
  // Get variants data early to build dropdown
  const trips = getAllTripsForRoute();
  if (trips.length === 0) {
    container.innerHTML = "<div class='p-4 text-gray-500'>No schedule available.</div>";
    return;
  }
  
  // Show loading state
  container.innerHTML = `
    <div class="p-4 text-gray-500 flex items-center gap-2">
      <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-500"></div>
      Loading variants...
    </div>
  `;
  
  // Load variants asynchronously (no UI freeze)
  const variantsData = await getVariantsDataAsync();
  const tripToVariantGlobal = variantsData ? variantsData.tripToVariant : {};
  
  // Build variant dropdown options
  let variantOptionsHtml = '<option value="0">Wszystko</option>';
  if (variantsData && variantsData.variantDetails) {
    const variantNumbers = Object.keys(variantsData.variantDetails).map(k => parseInt(k, 10)).filter(n => !isNaN(n)).sort((a, b) => a - b);
    variantNumbers.forEach(vNum => {
      variantOptionsHtml += `<option value="${vNum}">Wariant #${vNum}</option>`;
    });
  }
  
  // Calculate variant range label
  let variantRangeLabel = '';
  if (state.selectedVariantFilter > 0 && variantsData && variantsData.variantDetails) {
    const variant = variantsData.variantDetails[state.selectedVariantFilter];
    if (variant && variant.stopDetails && variant.stopDetails.length > 0) {
      const firstStop = variant.stopDetails[0]?.stop_name || '?';
      const lastStop = variant.stopDetails[variant.stopDetails.length - 1]?.stop_name || '?';
      variantRangeLabel = `${firstStop} - ${lastStop}`;
    }
  }
  
  // Determine depot button state
  const isVariantMode = state.selectedVariantFilter > 0;
  const depotButtonDisabled = isVariantMode ? 'disabled' : '';
  const depotButtonClasses = isVariantMode 
    ? 'bg-blue-500 text-white px-4 py-2 rounded opacity-50 cursor-not-allowed'
    : 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600';
  const depotButtonText = isVariantMode 
    ? 'Zjazdy widoczne (tryb wariantu)'
    : (state.showAllTrips ? 'Ukryj zjazdy i wyjazdy' : 'Pokaż zjazdy i wyjazdy');
  
  container.innerHTML = `
    <div class="flex gap-4 items-center mb-4">
      <button id="toggle-depot-trips-main" class="${depotButtonClasses}" ${depotButtonDisabled} style="min-width: 280px;">
        ${depotButtonText}
      </button>
      <select id="variant-filter-select" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 cursor-pointer font-medium" style="appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27white%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1.5em 1.5em; padding-right: 2.5rem; margin-left:-0.5rem;">
        ${variantOptionsHtml}
      </select>
      <div class="flex-1 text-right text-gray-700 font-medium" id="variant-range-label">
        ${variantRangeLabel}
      </div>
    </div>
    <div id="schedule-table-root"></div>
`;
  
  // Set selected value for dropdown
  const variantSelect = $('variant-filter-select');
  if (variantSelect) {
    variantSelect.value = state.selectedVariantFilter.toString();
  }
  
  const depotButton = $('toggle-depot-trips-main');
  if (depotButton) {
    depotButton.onclick = () => { 
      if (state.selectedVariantFilter > 0) return; // Disabled in variant mode
      
      const tableRoot = $('schedule-table-root');
      const scrollContainer = tableRoot?.querySelector('.overflow-x-auto');
      const savedScrollLeft = scrollContainer ? scrollContainer.scrollLeft : 0;
      const savedScrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
      
      state.showAllTrips = !state.showAllTrips; 
      renderTimetable(); 
      
      // Restore scroll position after render
      setTimeout(() => {
        const newScrollContainer = $('schedule-table-root')?.querySelector('.overflow-x-auto');
        if (newScrollContainer) {
          newScrollContainer.scrollLeft = savedScrollLeft;
          newScrollContainer.scrollTop = savedScrollTop;
        }
      }, 0);
    };
  }
  
  if (variantSelect) {
    variantSelect.onchange = async (e) => {
      state.selectedVariantFilter = parseInt(e.target.value, 10);
      
      // Auto-enable showAllTrips when variant is selected
      if (state.selectedVariantFilter > 0) {
        state.showAllTrips = true;
        // Update map to show the selected variant
        state.selectedVariant = state.selectedVariantFilter;
      }
      
      renderTimetable();
      
      // Update map to show the selected variant
      if (typeof updateMap === 'function') {
        await updateMap();
      }
    };
  }

  const tableRoot = $('schedule-table-root'); if (!tableRoot) return;

if (variantsData && variantsData.variantDetails) {
  const available = Object.keys(variantsData.variantDetails).map(k=>parseInt(k,10)).filter(n=>!isNaN(n));
  if (available.length>0 && !available.includes(state.selectedVariant)) state.selectedVariant = available[0];
}

let masterList = ensureCanonicalMasterListForCurrentSelection();

const tripStopMaps = {};
trips.forEach(trip => {
  const stopTimes = getStopTimesIndexOrCache()[trip.trip_id] || [];
  stopTimes.sort((a,b)=>parseInt(a.stop_sequence||'0') - parseInt(b.stop_sequence||'0'));
  tripStopMaps[trip.trip_id] = stopTimes;
});

const profile = getCurrentRouteProfile();

// === STEP 3: Use pre-computed trip processing from profile ===
// Profile already computed all stop classification, pStops filtering, and service/depot classification
const processedTrips = trips.map(trip => {
  const processed = profile && profile.processedTrips ? profile.processedTrips[trip.trip_id] : null;
  
  if (!processed) {
    // This should rarely happen - profile should process all trips
    console.warn('No processed data for trip (profile not built?):', trip.trip_id);
    // Safe fallback: empty trip with no stops
    return { 
      ...trip, 
      pStops: [], 
      hasPassenger: false, 
      hasPassengerInsideCore: false, 
      isServiceTrip: false,
      firstCoreIdx: -1, 
      lastCoreIdx: -1 
    };
  }
  
  // Use pre-computed data from profile
  return { 
    ...trip, 
    pStops: processed.pStops,
    hasPassenger: processed.hasPassenger,
    hasPassengerInsideCore: processed.hasPassengerInsideCore,
    isServiceTrip: processed.isServiceTrip,
    firstCoreIdx: processed.firstCoreIdx,
    lastCoreIdx: processed.lastCoreIdx
  };
}).filter(t => state.showAllTrips || (t.pStops.length > 0 && t.isServiceTrip));

// Filter trips by selected variant
let filteredTrips = processedTrips;
if (state.selectedVariantFilter > 0) {
  filteredTrips = processedTrips.filter(trip => {
    const variantNum = tripToVariantGlobal[trip.trip_id];
    return variantNum === state.selectedVariantFilter;
  });
}

if (filteredTrips.length === 0) { 
  tableRoot.innerHTML = "<div class='p-4 text-gray-500'>No trips for this threshold.</div>"; 
  return; 
}

let sortedTrips = sortTripsByMostFrequentStop(filteredTrips, tripStopMaps, state.gtfsData.stopsIndex);
sortedTrips = sortedTrips.map(t => {
  const firstStop = t.pStops[0];
  let start = firstStop?.departure_time || "00:00:00";
  if (String(start).match(/^\d:/)) start = "0" + start;
  return { ...t, start };
});

const newTripStopMaps = {};
sortedTrips.forEach(t => {
  // When showAllTrips is true, use ALL stops from the trip (including depot/technical stops)
  // When showAllTrips is false, use only passenger stops (pStops)
  if (state.showAllTrips) {
    // Use all stops from the original tripStopMaps
    newTripStopMaps[t.trip_id] = tripStopMaps[t.trip_id] || [];
  } else {
    // Use only passenger stops
    newTripStopMaps[t.trip_id] = t.pStops;
  }
});

if (!masterList || masterList.length === 0) {
  tableRoot.innerHTML = "<div class='p-4 text-gray-500'>Unable to build schedule.</div>";
  return;
}

const tripMappings = createTripMappings(sortedTrips, newTripStopMaps, masterList);

const visibleRowIndices = [];
const visiblePassengerRowIndices = []; // Only passenger rows (excluding tail)

masterList.forEach((mStop, mIdx) => {
  // Rule 1: Hide tail rows when showAllTrips is OFF
  if (!state.showAllTrips && mStop.nodeType === 'tail') {
    return; // Skip this row
  }
  
  // Rule 2: Hide rows with no departures for current date in any trip
  let hasAnyDeparture = false;
  for (let tripIdx = 0; tripIdx < sortedTrips.length; tripIdx++) {
    const mapping = tripMappings[tripIdx];
    if (mapping[mIdx]) {
      hasAnyDeparture = true;
      break;
    }
  }
  
  if (!hasAnyDeparture) {
    return; // Skip this row - no trips stop here on this date
  }
  
  // Row is visible
  visibleRowIndices.push(mIdx);
  
  // Track passenger rows separately for adjacent-swaps ordering
  if (mStop.nodeType !== 'tail') {
    visiblePassengerRowIndices.push(mIdx);
  }
});

// === STEP 7: Apply adjacent-swaps column ordering (reorder TRIPS, not rows) ===
const serviceTrips = [];
const depotTrips = [];

sortedTrips.forEach(trip => {
  // Use pre-computed classification from profile
  if (trip.isServiceTrip) {
    serviceTrips.push(trip);
  } else {
    depotTrips.push(trip);
  }
});

const key = getCanonicalKeyForCurrentSelection() || 'fallback';
const dir = state.selectedDirection || '0';
const columnOrderCacheKey = `${key}::${dir}::${state.selectedDate}::${state.showAllTrips}`;

let orderedServiceTrips = serviceTrips;
if (serviceTrips.length > 0) {
  const serviceTripMappings = serviceTrips.map(trip => {
    const originalIdx = sortedTrips.findIndex(t => t.trip_id === trip.trip_id);
    return tripMappings[originalIdx];
  });
  
  // Check cache
  if (state.columnOrderCache[columnOrderCacheKey]) {
    const cachedTripIds = state.columnOrderCache[columnOrderCacheKey];
    const tripMap = new Map(serviceTrips.map(t => [t.trip_id, t]));
    orderedServiceTrips = cachedTripIds
      .map(tid => tripMap.get(tid))
      .filter(Boolean);
    
    // If cache doesn't match, recompute
    if (orderedServiceTrips.length !== serviceTrips.length) {
      orderedServiceTrips = adjacentSwapOrder(
        serviceTrips,
        serviceTripMappings,
        visiblePassengerRowIndices, // Use only passenger rows for ranking
        adjacentSwapOrderConfig
      );
      state.columnOrderCache[columnOrderCacheKey] = orderedServiceTrips.map(t => t.trip_id);
    }
  } else {
    // Compute and cache
    orderedServiceTrips = adjacentSwapOrder(
      serviceTrips,
      serviceTripMappings,
      visiblePassengerRowIndices, // Use only passenger rows for ranking
      adjacentSwapOrderConfig
    );
    state.columnOrderCache[columnOrderCacheKey] = orderedServiceTrips.map(t => t.trip_id);
  }
}

const orderedDepotTrips = depotTrips.slice().sort((a, b) => {
  const getFirstCoreTime = (trip) => {
    if (!profile || !profile.coreStops) return null;
    const coreStopsSet = new Set(profile.coreStops);
    const stops = newTripStopMaps[trip.trip_id] || [];
    
    for (let i = 0; i < stops.length; i++) {
      if (coreStopsSet.has(stops[i].stop_id)) {
        return stops[i].departure_time || stops[i].arrival_time;
      }
    }
    return null;
  };
  
  const timeA = getFirstCoreTime(a);
  const timeB = getFirstCoreTime(b);
  
  // Both have firstCoreTime - compare
  if (timeA && timeB) {
    const diff = Utils.timeToMinutes(timeA) - Utils.timeToMinutes(timeB);
    if (diff !== 0) return diff;
  } else if (timeA) {
    return -1; // a has time, b doesn't - a comes first
  } else if (timeB) {
    return 1; // b has time, a doesn't - b comes first
  }
  
  // Tie-breaker: trip_id
  return a.trip_id.localeCompare(b.trip_id);
});

let orderedTrips;
if (state.showAllTrips) {
  orderedTrips = [...orderedServiceTrips, ...orderedDepotTrips];
} else {
  // When showAllTrips is false, only show service trips
  orderedTrips = orderedServiceTrips;
}

const orderedTripMappings = orderedTrips.map(trip => {
  const originalIdx = sortedTrips.findIndex(t => t.trip_id === trip.trip_id);
  return tripMappings[originalIdx];
});

// Use orderedTrips and orderedTripMappings for rendering
sortedTrips = orderedTrips;
const finalTripMappings = orderedTripMappings;

// === POPULATE CACHED TIMETABLE DATA FOR MODAL ===
// Store all trips (including those that might be hidden)
state.currentTimetableData.allTrips = trips; // Store ALL trips before filtering

const stopDepartures = {};
masterList.forEach((mStop) => {
  const allStopIds = mStop.stopIds || [mStop.id];
  
  const departures = [];
  
  // Go through ALL trips (not just sortedTrips) to include hidden ones
  trips.forEach(trip => {
    const stopTimes = getStopTimesIndexOrCache()[trip.trip_id] || [];
    const stopTime = stopTimes.find(st => allStopIds.includes(st.stop_id));
    
    if (stopTime) {
      const departureTime = stopTime.departure_time || stopTime.arrival_time;
      if (departureTime) {
        departures.push({
          trip_id: trip.trip_id,
          time: departureTime,
          trip: trip,
          service_id: trip.service_id,
          headsign: trip.trip_headsign || ''
        });
      }
    }
  });
  
  // Store departures for all stopIds in this merged stop
  allStopIds.forEach(stopId => {
    stopDepartures[stopId] = departures;
  });
});

state.currentTimetableData.stopDepartures = stopDepartures;
// === END CACHED DATA ===
      
      let html = '<div class="overflow-x-auto"><table class="text-sm border-collapse border border-gray-300 w-full bg-white"><thead class="bg-gray-50 sticky top-0">';
      html += '<tr>';
      
// NAGŁÓWEK "Stop Name": 
      // padding: 14px (góra/dół - wysokość) 8px (prawo) 14px (dół) 24px (lewo - wcięcie)
      html += '<th class="text-left font-semibold border border-gray-300 sticky left-0 bg-gray-50 z-30" style="min-width: 250px; padding: 14px 8px 14px 10px;">Przystanek</th>';
      
      sortedTrips.forEach(trip => {
        const vNum = tripToVariantGlobal[trip.trip_id] || 1;
        const isSelected = state.selectedVariant === vNum;
        html += `<th class="p-1 font-semibold border border-gray-300 text-center whitespace-nowrap text-xs cursor-pointer ${isSelected ? 'bg-blue-500 text-white' : 'bg-gray-200 hover:bg-gray-300'}" style="width:58px;" data-variant="${vNum}" tabindex="0" role="button">#${vNum}</th>`;
      });
      html += '</tr></thead><tbody>';

      // Main loop: generate each row for VISIBLE stops only
      visibleRowIndices.forEach((mIdx) => {
        const mStop = masterList[mIdx];
        html += '<tr class="hover:bg-gray-50">';
        
        const isOnDemandStop = sortedTrips.some(trip => {
          const stopMatch = newTripStopMaps[trip.trip_id]?.find(st => st.stop_id === mStop.id);
          return stopMatch?.isOnDemand;
        });
        
        // First column: stop name cell with onclick for modal
        // Note: mStop.id and mStop.name are escaped to prevent XSS
        html += `<td class="p-2 font-medium sticky left-0 bg-white border border-gray-300 cursor-pointer hover:bg-blue-50 z-10" style="min-width:250px; padding-left: 10px;" onclick="openStopTimetable('${Utils.escapeHtml(mStop.id)}')">${Utils.escapeHtml(mStop.name)}${isOnDemandStop ? ' <span style="color: #ff0000; font-style: normal; margin-left: 4px;">&#128276;</span>' : ''}</td>`;

        const isMergedStop = mStop.stopIds && mStop.stopIds.length > 1;

        // Inner loop: generate time cells for each trip
        finalTripMappings.forEach((mapping, tripIdx) => {
          const stopMatch = mapping[mIdx];
          const trip = sortedTrips[tripIdx];
          
          if (stopMatch) {
            let cellTooltip = '';
            
            if (isMergedStop) {
              const actualStopId = stopMatch.stop_id;  // ← Właściwy stop_id dla TEJ komórki!
              const stopData = state.gtfsData.stopsIndex[actualStopId];
              
              if (stopData) {
                const infoParts = [];
                if (stopData.stop_id) infoParts.push(`ID: ${Utils.escapeHtml(stopData.stop_id)}`);
                if (stopData.stop_desc) infoParts.push(Utils.escapeHtml(stopData.stop_desc));
                if (stopData.platform_code) infoParts.push(`Peron: ${Utils.escapeHtml(stopData.platform_code)}`);
                
                if (infoParts.length > 0) {
                  cellTooltip = infoParts.join('<br>');
                }
              }
            }
            
            // Renderuj komórkę z właściwym tooltipem
            if (cellTooltip) {
              html += `<td class="p-1 text-center text-xs border border-gray-300 time-cell-with-tooltip">
                ${Utils.formatTime(stopMatch.departure_time || stopMatch.arrival_time)}
                <span class="tooltip-content">${cellTooltip}</span>
              </td>`;
            } else {
              // No tooltip for non-merged stops
              html += `<td class="p-1 text-center text-xs border border-gray-300">
                ${Utils.formatTime(stopMatch.departure_time || stopMatch.arrival_time)}
              </td>`;
            }
          } else {
            // FIX #7: Add "&lt;" symbol for empty cells to indicate no service
            html += '<td class="p-1 text-center text-xs border border-gray-300 text-gray-400">&lt;</td>';
          }
        });
        
        html += '</tr>';
      });
      html += '</tbody></table></div>';
      tableRoot.innerHTML = html;
      
      // FIX #5: Add tooltip positioning on hover
      setTimeout(() => {
        const timeCells = tableRoot.querySelectorAll('.time-cell-with-tooltip');
        timeCells.forEach(cell => {
          cell.addEventListener('mouseenter', function(e) {
            const tooltip = this.querySelector('.tooltip-content');
            if (!tooltip) return;
            
            const cellRect = this.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            const top = cellRect.top - tooltipRect.height - 8;
            const left = cellRect.left + (cellRect.width / 2) - (tooltipRect.width / 2);
            
            const finalTop = Math.max(10, top);
            const finalLeft = Math.max(10, Math.min(left, window.innerWidth - tooltipRect.width - 10));
            
            tooltip.style.top = finalTop + 'px';
            tooltip.style.left = finalLeft + 'px';
          });
        });
      }, 0);
      
      const thead = tableRoot.querySelector('thead');
      if (thead && !thead.dataset.variantListenerAttached) {
        function applyHeaderSelection(rootThead) {
          if (!rootThead) return;
          $$('th[data-variant]', rootThead).forEach(h => {
            const hv = parseInt(h.getAttribute('data-variant'), 10) || 1;
            if (hv === state.selectedVariant) {
              h.classList.remove('bg-gray-200', 'hover:bg-gray-300');
              h.classList.add('bg-blue-500', 'text-white');
              h.setAttribute('aria-pressed', 'true');
            } else {
              h.classList.remove('bg-blue-500', 'text-white');
              h.classList.add('bg-gray-200');
              h.setAttribute('aria-pressed', 'false');
            }
          });
        }
        thead.addEventListener('click', async (evt) => {
          const th = evt.target.closest('th[data-variant]');
          if (!th) return;
          const v = parseInt(th.getAttribute('data-variant'), 10) || 1;
          if (state.selectedVariant === v) return;
          state.selectedVariant = v;
          applyHeaderSelection(thead);
          if (typeof updateMap === 'function') await updateMap();
        });
        thead.addEventListener('keydown', async (evt) => {
          if (evt.key !== 'Enter' && evt.key !== ' ') return;
          const th = evt.target.closest('th[data-variant]');
          if (!th) return;
          evt.preventDefault();
          const v = parseInt(th.getAttribute('data-variant'), 10) || 1;
          if (state.selectedVariant === v) return;
          state.selectedVariant = v;
          applyHeaderSelection(thead);
          if (typeof updateMap === 'function') await updateMap();
          th.focus();
        });
        const scheduleRoot = $('schedule-table-root');
        if (scheduleRoot && !scheduleRoot.dataset.variantObserverAttached) {
          const mo = new MutationObserver((mutations) => {
            const newThead = scheduleRoot.querySelector('thead');
            if (newThead) applyHeaderSelection(newThead);
          });
          mo.observe(scheduleRoot, { childList: true, subtree: true });
          scheduleRoot.dataset.variantObserverAttached = '1';
        }
        applyHeaderSelection(thead);
        thead.dataset.variantListenerAttached = '1';
      }
    }

function openStopTimetable(stopId) {
  if (!state.gtfsData || !state.selectedDate) return;
  const stop = state.gtfsData.stopsIndex[stopId];
  if (!stop) return;

  // Collect departures at this stop
  // If a route is selected, filter by route and direction
  // Otherwise, show ALL routes
  let allDepartures = [];
  
  if (state.selectedRoute && state.selectedDirection !== undefined) {
    // Filter by selected route and direction
    const routeTrips = state.gtfsData.tripsIndex[state.selectedRoute.route_id] || [];
    const directionTrips = routeTrips.filter(t => (t.direction_id || '0') === state.selectedDirection);
    
    directionTrips.forEach(trip => {
      const stopTimes = getStopTimesIndexOrCache()[trip.trip_id] || [];
      const stopTime = stopTimes.find(st => st.stop_id === stopId);
      
      if (stopTime) {
        const departureTime = stopTime.departure_time || stopTime.arrival_time;
        if (departureTime) {
          allDepartures.push({
            trip_id: trip.trip_id,
            time: departureTime,
            trip: trip,
            service_id: trip.service_id,
            headsign: trip.trip_headsign || '',
            route: state.selectedRoute
          });
        }
      }
    });
  } else {
    // No route/direction filter - show ALL routes
    state.gtfsData.routes.forEach(route => {
      const routeTrips = state.gtfsData.tripsIndex[route.route_id] || [];
      
      routeTrips.forEach(trip => {
        const stopTimes = getStopTimesIndexOrCache()[trip.trip_id] || [];
        const stopTime = stopTimes.find(st => st.stop_id === stopId);
        
        if (stopTime) {
          const departureTime = stopTime.departure_time || stopTime.arrival_time;
          if (departureTime) {
            allDepartures.push({
              trip_id: trip.trip_id,
              time: departureTime,
              trip: trip,
              service_id: trip.service_id,
              headsign: trip.trip_headsign || '',
              route: route
            });
          }
        }
      });
    });
  }

  // Determine main destination based on the currently selected route (if any)
  let mainDestination = '';
  let mainTerminusStopId = null;
  
  if (state.selectedRoute) {
    const routeTrips = state.gtfsData.tripsIndex[state.selectedRoute.route_id] || [];
    const directionTrips = routeTrips.filter(t => (t.direction_id || '0') === state.selectedDirection);
    
    try {
      const directions = getAvailableDirections();
      const currentDir = directions.find(d => String(d.id) === String(state.selectedDirection));
      if (currentDir) {
        mainDestination = currentDir.fullName || currentDir.name || '';
      }
    } catch (e) {
      // Ignore errors
    }
    
    if (!mainDestination) {
      const headsigns = directionTrips.map(t => t.trip_headsign).filter(h => h);
      const headsignCounts = {};
      headsigns.forEach(h => { headsignCounts[h] = (headsignCounts[h] || 0) + 1; });
      let maxCount = 0;
      Object.keys(headsignCounts).forEach(h => {
        if (headsignCounts[h] > maxCount) {
          maxCount = headsignCounts[h];
          mainDestination = h;
        }
      });
    }

    if (mainDestination && directionTrips.length > 0) {
      const trip = directionTrips.find(t => t.trip_headsign === mainDestination);
      if (trip) {
        const stopTimes = getStopTimesIndexOrCache()[trip.trip_id] || [];
        if (stopTimes.length > 0) {
          const sortedStopTimes = [...stopTimes].sort((a, b) => parseInt(a.stop_sequence) - parseInt(b.stop_sequence));
          const lastStopTime = sortedStopTimes[sortedStopTimes.length - 1];
          mainTerminusStopId = lastStopTime.stop_id;
        }
      }
    }

    if (!mainDestination && directionTrips.length > 0) {
      const firstTrip = directionTrips[0];
      const stopTimes = getStopTimesIndexOrCache()[firstTrip.trip_id] || [];
      if (stopTimes.length > 0) {
        const lastStopTime = stopTimes[stopTimes.length - 1];
        const lastStop = state.gtfsData.stopsIndex[lastStopTime.stop_id];
        mainDestination = lastStop?.stop_name || '';
        mainTerminusStopId = lastStopTime.stop_id;
      }
    }
  } else {
    // No route selected - use the stop name as destination
    mainDestination = stop.stop_name || 'Unknown';
  }

  // Resolve dates for each column with future-oriented preference
  const mondayDate = findDateForDayOfWeek(1); // Monday
  const saturdayDate = findDateForDayOfWeek(6); // Saturday
  const sundayDate = findDateForDayOfWeek(0); // Sunday
  
  // Find holidays in upcoming week
  const nearbyHolidays = TimeUtils.findUpcomingHolidays(state.selectedDate);
  
  // Classify holidays by day of week
  const holidaysByDayOfWeek = new Map(); // dayOfWeek -> holiday object
  const weekdayHolidays = []; // Holidays falling on Mon-Fri
  
  nearbyHolidays.forEach(holiday => {
    const holidayDate = Utils.parseGTFSDate(holiday.date);
    if (holidayDate) {
      const dayOfWeek = holidayDate.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
      holidaysByDayOfWeek.set(dayOfWeek, holiday);
      
      // Check if it's a weekday (Mon-Fri)
      if (dayOfWeek >= 1 && dayOfWeek <= 5) {
        weekdayHolidays.push(holiday);
      }
    }
  });
  
  // Collect all weekday dates (Mon-Fri) for aggregation, excluding holidays
  const weekdayDates = [];
  const weekdayHolidayDates = new Set(weekdayHolidays.map(h => h.date));
  
  if (mondayDate) {
    const monDate = Utils.parseGTFSDate(mondayDate);
    for (let i = 0; i < 5; i++) { // Mon to Fri
      const d = new Date(monDate);
      d.setDate(monDate.getDate() + i);
      const dateStr = Utils.formatDateToGTFS(d);
      
      // Exclude weekday holidays from the weekday column
      if (!weekdayHolidayDates.has(dateStr)) {
        weekdayDates.push(dateStr);
      }
    }
  }
  
  // Get services for each date
  const weekdayServicesMap = new Map(); // Map of date -> services
  weekdayDates.forEach(dateStr => {
    weekdayServicesMap.set(dateStr, getServicesForDate(dateStr));
  });
  
  const saturdayServices = saturdayDate ? getServicesForDate(saturdayDate) : [];
  const sundayServices = sundayDate ? getServicesForDate(sundayDate) : [];

  // Helper: get trip terminus
  const getTripTerminus = (tripId) => {
    const stopTimes = getStopTimesIndexOrCache()[tripId] || [];
    if (stopTimes.length === 0) return null;
    const sortedStopTimes = [...stopTimes].sort((a, b) => parseInt(a.stop_sequence) - parseInt(b.stop_sequence));
    const lastStopTime = sortedStopTimes[sortedStopTimes.length - 1];
    return lastStopTime.stop_id;
  };

  const alternativeTermini = new Map();
  let nextLetter = 'a';

  /**
   * Process departures for a column with weekday annotations
   * For Mon-Fri column only: track which weekdays each minute appears on
   */
  const getTimesByHourWithAnnotations = (departures, isWeekdayColumn = false, dateToServicesMap = null) => {
    const hourGroups = {};
    
    // For weekday column: track minutes by weekday AND terminus
    // Key: "HH:MM:terminus" -> Set of day indices (0=Mon, 4=Fri)
    const minuteWeekdayMap = new Map();
    
    departures.forEach(departure => {
      if (!departure.time) return;
      const [hourStr, minute] = departure.time.split(':');
      let hour = parseInt(hourStr, 10);
      let displayHour = hour % 24;
      
      // Time window: 04:00 to next day 03:59
      if ((hour >= 4 && hour < 24) || (hour >= 24 && hour < 28)) {
        const terminusStopId = getTripTerminus(departure.trip_id);
        let terminusKey = '';
        
        // Determine terminus annotation (lowercase letters)
        if (terminusStopId && terminusStopId !== mainTerminusStopId) {
          const tripHeadsign = departure.headsign;
          if (tripHeadsign && tripHeadsign !== mainDestination) {
            if (!alternativeTermini.has(tripHeadsign)) {
              alternativeTermini.set(tripHeadsign, nextLetter);
              nextLetter = String.fromCharCode(nextLetter.charCodeAt(0) + 1);
            }
            terminusKey = alternativeTermini.get(tripHeadsign);
          } else if (!tripHeadsign) {
            const terminusStop = state.gtfsData.stopsIndex[terminusStopId];
            const terminusName = terminusStop?.stop_name || terminusStopId;
            if (terminusName !== mainDestination) {
              if (!alternativeTermini.has(terminusName)) {
                alternativeTermini.set(terminusName, nextLetter);
                nextLetter = String.fromCharCode(nextLetter.charCodeAt(0) + 1);
              }
              terminusKey = alternativeTermini.get(terminusName);
            }
          }
        }
        
        if (/^[0-5]\d$/.test(minute)) {
          if (!hourGroups[displayHour]) hourGroups[displayHour] = [];
          
          // Track weekday presence for Mon-Fri column
          // Key includes both minute AND terminus to handle different terminus on different days
          if (isWeekdayColumn && dateToServicesMap) {
            const mapKey = `${String(displayHour).padStart(2, '0')}:${minute}:${terminusKey}`;
            if (!minuteWeekdayMap.has(mapKey)) {
              minuteWeekdayMap.set(mapKey, new Set());
            }
            
            // Determine which weekday this departure runs on
            const serviceId = departure.service_id;
            weekdayDates.forEach((dateStr, dayIdx) => {
              const servicesForDay = dateToServicesMap.get(dateStr) || [];
              if (servicesForDay.includes(serviceId)) {
                minuteWeekdayMap.get(mapKey).add(dayIdx);
              }
            });
          }
          
          // Store minute with terminus key for later processing
          hourGroups[displayHour].push({ minute, terminusKey });
        }
      }
    });

    // Add weekday annotations (superscript numbers) for Mon-Fri column
    // Smart algorithm: only annotate the minority pattern when there are complementary patterns
    const weekdayAnnotations = new Map(); // Set of day indices -> superscript symbol
    let nextSuperscript = 1;
    
    if (isWeekdayColumn) {
      // First pass: collect all unique weekday patterns in this hour group
      const hourPatterns = new Map(); // hour -> Map of minuteKey -> weekday pattern
      
      Object.keys(hourGroups).forEach(hour => {
        hourPatterns.set(hour, new Map());
        
        hourGroups[hour].forEach(entry => {
          const { minute, terminusKey } = entry;
          const mapKey = `${String(hour).padStart(2, '0')}:${minute}:${terminusKey}`;
          const weekdaysSet = minuteWeekdayMap.get(mapKey);
          
          if (weekdaysSet && weekdaysSet.size > 0) {
            const pattern = Array.from(weekdaysSet).sort().join(',');
            hourPatterns.get(hour).set(mapKey, {
              pattern,
              dayCount: weekdaysSet.size,
              minute,
              terminusKey
            });
          }
        });
      });
      
      // Second pass: determine which patterns need annotation
      // Strategy: find complementary patterns and only annotate the minority
      const patternsToAnnotate = new Set();
      
      Object.keys(hourGroups).forEach(hour => {
        const patterns = hourPatterns.get(hour);
        const patternCounts = new Map(); // pattern -> count of occurrences
        const patternDayCounts = new Map(); // pattern -> number of days
        
        // Count pattern occurrences
        patterns.forEach((info, mapKey) => {
          const count = patternCounts.get(info.pattern) || 0;
          patternCounts.set(info.pattern, count + 1);
          patternDayCounts.set(info.pattern, info.dayCount);
        });
        
        // Find unique patterns (not all 5 days)
        const uniquePatterns = Array.from(patternCounts.keys()).filter(p => {
          const dayCount = patternDayCounts.get(p);
          return dayCount < 5;
        });
        
        if (uniquePatterns.length === 0) {
          // All patterns run on all 5 days - no annotation needed
        } else if (uniquePatterns.length === 1) {
          // Only one partial pattern - annotate it
          patternsToAnnotate.add(uniquePatterns[0]);
        } else {
          // Multiple patterns - check if they're complementary
          // Complementary means their union = all 5 weekdays
          const allDaysInPatterns = new Set();
          uniquePatterns.forEach(pattern => {
            pattern.split(',').forEach(d => allDaysInPatterns.add(d));
          });
          
          if (allDaysInPatterns.size === 5 && uniquePatterns.length === 2) {
            // Two complementary patterns - annotate only the minority (fewer days)
            const pattern1 = uniquePatterns[0];
            const pattern2 = uniquePatterns[1];
            const count1 = patternDayCounts.get(pattern1);
            const count2 = patternDayCounts.get(pattern2);
            
            if (count1 < count2) {
              patternsToAnnotate.add(pattern1);
            } else if (count2 < count1) {
              patternsToAnnotate.add(pattern2);
            } else {
              // Equal counts - annotate both
              patternsToAnnotate.add(pattern1);
              patternsToAnnotate.add(pattern2);
            }
          } else {
            // Non-complementary or more than 2 patterns - annotate all partial patterns
            uniquePatterns.forEach(p => patternsToAnnotate.add(p));
          }
        }
      });
      
      // Third pass: apply annotations
      Object.keys(hourGroups).forEach(hour => {
        const newMinutes = [];
        
        hourGroups[hour].forEach(entry => {
          const { minute, terminusKey } = entry;
          const mapKey = `${String(hour).padStart(2, '0')}:${minute}:${terminusKey}`;
          
          const weekdaysSet = minuteWeekdayMap.get(mapKey);
          let weekdayAnnotation = '';
          
          if (weekdaysSet && weekdaysSet.size > 0 && weekdaysSet.size < 5) {
            const weekdaysKey = Array.from(weekdaysSet).sort().join(',');
            
            // Only annotate if this pattern should be annotated
            if (patternsToAnnotate.has(weekdaysKey)) {
              if (!weekdayAnnotations.has(weekdaysKey)) {
                const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹'];
                
                // Special case: if pattern is a single day, use the weekday number (1-5)
                if (weekdaysSet.size === 1) {
                  const dayIndex = Array.from(weekdaysSet)[0];
                  // dayIndex: 0=Mon, 1=Tue, 2=Wed, 3=Thu, 4=Fri
                  // Display as: 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri
                  const weekdayNumber = dayIndex + 1;
                  weekdayAnnotations.set(weekdaysKey, superscripts[weekdayNumber]);
                } else {
                  // Multiple days: use sequential superscript
                  weekdayAnnotations.set(weekdaysKey, superscripts[nextSuperscript]);
                  nextSuperscript++;
                }
              }
              
              weekdayAnnotation = weekdayAnnotations.get(weekdaysKey);
            }
          }
          
          // Format: MM + terminus (lowercase) + weekday (superscript)
          newMinutes.push(minute + terminusKey + weekdayAnnotation);
        });
        
        hourGroups[hour] = newMinutes;
      });
    } else {
      // For non-weekday columns, just format the entries
      Object.keys(hourGroups).forEach(hour => {
        hourGroups[hour] = hourGroups[hour].map(entry => entry.minute + entry.terminusKey);
      });
    }

    // Sort minutes within each hour
    Object.keys(hourGroups).forEach(hour => {
      hourGroups[hour].sort((a, b) => {
        // Extract numeric minute for sorting (remove all annotations)
        const minA = parseInt(a.replace(/[^0-9]/g, ''));
        const minB = parseInt(b.replace(/[^0-9]/g, ''));
        return minA - minB;
      });
    });

    const hourOrder = [];
    for (let h = 4; h < 24; h++) hourOrder.push(h);
    for (let h = 0; h < 4; h++) hourOrder.push(h);
    const filteredOrder = hourOrder.filter(h => hourGroups[h]);
    const result = {};
    filteredOrder.forEach(h => { result[h] = hourGroups[h]; });
    
    return { timesByHour: result, weekdayAnnotations };
  };

  // Process weekday column with annotations (excluding weekday holidays)
  const weekdayDepartures = allDepartures.filter(d => {
    return Array.from(weekdayServicesMap.values()).some(services => services.includes(d.service_id));
  });
  
  const weekdayResult = getTimesByHourWithAnnotations(weekdayDepartures, true, weekdayServicesMap);
  const weekdayTimes = weekdayResult.timesByHour;
  const weekdayAnnotationsMap = weekdayResult.weekdayAnnotations;
  
  // Process weekend columns - check if replaced by holiday
  let saturdayColumn = null;
  let sundayColumn = null;
  
  const saturdayHoliday = holidaysByDayOfWeek.get(6); // Saturday
  const sundayHoliday = holidaysByDayOfWeek.get(0); // Sunday
  
  if (saturdayHoliday) {
    // Saturday is a holiday - use holiday data for this column
    const holidayServices = getServicesForDate(saturdayHoliday.date);
    const holidayDepartures = allDepartures.filter(d => holidayServices.includes(d.service_id));
    const holidayTimes = getTimesByHourWithAnnotations(holidayDepartures, false).timesByHour;
    saturdayColumn = { name: saturdayHoliday.name, times: holidayTimes, isHoliday: true };
  } else {
    // Normal Saturday
    const saturdayDepartures = allDepartures.filter(d => saturdayServices.includes(d.service_id));
    const saturdayTimes = getTimesByHourWithAnnotations(saturdayDepartures, false).timesByHour;
    saturdayColumn = { name: 'Sobota', times: saturdayTimes, isHoliday: false };
  }
  
  if (sundayHoliday) {
    // Sunday is a holiday - use holiday data for this column
    const holidayServices = getServicesForDate(sundayHoliday.date);
    const holidayDepartures = allDepartures.filter(d => holidayServices.includes(d.service_id));
    const holidayTimes = getTimesByHourWithAnnotations(holidayDepartures, false).timesByHour;
    sundayColumn = { name: sundayHoliday.name, times: holidayTimes, isHoliday: true };
  } else {
    // Normal Sunday
    const sundayDepartures = allDepartures.filter(d => sundayServices.includes(d.service_id));
    const sundayTimes = getTimesByHourWithAnnotations(sundayDepartures, false).timesByHour;
    sundayColumn = { name: 'Niedziela', times: sundayTimes, isHoliday: false };
  }
  
  // Process weekday holiday columns (Mon-Fri holidays as separate columns)
  const weekdayHolidayColumns = [];
  weekdayHolidays.forEach(holiday => {
    const holidayServices = getServicesForDate(holiday.date);
    const holidayDepartures = allDepartures.filter(d => holidayServices.includes(d.service_id));
    const holidayTimes = getTimesByHourWithAnnotations(holidayDepartures, false).timesByHour;
    
    weekdayHolidayColumns.push({
      name: holiday.name,
      times: holidayTimes,
      date: holiday.date
    });
  });

  const formatTimesByHour = (timesByHour) => {
    if (Object.keys(timesByHour).length === 0) return '<span style="color: #999;">No service</span>';
    const rows = [];
    const hourOrder = [];
    for (let h = 4; h < 24; h++) hourOrder.push(h);
    for (let h = 0; h < 4; h++) hourOrder.push(h);
    const hours = hourOrder.filter(h => timesByHour.hasOwnProperty(h));
    hours.forEach((hour, index) => {
      const hourPadded = String(hour).padStart(2,'0');
      const minutes = timesByHour[hour].join('  ');
      const bgColor = index % 2 === 0 ? '#e4e7eb' : '#ffffff';
      rows.push(`<div style="margin-bottom: 0; background: ${bgColor}; padding: 0.1rem 0.25rem; line-height: 1.3;"><div style="background: #4a5568; color: white; padding: 0.1rem 0.3rem; display: inline-block; font-weight: bold; min-width: 1.75rem; text-align: center; font-size: 0.8rem;">${hourPadded}</div><div style="padding: 0.1rem 0.3rem; display: inline; font-size: 0.8rem;">${minutes}</div></div>`);
    });
    return rows.join('');
  };

  // Build legends
  let legendHTML = '';
  const legendParts = [];
  
  // Weekday annotations legend
  if (weekdayAnnotationsMap.size > 0) {
    const weekdayNames = ['poniedziałek', 'wtorek', 'środa', 'czwartek', 'piątek'];
    const weekdayItems = [];
    
    weekdayAnnotationsMap.forEach((symbol, weekdaysKey) => {
      const dayIndices = weekdaysKey.split(',').map(s => parseInt(s));
      const dayNames = dayIndices.map(i => weekdayNames[i]).join(', ');
      weekdayItems.push(`<span style="font-weight: bold;">${symbol}</span> - ${dayNames}`);
    });
    
    if (weekdayItems.length > 0) {
      legendParts.push(weekdayItems.join(' • '));
    }
  }
  
  // Terminus annotations legend
  if (alternativeTermini.size > 0) {
    const terminusItems = [];
    alternativeTermini.forEach((letter, terminus) => {
      terminusItems.push(`<span style="font-weight: bold;">${letter}</span> - do ${Utils.escapeHtml(terminus)}`);
    });
    legendParts.push(terminusItems.join(' • '));
  }
  
  if (legendParts.length > 0) {
    legendHTML = `<div style="padding: 0.2rem 1rem; border-top: 1px solid #ddd; background: #f9fafb; font-size: 0.7rem; line-height: 1.2; margin: 0;">${legendParts.join(' | ')}</div>`;
  }

  // Build table HTML
  let tableHeaderHTML = `<tr style="background: #e5e7eb;">
    <th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">Dzień powszedni</th>
    <th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">${Utils.escapeHtml(saturdayColumn.name)}</th>
    <th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">${Utils.escapeHtml(sundayColumn.name)}</th>`;
  
  // Add weekday holiday columns
  weekdayHolidayColumns.forEach(hCol => {
    tableHeaderHTML += `<th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">${Utils.escapeHtml(hCol.name)}</th>`;
  });
  
  tableHeaderHTML += `</tr>`;
  
  let tableBodyHTML = `<tr>
    <td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(weekdayTimes)}</td>
    <td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(saturdayColumn.times)}</td>
    <td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(sundayColumn.times)}</td>`;
  
  // Add weekday holiday column data
  weekdayHolidayColumns.forEach(hCol => {
    tableBodyHTML += `<td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(hCol.times)}</td>`;
  });
  
  tableBodyHTML += `</tr>`;

  // Build modal header - show route badge only if a route is selected
  let headerHTML = '<div style="display: flex; gap: 1rem; align-items: flex-start; padding: 0.75rem 1rem; border-bottom: 2px solid #ddd;">';
  
  if (state.selectedRoute) {
    headerHTML += `<div style="border: 3px solid #000; height: 53px; font-weight: bold; font-size: 1.9rem; text-align: center; line-height: 1.2; min-width: 93px; display: flex; align-items: center; justify-content: center;">${state.selectedRoute.route_short_name || state.selectedRoute.route_id}</div>`;
  }
  
  headerHTML += `<div style="flex: 1; min-width: 0;"><div style="font-size: 1.75rem; font-weight: 900; line-height: 1.1; text-transform: uppercase;">${Utils.escapeHtml(stop.stop_name)}</div>`;
  
  if (mainDestination && state.selectedRoute) {
    headerHTML += `<div style="font-size: 1.5rem; font-weight: 700; line-height: 1.2; text-transform: uppercase; display: flex; align-items: center; white-space: nowrap;"><span style="margin-right: 0.3em;">&#8594;</span><span style="overflow-wrap: anywhere;">${Utils.escapeHtml(mainDestination)}</span></div>`;
  }
  
  headerHTML += '</div></div>';

  const modalHTML = `<div id="stop-timetable-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;"><div style="background: white; padding: 0; border-radius: 8px; max-width: 1400px; max-height: 95vh; overflow-y: auto;">${headerHTML}<table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd;"><thead>${tableHeaderHTML}</thead><tbody>${tableBodyHTML}</tbody></table>${legendHTML}</div></div>`;
  
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHTML;
  document.body.appendChild(modalContainer);
  
  let modalClosed = false;
  const closeModal = () => {
    if (modalClosed) return;
    modalClosed = true;
    if (modalContainer && document.body.contains(modalContainer)) document.body.removeChild(modalContainer);
    document.removeEventListener('keydown', handleEscape);
  };
  const handleEscape = (e) => { if (e.key === 'Escape') closeModal(); };
  document.addEventListener('keydown', handleEscape);
  $('stop-timetable-modal').onclick = (e) => { if (e.target.id === 'stop-timetable-modal') closeModal(); };
}

// ═══════════════════════════════════════════════════════════════
// 14. MAIN RENDER & VIEW CONTROL
// ═══════════════════════════════════════════════════════════════
    function getCurrentView() {
      // Early returns in order of precedence - simpler flow with clear hierarchy
      if (state.loading) return VIEW.LOADING;
      if (state.error) return VIEW.ERROR;
      if (!state.gtfsData) return VIEW.UPLOAD;
      
      // Stop-related views (check selectedStop before showStopsView for specificity)
      if (!state.selectedRoute && state.showStopsView && state.selectedStop) {
        return VIEW.STOP_DETAIL;
      }
      if (!state.selectedRoute && state.showStopsView) {
        return VIEW.STOPS_LIST;
      }
      
      // Route views
      if (!state.selectedRoute) return VIEW.ROUTES_LIST;
      return VIEW.ROUTE_TIMETABLE;
    }

    function renderImmediate() {
      const root = $('root');
      const currentView = getCurrentView();
      
      let html = `<div class="h-screen flex flex-col bg-gray-50">
  <div class="bg-white shadow-sm border-b px-4 py-1">
    <div class="max-w-6xl mx-auto" style="display:flex; align-items:center; justify-content:center; position:relative; min-height: 32px;">
      
      <button id="back-button" 
        class="bg-orange-500 text-white rounded cursor-pointer hover:bg-orange-600 inline-flex items-center justify-center font-medium" 
        style="position:absolute; left:0; width: 40px; height: 32px;" aria-label="Back">
        <span style="font-size: 1rem; line-height: 1; margin-top: -1px;">←</span>
      </button>

      <h2 class="text-xl font-bold text-orange-500" style="margin:0; line-height: 32px;">GTFS Fusion</h2>

      <label class="bg-orange-500 text-white rounded cursor-pointer hover:bg-orange-600 inline-flex items-center justify-center font-medium" 
        style="position:absolute; right:0; width: 40px; height: 32px;">
        ${icons.upload(16)}
        <button id="file-input" class="hidden">Select ZIP</button>
      </label>
      
    </div>
  </div>`;

switch(currentView) {
case VIEW.LOADING:
  const progressBarHtml = state.loadingProgressPercent > 0 
    ? `<div style="width: 300px; background: #e5e7eb; border-radius: 8px; height: 12px; margin: 1rem auto; overflow: hidden;">
         <div style="width: ${state.loadingProgressPercent}%; height: 100%; background: linear-gradient(90deg,#60a5fa,#3b82f6); border-radius: 8px; transition: width 200ms ease;"></div>
       </div>
       <p class="text-sm text-gray-500">${state.loadingProgressPercent}%</p>`
    : '';
  
  const dbModeIndicator = state.loadingStep && state.loadingStep.includes('cache dysku')
    ? '<p class="text-sm text-blue-600 font-semibold mt-2">💾 Używam cache dysku (feed &gt; 12M wierszy)</p>'
    : '';
  
  html += `<div class="flex-1 flex flex-col items-center justify-center bg-gray-50">
    <div class="text-center">
      <p class="text-gray-600 font-medium">${state.loadingStep || 'Przetwarzanie'}</p>
      ${progressBarHtml}
      ${dbModeIndicator}
      <div style="margin-top:1rem;">
        <button id="cancel-parse" class="bg-red-500 text-white px-3 py-1 hover:bg-red-600">Anuluj</button>
      </div>
    </div>
  </div>`;
  break;
    
  case VIEW.ERROR:
    html += `<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 m-4 rounded">${state.error}</div>`;
    break;
    
  case VIEW.UPLOAD:
    html += `<div class="flex-1 flex items-center justify-center">
    <div style="display: flex; flex-direction: column; align-items: center; gap: 1rem;">
      <label class="bg-orange-500 text-white px-6 py-3 rounded-lg cursor-pointer hover:bg-orange-600 inline-flex items-center gap-2 text-lg font-medium">
        Załaduj GTFS
        <button id="file-input" class="hidden">Select ZIP</button>
      </label>
    </div>
  </div>`;
    break;
    
  case VIEW.STOP_DETAIL:
    const stop = state.selectedStop;
    
    const allStopIds = stop.stopIds || [stop.stop_id];
    
    const activeServices = getServicesForDate(state.selectedDate);
    const departures = [];
    const routesAtStop = new Map();
    
    state.gtfsData.routes.forEach(route => {
      const trips = state.gtfsData.tripsIndex[route.route_id] || [];
      trips.forEach(trip => {
        if (!activeServices.includes(trip.service_id)) return;
        const stopTimes = getStopTimesIndexOrCache()[trip.trip_id] || [];
        const stopTime = stopTimes.find(st => st.stop_id === stop.stop_id);
        if (stopTime) {
          const departureTime = stopTime.departure_time || stopTime.arrival_time;
          if (departureTime) {
            departures.push({
              route: route,
              trip: trip,
              time: departureTime,
              timeMinutes: Utils.timeToMinutes(departureTime),
              headsign: trip.trip_headsign || ''
            });
            if (!routesAtStop.has(route.route_id)) routesAtStop.set(route.route_id, route);
          }
        }
      });
    });
    
    departures.sort((a, b) => a.timeMinutes - b.timeMinutes);
    
    // Store departures in state for dynamic filtering
    state.stopDetailDepartures = departures;
    
    let filteredDepartures = departures;
    if (state.stopViewFilteredRoutes.length > 0) {
      filteredDepartures = departures.filter(d => state.stopViewFilteredRoutes.includes(d.route.route_id));
    }
    
    const routesArray = Array.from(routesAtStop.values());
    routesArray.sort((a, b) => {
      const na = String(a.route_short_name || a.route_id || '');
      const nb = String(b.route_short_name || b.route_id || '');
      return na.localeCompare(nb, undefined, { numeric: true, sensitivity: 'base' });
    });
    
    html += `<div class="flex-1 overflow-auto p-6">
  <div class="max-w-6xl mx-auto">
    <div class="bg-white shadow-sm p-4">
      <!-- Nagłówek -->
      <div class="header-row">
        <div class="header-left">
          <h2 class="text-2xl font-bold" style="margin:0;">${Utils.escapeHtml(stop.stop_name)}</h2>
        </div>
        <div class="title-controls">
          ${state.availableDates.length ? `<select id="date-select-stop" class="border rounded px-3 py-2 text-sm">${state.availableDates.map(d => `<option value="${Utils.escapeHtml(String(d.value))}" ${String(d.value) === String(state.selectedDate) ? 'selected' : ''}>${Utils.escapeHtml(d.label)}</option>`).join('')}</select>` : ''}
        </div>
      </div>
      <!-- Filtry -->
      <div style="margin-top:12px;">
        <div style="display:grid; grid-template-columns: repeat(16, 1fr); gap:8px;">
          <button id="filter-all-routes" class="px-2 py-1 rounded border border-black text-xs font-semibold ${state.stopViewFilteredRoutes.length === 0 ? 'bg-blue-500 text-white' : 'bg-white hover:bg-gray-50'}" style="min-height:50px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
            <span>Wszystkie</span>
            <span>(${departures.length})</span>
          </button>
          ${(() => {
            const buttons = [];
            const slotsPerRow = 16;
            for (let i = 0; i < routesArray.length; i++) {
              const route = routesArray[i];
              const isSelected = state.stopViewFilteredRoutes.includes(route.route_id);
              const meta = getRouteTypeMeta(route.route_type);
              const count = departures.filter(d => d.route.route_id === route.route_id).length;
              buttons.push(`<button class="route-filter-btn px-2 py-1 rounded border border-black text-xs font-semibold ${isSelected ? 'bg-blue-500 text-white' : 'bg-white hover:bg-gray-50'}" data-route-id="${Utils.escapeHtml(route.route_id)}" style="border-left: 4px solid ${meta.color}; min-height:50px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <span>${Utils.escapeHtml(route.route_short_name || route.route_id)}</span>
                <span>(${count})</span>
              </button>`);
            }
            const totalSlots = Math.ceil((routesArray.length + 1) / slotsPerRow) * slotsPerRow;
            const emptySlots = totalSlots - (routesArray.length + 1);
            for (let i = 0; i < emptySlots; i++) {
              buttons.push(`<div class="px-2 py-1 rounded border border-gray-300 bg-gray-100" style="min-height:50px;"></div>`);
            }
            return buttons.join('');
          })()}
        </div>
      </div>
      
<!-- Mapa i tabela -->
      <div style="margin-top:12px; display:grid; grid-template-columns: repeat(16, 1fr); gap:8px;">
        <!-- Tabela zajmuje 6 kolumn -->
        <div style="grid-column: 1 / 7;">
          <div id="stop-detail-departures-table" style="height:500px; overflow-y:auto;">
            ${filteredDepartures.length === 0 ? '<div class="text-gray-700 p-4">No departures found</div>' : `
<table
  class="text-sm border w-full"
  style="border-collapse: collapse; table-layout: fixed;"
>
  <colgroup>
    <col style="width:4.5em">
    <col style="width:max-content">
    <col style="width:100%">
  </colgroup>

  <thead class="bg-gray-50 sticky top-0 z-10">
    <tr>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Czas
      </th>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Linia
      </th>
      <th class="text-left p-3 font-semibold border">
        Kierunek
      </th>
    </tr>
  </thead>

  <tbody>
    ${filteredDepartures.map(dep => {
      const meta = getRouteTypeMeta(dep.route.route_type);

      return `
        <tr class="border-b hover:bg-gray-50">
          <td class="p-1 font-bold border whitespace-nowrap text-center">
            ${Utils.formatTime(dep.time)}
          </td>

          <!-- ROUTE: NIE ROZCIĄGA SIĘ -->
<td class="p-1 border whitespace-nowrap">
  <div class="flex justify-center">
    ${routeBadgeHtml(dep.route, meta)}
  </div>
</td>

          <!-- DESTINATION: BIERZE RESZTĘ -->
          <td class="p-1 border break-words">
            ${Utils.escapeHtml(getTripDestination(dep))}
          </td>
        </tr>
      `;
    }).join("")}
  </tbody>
</table>
`}
          </div>
        </div>
        
<!-- Mapa zaczyna się od środka między 6. a 7. kolumną (6.5) i idzie do końca -->
        <div style="grid-column: 7 / 17;">
          <div class="bg-white shadow-sm" style="height:500px; margin-left:-4px; position:relative;">
            <div id="stop-detail-map" style="width:100%; height:100%; overflow:hidden;"></div>
          </div>
        </div>
</div>`;
    break;

  case VIEW.STOPS_LIST:
    // ========== WIDOK PRZYSTANKÓW ==========
    html += `<div class="flex-1 overflow-auto p-6">
    <div class="max-w-6xl mx-auto">
      <div class="routes-header">
        <div style="display:flex; align-items:center; gap:1rem;">
          <h2 class="text-2xl font-bold" style="margin:0;">Zobacz:</h2>
          <select id="view-mode-select-stops" class="border rounded px-3 py-2 text-base font-semibold">
            <option value="routes">linie</option>
            <option value="stops" selected>przystanki</option>
          </select>
        </div>
      </div>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
        <div class="bg-white shadow-sm" style="max-height: 600px; display: flex; flex-direction: column;">
          <div style="position: sticky; top: 0; z-index: 10; background: white; padding: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #e5e7eb;">
            <input 
              type="text" 
              id="stops-search-input-header"
              placeholder="search" 
              class="border rounded px-3 py-2 text-sm"
              style="width: 100%;"
            />
          </div>
          <div style="flex: 1; overflow-y: auto; padding: 1rem; padding-top: 0.5rem;">
            <div id="stops-list"></div>
          </div>
        </div>
        <div class="bg-white shadow-sm">
          <div id="stops-map" style="width:100%; height:600px;"></div>
        </div>
      </div>
    </div>
  </div>`;
    break;

  case VIEW.ROUTES_LIST:
    // ========== WIDOK TRAS ==========
    html += `<div id="routes-list-container" class="flex-1 overflow-auto p-6"><div class="max-w-6xl mx-auto">
    <div class="routes-header">
      <div style="display:flex; align-items:center; gap:1rem;">
        <h2 class="text-2xl font-bold" style="margin:0;">Zobacz:</h2>
        <select id="view-mode-select" class="border rounded px-3 py-2 text-base font-semibold">
          <option value="routes" selected>linie</option>
          <option value="stops">przystanki</option>
        </select>
      </div>
      <div style="position:relative;">
        <button id="routes-options-btn" class="border rounded px-3 py-2 text-sm">Opcje ▾</button>
        <div id="routes-options" class="routes-options" style="display:none;">
          <label style="display:flex;align-items:center;gap:8px;"><span style="font-size:13px;">Grupuj według</span>
<select id="route-group-select" class="border rounded px-2 py-1 text-sm" style="margin-left:8px;">
<option value="logical" ${state.routeGroupMode==='logical'?'selected':''}>Zgrupowane linie</option>
<option value="service_type" ${state.routeGroupMode==='service_type'?'selected':''}>Środka transportu</option>
<option value="agency" ${state.routeGroupMode==='agency'?'selected':''}>Przewoźnika</option>
<option value="raw_routes" ${state.routeGroupMode==='raw_routes'?'selected':''}>route_id</option>
</select>
          </label>
        </div>
      </div>
    </div>
    <div id="routes-container" class="mb-8"><div id="routes-tbody"></div></div>
  </div></div>`;
    break;

  case VIEW.ROUTE_TIMETABLE:
    // ========== WIDOK LINII z rozkładem ==========
    const directions = getAvailableDirections();
    const dirA = Array.isArray(directions) && directions.length >= 1 ? directions[0] : null;
    const dirB = Array.isArray(directions) && directions.length >= 2 ? directions[1] : null;
    const displayA = dirA ? (dirA.fullName || dirA.name || '') : '';
    const displayB = dirB ? (dirB.fullName || dirB.name || '') : '';
    const combinedAB = (displayA && displayB) ? `${displayA} → ${displayB}` : (displayA || displayB || '');
    
    const shortName = String(state.selectedRoute.route_short_name || '').trim();
    const longName = String(state.selectedRoute.route_long_name || '').trim();
    
    let routeTitleRaw = '';
    // Priority: 1. Clean directions from getAvailableDirections (if both available)
    //           2. Fallback to route_long_name if directions not available
    if (combinedAB) {
      routeTitleRaw = combinedAB;
    } else if (longName) {
      routeTitleRaw = longName;
    } else {
      const selDir = Array.isArray(directions) && directions.length
        ? (directions.find(d => String(d.id) === String(state.selectedDirection)) || directions[0])
        : null;
      routeTitleRaw = selDir ? (selDir.fullName || selDir.name || '') : (state.selectedRoute.route_id || '');
    }
    if (shortName && routeTitleRaw) {
      routeTitleRaw = shortName + ' ' + routeTitleRaw;
    }
    if (shortName) {
      const escaped = shortName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const doubleRe = new RegExp('^' + escaped + '\\s+' + escaped + '(?:\\s|$)');
      if (doubleRe.test(routeTitleRaw)) {
        routeTitleRaw = routeTitleRaw.replace(new RegExp('^' + escaped + '\\s*'), '');
      }
    }
    const routeTitle = Utils.escapeHtml(routeTitleRaw);
    let titleWithoutShort = routeTitleRaw || '';
    if (shortName) {
      const escapedShortForRe = shortName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      titleWithoutShort = titleWithoutShort.replace(new RegExp('^' + escapedShortForRe + '\\s*'), '');
    }
    const shortEsc = Utils.escapeHtml(shortName);
    const titleEsc = Utils.escapeHtml(titleWithoutShort || routeTitleRaw || '');
    
    html += `<div class="flex-1 overflow-auto">
  <div class="max-w-6xl mx-auto">
    <div class="bg-white border-b p-4" style="box-sizing:border-box;">
      <div class="header-row" style="display:flex;align-items:center;gap:0.5rem;">
        <div class="header-left" style="min-width:0; display:flex; align-items:center; gap:0.5rem; flex:0 1 auto;">
          <h2 class="text-2xl font-bold" title="${Utils.escapeHtml(routeTitleRaw)}" style="margin:0; display:flex; align-items:center;">
            <span class="header-with-badge">` +
              (shortName ? `<span class="route-badge">${shortEsc}</span>` : '') +
              `<span class="route-title" title="${Utils.escapeHtml(routeTitleRaw)}">${titleEsc}</span>
            </span>
          </h2>
        </div>

        <div class="title-controls" style="margin-left:auto;display:flex;align-items:center;gap:0.5rem;flex:0 0 auto;">
          ${directions.length>1 ? `<select id="direction-select" style="max-width:160px;display:inline-block;" class="border rounded px-3 py-2 text-sm">${directions.map(dir => `<option value="${Utils.escapeHtml(String(dir.id))}" ${String(state.selectedDirection) === String(dir.id) ? 'selected' : ''}>${Utils.escapeHtml(dir.name)}</option>`).join('')}</select>` : ''}
          ${ (state.availableDates || []).length ? `<select id="date-select" style="width:auto;min-width:160px;display:inline-block;" class="border rounded px-3 py-2 text-sm">${(state.availableDates||[]).map(d => `<option value="${Utils.escapeHtml(String(d.value))}" ${String(d.value) === String(state.selectedDate) ? 'selected' : ''}>${Utils.escapeHtml(d.label)}</option>`).join('')}</select>` : '' }
        </div>
      </div>

      <div style="margin-top:12px;">
        <div id="map-container" style="width:100%; height:420px; box-sizing:border-box; border-radius:6px; overflow:hidden; background:#fff;"></div>
        <div id="timetable-container" class="mt-4 mb-0"></div>
      </div>
    </div>
  </div>
</div>`;
    break;
}
      
      html += `</div>`;
      root.innerHTML = html;

      $('cancel-parse')?.addEventListener('click', cancelParsing);
      
      const routesOptionsBtn = $('routes-options-btn');
      const routesOptions = $('routes-options');
      if (routesOptionsBtn && routesOptions) {
        routesOptionsBtn.addEventListener('click', (e) => {
          state.routesOptionsOpen = !state.routesOptionsOpen;
          routesOptions.style.display = state.routesOptionsOpen ? 'block' : 'none';
        });
        if (!state.routesOptionsListenerAttached) {
          document.addEventListener('click', (ev) => {
            try {
              if (!$('routes-options')) return;
              const ro = $('routes-options');
              const btn = $('routes-options-btn');
              if (!ro || !btn) return;
              if (!ro.contains(ev.target) && ev.target !== btn) {
                state.routesOptionsOpen = false;
                ro.style.display = 'none';
              }
            } catch(e){}
          });
          state.routesOptionsListenerAttached = true;
        }
      }
      $('route-group-select')?.addEventListener('change', (e) => { state.routeGroupMode = e.target.value || 'route_id'; renderRouteTable(); });
      
      ['view-mode-select', 'view-mode-select-stops'].forEach(id => {
        $(id)?.addEventListener('change', (e) => {
          state.showStopsView = (e.target.value === 'stops');
          render();
        });
      });
      
      $('back-button')?.addEventListener('click', () => {
    if (state.selectedStop) {
      // Powrót ze STOP_DETAIL do STOPS_LIST
      // Restore expanded group if we had one
      if (state.stopsListMapState && state.stopsListMapState.expandedGroup) {
        state.expandedStopGroup = state.stopsListMapState.expandedGroup;
      }
      // FIX #3: Reset map state when leaving STOP_DETAIL
      state.stopDetailMapInitialized = false;
      state.stopDetailMapLayers = {};
      if (state.stopDetailMapInstance) {
        try {
          state.stopDetailMapInstance.remove();
        } catch(e) {}
        state.stopDetailMapInstance = null;
      }
      state.selectedStop = null;
      state.stopViewFilteredRoutes = [];
    } else if (state.selectedRoute) {
      // Powrót z ROUTE_TIMETABLE do ROUTES_LIST
      state.selectedRoute = null;
      resetMap();
    } else if (state.showStopsView) {
      // Powrót ze STOPS_LIST do ROUTES_LIST
      state.showStopsView = false;
      state.expandedStopGroup = null;
      state.stopsListMapState = null;
      state.stopsListSearchQuery = '';
      state.routesListScrollPosition = 0; // Reset scroll position
      resetMap();
    } else if (!state.showStopsView) {
      // Powrót z ROUTES_LIST do STOPS_LIST
      state.showStopsView = true;
      state.routesListScrollPosition = 0; // Reset scroll position
      resetMap();
    }
    render(); 
  });

const filterAllBtn = document.getElementById('filter-all-routes');
if (filterAllBtn) {
  const oldHandler = filterAllBtn._filterHandler;
  if (oldHandler) filterAllBtn.removeEventListener('click', oldHandler);
  const newHandler = () => {
    state.stopViewFilteredRoutes = [];
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
    updateRouteFilterButtons();
    updateDeparturesTable();
  };
  filterAllBtn._filterHandler = newHandler;
  filterAllBtn.addEventListener('click', newHandler);
}
document.querySelectorAll('.route-filter-btn').forEach(btn => {
  const oldHandler = btn._filterHandler;
  if (oldHandler) btn.removeEventListener('click', oldHandler);
  const newHandler = () => {
    const routeId = btn.getAttribute('data-route-id');
    const idx = state.stopViewFilteredRoutes.indexOf(routeId);
    if (idx > -1) {
      state.stopViewFilteredRoutes.splice(idx, 1);
    } else {
      state.stopViewFilteredRoutes.push(routeId);
    }
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
    updateRouteFilterButtons();
    updateDeparturesTable();
  };
  btn._filterHandler = newHandler;
  btn.addEventListener('click', newHandler);
});
// -- KONIEC BLOKU obsługi kliknięć --		

// WARNING: Do not duplicate these event listeners - they should only be registered once
// to avoid multiple callbacks firing on each change
$('direction-select')?.addEventListener('change', async (e) => {
    const newDirection = String(e.target.value);
    if (newDirection === state.selectedDirection) return; // Avoid redundant updates
    state.selectedDirection = newDirection;
    // Invalidate canonical cache when direction changes
    invalidateCanonicalCacheForCurrentSelection();
    resetMap();
    render();
  });

$('date-select')?.addEventListener('change', async (e) => {
    state.selectedDate = String(e.target.value);
    resetMap();
    render();
  });

if (state.gtfsData && !state.selectedRoute && !state.showStopsView) {
  renderRouteTable();
  // Restore scroll position after rendering routes list
  if (state.routesListScrollPosition !== undefined && state.routesListScrollPosition > 0) {
    setTimeout(() => {
      const container = document.querySelector('#routes-list-container');
      if (container) {
        container.scrollTop = state.routesListScrollPosition;
      }
    }, 50);
  }
}
if (state.gtfsData && !state.selectedRoute && state.showStopsView && state.selectedStop) {
  // Renderuj mapę z trasami linii - only once on first load
  setTimeout(async () => {
    await renderStopDetailMap(state.selectedStop.stop_id, state.selectedDate, state.stopViewFilteredRoutes);
    // FIX #3: Apply initial filter after map is initialized
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
  }, 50);
  
// replace the stop-detail date-select handler with this (if present in your file)
$('date-select-stop')?.addEventListener('change', async (e) => {
  state.selectedDate = String(e.target.value);
  state.stopDetailDepartures = [];
  
  // FIX #4: Update layers without restarting map
  if (state.stopDetailMapInstance && state.stopDetailMapInitialized) {
    const map = state.stopDetailMapInstance;
    const stopId = state.selectedStop.stop_id;
    
    // Remove old layers
    Object.values(state.stopDetailMapLayers).forEach(layer => {
      map.removeLayer(layer);
    });
    state.stopDetailMapLayers = {};
    
    const result = collectRoutesForStop(stopId, state.selectedDate, []);
    
    const routesData = result.routes || [];
    
    // Recreate layers
    for (const routeData of routesData) {
      const { route, stops, color, direction, shapeId } = routeData;
      const layerKey = `${route.route_id}_${direction}`;
      
      const layer = window.L.featureGroup();
      
      const mainRouteStops = stops.filter(s => s.type === 'core' || s.type === 'branch');
      
      if (mainRouteStops.length > 1) {
        let lineGeometry = null;
        
        if (shapeId && state.gtfsData.shapesIndex && state.gtfsData.shapesIndex[shapeId]) {
          lineGeometry = getSimplifiedShape(shapeId);
        }
        
        if (!lineGeometry) {
          try {
            lineGeometry = await generateLineGeometry(mainRouteStops, route.route_type);
          } catch (err) {
            // Ignore geometry generation errors - fallback to straight lines between stops
          }
        }
        
        if (!lineGeometry || lineGeometry.length < 2) {
          lineGeometry = mainRouteStops.map(s => [s.lat, s.lon]).filter(([lat, lon]) => !isNaN(lat) && !isNaN(lon));
        }
        
        if (Array.isArray(lineGeometry) && lineGeometry.length > 1) {
          window.L.polyline(lineGeometry, {
            color: color,
            weight: 3,
            opacity: 0.7,
            smoothFactor: 0.5
          }).addTo(layer);
        }
      }
      
      mainRouteStops.forEach(s => {
        if (!s || isNaN(parseFloat(s.lat)) || isNaN(parseFloat(s.lon))) return;
        const sLat = parseFloat(s.lat);
        const sLon = parseFloat(s.lon);
        window.L.marker([sLat, sLon], {
          icon: createSvgIcon(color)
        }).addTo(layer).bindPopup(s.name);
      });
      
      state.stopDetailMapLayers[layerKey] = layer;
      layer.addTo(map);
    }
    
    // Apply current filter
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
  }
  
  const activeServices = getServicesForDate(state.selectedDate);
  const departures = [];
  const routesAtStop = new Map();
  
  state.gtfsData.routes.forEach(route => {
    const trips = state.gtfsData.tripsIndex[route.route_id] || [];
    trips.forEach(trip => {
      if (!activeServices.includes(trip.service_id)) return;
      const stopTimes = getStopTimesIndexOrCache()[trip.trip_id] || [];
      const stopTime = stopTimes.find(st => st.stop_id === state.selectedStop.stop_id);
      if (stopTime) {
        const departureTime = stopTime.departure_time || stopTime.arrival_time;
        if (departureTime) {
          departures.push({
            route: route,
            trip: trip,
            time: departureTime,
            timeMinutes: Utils.timeToMinutes(departureTime),
            headsign: trip.trip_headsign || ''
          });
          if (!routesAtStop.has(route.route_id)) routesAtStop.set(route.route_id, route);
        }
      }
    });
  });
  
  departures.sort((a, b) => a.timeMinutes - b.timeMinutes);
  state.stopDetailDepartures = departures;
  
  // Update UI
  updateDeparturesTable();
  updateRouteFilterButtons();
});

}
if (state.gtfsData && !state.selectedRoute && state.showStopsView && !state.selectedStop) renderStopsView();
if (state.gtfsData && state.selectedRoute) { 
  try {
    renderTimetable(); 
  } catch (err) {
    console.error('renderTimetable error:', err);
  }
  updateMap().catch(() => {
    // Ignore map update errors - map functionality is non-critical for timetable display
  }); 
}
}

    function render(force = false) {
      const now = Date.now();
      
      // During loading, throttle renders to avoid excessive DOM updates
      if (state.loading && !force) {
        if (now - lastRenderTime < RENDER_THROTTLE_MS) {
          return; // Skip render if called too soon
        }
      }
      
      lastRenderTime = now;
      renderImmediate();
    }

// ═══════════════════════════════════════════════════════════════
// GLOBAL EVENT DELEGATION (run once on page load)
// ═══════════════════════════════════════════════════════════════

(function initGlobalHandlers() {
  console.log('[Init] Setting up global event handlers...');
  
  // Upload handler - delegacja na document (działa dla wszystkich upload buttonów)
  document.addEventListener('click', async (e) => {
    // Znajdź najbliższy label z upload ikoną
    const uploadLabel = e.target.closest('label');
    
    if (!uploadLabel) return;
    
    // Sprawdź czy to upload button (ma SVG lub file-input dziecko)
    const hasUploadSVG = uploadLabel.innerHTML.includes('<svg') && 
                         uploadLabel.innerHTML.includes('path');
    const hasFileInput = uploadLabel.querySelector('#file-input');
    
    if (hasUploadSVG || hasFileInput) {
      console.log('[Upload] Upload button clicked');
      e.preventDefault();
      e.stopPropagation();
      
      // Wywołaj handler
      if (typeof handleFileUpload === 'function') {
        await handleFileUpload();
      } else {
        console.error('[Upload] handleFileUpload function not found!');
      }
    }
  });
  
  console.log('[Init] Global handlers ready');
})();

    // initial render
    render();
	
document.querySelector('label[for="file-input"]')?.addEventListener('click', async (e) => {
  e.preventDefault();
  await handleFileUpload();
});
  </script>
</body>
</html>
