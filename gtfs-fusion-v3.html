<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GTFS Fusion</title>
  <script>
    // Define exports for fflate UMD compatibility
    if (typeof exports === 'undefined') {
      var exports = {};
    }
  </script>
  <script src="https://unpkg.com/fflate@0.8.1/umd/index.js"></script>
  <script>
    // Expose fflate globally from exports
    if (typeof exports !== 'undefined' && exports.unzip) {
      window.fflate = exports;
    }
  </script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  <style>
    body { margin:0; font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }
    #root { height:100vh; }
    .custom-svg-icon { background: none !important; border: none !important; }
    .routes-header{ display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; }
    .routes-grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(96px, 1fr)); gap:12px; }
    .route-card{ display:flex; align-items:center; justify-content:center; height:48px; background:#eff6ff; border:1px solid #e6eefb; color:#0f172a; font-weight:600; border-radius:6px; cursor:pointer; transition:background .12s, transform .06s; gap:8px; padding:0 8px; text-align:center; }
    .route-card:hover{ background:#e0f2fe; transform:translateY(-1px); }
    .agency-group{ margin-bottom:28px; }
    .agency-title{ font-weight:700; margin:12px 0 8px; color:#334155; }
    .progress-bar { height:12px; background:linear-gradient(90deg,#60a5fa,#3b82f6); border-radius:8px; transition:width 200ms ease; }
.progress-badge {
  position: absolute;
  top: -26px;
  right: 0;
  background: linear-gradient(135deg, #3b82f6, #2563eb);
  color: white;
  padding: 3px 10px;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 700;
  box-shadow: 0 2px 6px rgba(59, 130, 246, 0.3);
  letter-spacing: 0.5px;
}
@keyframes slow-blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}
.route-title {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
  word-break: break-word;
  white-space: normal;
  font-size: 1.125rem; /* ~18px — dopasuj jeśli chcesz mniejszy/wiekszy */
  line-height: 1.15;
  max-height: calc(1.15em * 2);
  min-width: 0;        /* bardzo ważne w flex-context */
  flex: 1 1 auto;
}
/* wklej do <style> (np. po .route-card-title) */
.route-badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: 2px solid #111;       /* czarna ramka */
  background: #fff;             /* biały środek */
  color: #111;
  font-weight: 900;
  font-size: 1.25rem;
  min-width: 48px;
  height: 40px;
  padding: 0 0.5rem;
  border-radius: 6px;
  margin-right: 0.75rem;
  box-sizing: border-box;
  line-height: 1;
}
/* badge + title: inline-flex, nie zawija się wewnętrznie; title może się kurczyć */
.header-with-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  flex-wrap: nowrap;
  min-width: 0;
}
	.routes-options { position: absolute; right: 4px; top: calc(100% + 6px); background: white; border: 1px solid #e5e7eb; padding: 8px; border-radius: 6px; box-shadow: 0 6px 18px rgba(15,23,42,0.08); z-index: 30; }
 /* kontener nagłówka - musi być relative, żeby controls absolute działało względem niego */
.header-row {
  position: relative;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

/* lewa część (badge + title) */
.header-left {
  min-width: 0;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  /* pozwól lewemu blokowi rozszerzać się tylko do dostępnego miejsca */
  flex: 0 1 auto;
}

/* prawy kontener: absolutnie przytwierdzony do prawej */
.title-controls {
  position: absolute;
  right: 0px;              /* dostosuj odsunięcie od prawej krawędzi kontenera */
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  align-items: center;
  gap: 0.5rem;
  white-space: nowrap;
  z-index: 2;
}

/* upewnij się, że selecty nie rozciągają się na 100% */
.title-controls > select {
  width: auto !important;
  display: inline-block;
  min-width: 160px; /* dopasuj szerokość */
}
*,
::before,
::after {
  --tw-border-spacing-x:0;
  --tw-border-spacing-y:0;
  --tw-translate-x:0;
  --tw-translate-y:0;
  --tw-rotate:0;
  --tw-skew-x:0;
  --tw-skew-y:0;
  --tw-scale-x:1;
  --tw-scale-y:1;
  --tw-pan-x: ;
  --tw-pan-y: ;
  --tw-pinch-zoom: ;
  --tw-scroll-snap-strictness:proximity;
  --tw-gradient-from-position: ;
  --tw-gradient-via-position: ;
  --tw-gradient-to-position: ;
  --tw-ordinal: ;
  --tw-slashed-zero: ;
  --tw-numeric-figure: ;
  --tw-numeric-spacing: ;
  --tw-numeric-fraction: ;
  --tw-ring-inset: ;
  --tw-ring-offset-width:0px;
  --tw-ring-offset-color:#fff;
  --tw-ring-color:rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow:0 0 #0000;
  --tw-ring-shadow:0 0 #0000;
  --tw-shadow:0 0 #0000;
  --tw-shadow-colored:0 0 #0000;
  --tw-blur: ;
  --tw-brightness: ;
  --tw-contrast: ;
  --tw-grayscale: ;
  --tw-hue-rotate: ;
  --tw-invert: ;
  --tw-saturate: ;
  --tw-sepia: ;
  --tw-drop-shadow: ;
  --tw-backdrop-blur: ;
  --tw-backdrop-brightness: ;
  --tw-backdrop-contrast: ;
  --tw-backdrop-grayscale: ;
  --tw-backdrop-hue-rotate: ;
  --tw-backdrop-invert: ;
  --tw-backdrop-opacity: ;
  --tw-backdrop-saturate: ;
  --tw-backdrop-sepia: ;
  --tw-contain-size: ;
  --tw-contain-layout: ;
  --tw-contain-paint: ;
  --tw-contain-style: 
}
::backdrop {
  --tw-border-spacing-x:0;
  --tw-border-spacing-y:0;
  --tw-translate-x:0;
  --tw-translate-y:0;
  --tw-rotate:0;
  --tw-skew-x:0;
  --tw-skew-y:0;
  --tw-scale-x:1;
  --tw-scale-y:1;
  --tw-pan-x: ;
  --tw-pan-y: ;
  --tw-pinch-zoom: ;
  --tw-scroll-snap-strictness:proximity;
  --tw-gradient-from-position: ;
  --tw-gradient-via-position: ;
  --tw-gradient-to-position: ;
  --tw-ordinal: ;
  --tw-slashed-zero: ;
  --tw-numeric-figure: ;
  --tw-numeric-spacing: ;
  --tw-numeric-fraction: ;
  --tw-ring-inset: ;
  --tw-ring-offset-width:0px;
  --tw-ring-offset-color:#fff;
  --tw-ring-color:rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow:0 0 #0000;
  --tw-ring-shadow:0 0 #0000;
  --tw-shadow:0 0 #0000;
  --tw-shadow-colored:0 0 #0000;
  --tw-blur: ;
  --tw-brightness: ;
  --tw-contrast: ;
  --tw-grayscale: ;
  --tw-hue-rotate: ;
  --tw-invert: ;
  --tw-saturate: ;
  --tw-sepia: ;
  --tw-drop-shadow: ;
  --tw-backdrop-blur: ;
  --tw-backdrop-brightness: ;
  --tw-backdrop-contrast: ;
  --tw-backdrop-grayscale: ;
  --tw-backdrop-hue-rotate: ;
  --tw-backdrop-invert: ;
  --tw-backdrop-opacity: ;
  --tw-backdrop-saturate: ;
  --tw-backdrop-sepia: ;
  --tw-contain-size: ;
  --tw-contain-layout: ;
  --tw-contain-paint: ;
  --tw-contain-style: 
}
/* ! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com */*,
::after,
::before {
  box-sizing:border-box;
  border-width:0;
  border-style:solid;
  border-color:#e5e7eb
}
::after,
::before {
  --tw-content:''
}
:host,
html {
  line-height:1.5;
  -webkit-text-size-adjust:100%;
  -moz-tab-size:4;
  tab-size:4;
  font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  font-feature-settings:normal;
  font-variation-settings:normal;
  -webkit-tap-highlight-color:transparent
}
body {
  margin:0;
  line-height:inherit
}
hr {
  height:0;
  color:inherit;
  border-top-width:1px
}
abbr:where([title]) {
  -webkit-text-decoration:underline dotted;
  text-decoration:underline dotted
}
h1,
h2,
h3,
h4,
h5,
h6 {
  font-size:inherit;
  font-weight:inherit
}
a {
  color:inherit;
  text-decoration:inherit
}
b,
strong {
  font-weight:bolder
}
code,
kbd,
pre,
samp {
  font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-feature-settings:normal;
  font-variation-settings:normal;
  font-size:1em
}
small {
  font-size:80%
}
sub,
sup {
  font-size:75%;
  line-height:0;
  position:relative;
  vertical-align:baseline
}
sub {
  bottom:-.25em
}
sup {
  top:-.5em
}
table {
  text-indent:0;
  border-color:inherit;
  border-collapse:collapse
}
button,
input,
optgroup,
select,
textarea {
  font-family:inherit;
  font-feature-settings:inherit;
  font-variation-settings:inherit;
  font-size:100%;
  font-weight:inherit;
  line-height:inherit;
  letter-spacing:inherit;
  color:inherit;
  margin:0;
  padding:0
}
button,
select {
  text-transform:none
}
button,
input:where([type=button]),
input:where([type=reset]),
input:where([type=submit]) {
  -webkit-appearance:button;
  background-color:transparent;
  background-image:none
}
:-moz-focusring {
  outline:auto
}
:-moz-ui-invalid {
  box-shadow:none
}
progress {
  vertical-align:baseline
}
::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height:auto
}
[type=search] {
  -webkit-appearance:textfield;
  outline-offset:-2px
}
::-webkit-search-decoration {
  -webkit-appearance:none
}
::-webkit-file-upload-button {
  -webkit-appearance:button;
  font:inherit
}
summary {
  display:list-item
}
blockquote,
dd,
dl,
figure,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
p,
pre {
  margin:0
}
fieldset {
  margin:0;
  padding:0
}
legend {
  padding:0
}
menu,
ol,
ul {
  list-style:none;
  margin:0;
  padding:0
}
dialog {
  padding:0
}
textarea {
  resize:vertical
}
input::placeholder,
textarea::placeholder {
  opacity:1;
  color:#9ca3af
}
[role=button],
button {
  cursor:pointer
}
:disabled {
  cursor:default
}
audio,
canvas,
embed,
iframe,
img,
object,
svg,
video {
  display:block;
  vertical-align:middle
}
img,
video {
  max-width:100%;
  height:auto
}
[hidden]:where(:not([hidden=until-found])) {
  display:none
}
.sticky {
  position:sticky
}
.left-0 {
  left:0px
}
.top-0 {
  top:0px
}
.z-10 {
  z-index:10
}
.mx-auto {
  margin-left:auto;
  margin-right:auto
}
.mb-4 {
  margin-bottom:1rem
}
.mb-0 {
  margin-bottom:0px
}
.mt-4 {
  margin-top:1rem
}
.flex {
  display:flex
}
.inline-flex {
  display:inline-flex
}
.hidden {
  display:none
}
.h-screen {
  height:100vh
}
.h-12 {
  height:3rem
}
.w-12 {
  width:3rem
}
.max-w-6xl {
  max-width:72rem
}
.flex-1 {
  flex:1 1 0%
}
@keyframes spin {
  to {
    transform:rotate(360deg)
  }
}
.animate-spin {
  animation:spin 1s linear infinite
}
.animate-ellipsis::after {
  content: '...';
  animation: ellipsis-dots 1.5s steps(4, end) infinite;
}
@keyframes ellipsis-dots {
  0%, 25% { content: '.'; }
  26%, 50% { content: '..'; }
  51%, 75% { content: '...'; }
  76%, 100% { content: ''; }
}
.cursor-pointer {
  cursor:pointer
}
.flex-col {
  flex-direction:column
}
.items-center {
  align-items:center
}
.justify-center {
  justify-content:center
}
.gap-4 {
  gap:1rem
}
.overflow-auto {
  overflow:auto
}
.overflow-x-auto {
  overflow-x:auto
}
.whitespace-nowrap {
  white-space:nowrap
}
.border {
  border-width:1px
}
.rounded-lg {
  border-radius:0.5rem
}
.rounded {
  border-radius:0.25rem
}
.rounded-full {
  border-radius:9999px
}
.border-b {
  border-bottom-width:1px
}
.border-b-2 {
  border-bottom-width:2px
}
.border-blue-600 {
  --tw-border-opacity:1;
  border-color:rgb(37 99 235 / var(--tw-border-opacity, 1))
}
.bg-gray-50 {
  --tw-bg-opacity:1;
  background-color:rgb(249 250 251 / var(--tw-bg-opacity, 1))
}
.bg-orange-500 {
  --tw-bg-opacity:1;
  background-color:rgb(249 115 22 / var(--tw-bg-opacity, 1))
}
.bg-white {
  --tw-bg-opacity:1;
  background-color:rgb(255 255 255 / var(--tw-bg-opacity, 1))
}
.bg-red-500 {
  --tw-bg-opacity:1;
  background-color:rgb(239 68 68 / var(--tw-bg-opacity, 1))
}
.bg-blue-500 {
  --tw-bg-opacity:1;
  background-color:rgb(59 130 246 / var(--tw-bg-opacity, 1))
}
.bg-gray-200 {
  --tw-bg-opacity:1;
  background-color:rgb(229 231 235 / var(--tw-bg-opacity, 1))
}
.p-1 {
  padding:0.25rem
}
.p-3 {
  padding:0.75rem
}
.p-4 {
  padding:1rem
}
.px-4 {
  padding-left:1rem;
  padding-right:1rem
}
.px-6 {
  padding-left:1.5rem;
  padding-right:1.5rem
}
.py-3 {
  padding-top:0.75rem;
  padding-bottom:0.75rem
}
.px-3 {
  padding-left:0.75rem;
  padding-right:0.75rem
}
.py-1 {
  padding-top:0.25rem;
  padding-bottom:0.25rem
}
.py-2 {
  padding-top:0.5rem;
  padding-bottom:0.5rem
}
.text-left {
  text-align:left
}
.text-center {
  text-align:center
}
.text-lg {
  font-size:1.125rem;
  line-height:1.75rem
}
.text-xl {
  font-size:1.25rem;
  line-height:1.75rem
}
.text-2xl {
  font-size:1.5rem;
  line-height:2rem
}
.text-sm {
  font-size:13.75px;
  line-height:1.25rem
}
.text-xs {
  font-size:0.75rem;
  line-height:1rem
}
.font-bold {
  font-weight:700
}
.font-medium {
  font-weight:500
}
.font-semibold {
  font-weight:600
}
.text-blue-600 {
  --tw-text-opacity:1;
  color:rgb(37 99 235 / var(--tw-text-opacity, 1))
}
.text-orange-500 {
  --tw-text-opacity:1;
  color:rgb(249 115 22 / var(--tw-text-opacity, 1))
}
.text-white {
  --tw-text-opacity:1;
  color:rgb(255 255 255 / var(--tw-text-opacity, 1))
}
.text-gray-600 {
  --tw-text-opacity:1;
  color:rgb(75 85 99 / var(--tw-text-opacity, 1))
}
.shadow-sm {
  --tw-shadow:0 1px 2px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored:0 1px 2px 0 var(--tw-shadow-color);
  box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
}
.hover\:bg-orange-600:hover {
  --tw-bg-opacity:1;
  background-color:rgb(234 88 12 / var(--tw-bg-opacity, 1))
}
.hover\:bg-red-600:hover {
  --tw-bg-opacity:1;
  background-color:rgb(220 38 38 / var(--tw-bg-opacity, 1))
}
.hover\:bg-blue-50:hover {
  --tw-bg-opacity:1;
  background-color:rgb(239 246 255 / var(--tw-bg-opacity, 1))
}
.hover\:bg-blue-600:hover {
  --tw-bg-opacity:1;
  background-color:rgb(37 99 235 / var(--tw-bg-opacity, 1))
}
.hover\:bg-gray-300:hover {
  --tw-bg-opacity:1;
  background-color:rgb(209 213 219 / var(--tw-bg-opacity, 1))
}
.hover\:bg-gray-50:hover {
  --tw-bg-opacity:1;
  background-color:rgb(249 250 251 / var(--tw-bg-opacity, 1))
}

/* Neutralna kolorystyka clusterów */
.marker-cluster-neutral {
  background-color: rgba(100, 116, 139, 0.6);
}
.marker-cluster-neutral div {
  background-color: rgba(71, 85, 105, 0.8);
  color: white;
}
.marker-cluster-neutral.marker-cluster-small {
  background-color: rgba(148, 163, 184, 0.6);
}
.marker-cluster-neutral.marker-cluster-small div {
  background-color: rgba(100, 116, 139, 0.8);
}

/* FIX #5: Tooltips for timetable departure times */
.time-cell-with-tooltip {
  position: relative;
  cursor: help;
}

.time-cell-with-tooltip .tooltip-content {
  visibility: hidden;
  opacity: 0;
  position: fixed !important;
  z-index: 99999 !important;
  background-color: #1f2937;
  color: #fff;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 12px;
  line-height: 1.4;
  white-space: nowrap;
  pointer-events: none !important;
  transition: opacity 0.2s, visibility 0.2s;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  max-width: 300px;
}

.time-cell-with-tooltip:hover .tooltip-content {
  visibility: visible !important;
  opacity: 1 !important;
}


 </style>
</head>
<body>
  <div id="root"></div>
  <script>
// ═══════════════════════════════════════════════════════════════
// GTFS Fusion - Single Page Application
// ═══════════════════════════════════════════════════════════════
// For architectural documentation, see DOCUMENTATION.md
// For refactoring notes, see REFACTORING.md
// ═══════════════════════════════════════════════════════════════

// ═══════════════════════════════════════════════════════════════
// 1. CONSTANTS & CONFIGURATION
// ═══════════════════════════════════════════════════════════════
const DAY_NAMES = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
const SUNDAY = 0, WEDNESDAY = 3, SATURDAY = 6;
const icons = { upload: (size=24) => `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12" /></svg>` };
    const VIEW = {
      LOADING: 'loading',
      ERROR: 'error',
      UPLOAD: 'upload',
      ROUTES_LIST: 'routes_list',
      STOPS_LIST: 'stops_list',
      STOP_DETAIL: 'stop_detail',
      ROUTE_TIMETABLE: 'route_timetable'
    };

    const KEY_ALIAS = {
      'route id':'route_id','routeid':'route_id','route_id':'route_id','route short name':'route_short_name','route_short_name':'route_short_name',
      'route long name':'route_long_name','route_long_name':'route_long_name','trip id':'trip_id','tripid':'trip_id','trip_id':'trip_id',
      'service id':'service_id','serviceid':'service_id','service_id':'service_id','stop id':'stop_id','stopid':'stop_id','stop_id':'stop_id',
      'stop sequence':'stop_sequence','stop_sequence':'stop_sequence','arrival time':'arrival_time','arrival_time':'arrival_time',
      'departure time':'departure_time','departure_time':'departure_time','pickup type':'pickup_type','pickup_type':'pickup_type',
      'drop off type':'drop_off_type','drop_off_type':'drop_off_type','stop lat':'stop_lat','stop_lat':'stop_lat',
      'stop lon':'stop_lon','stop_lon':'stop_lon','direction id':'direction_id','direction_id':'direction_id',
      'trip headsign':'trip_headsign','trip_headsign':'trip_headsign','start date':'start_date','start_date':'start_date',
      'end date':'end_date','end_date':'end_date','monday':'monday','tuesday':'tuesday','wednesday':'wednesday','thursday':'thursday',
      'friday':'friday','saturday':'saturday','sunday':'sunday','exception type':'exception_type','exception_type':'exception_type','date':'date'
    };

    const ROUTE_TYPE_META_BASIC = {
      0: { label: 'Tram', color: '#f59e0b', weight: 3, iconSvg: 'M6 3v13' },
      1: { label: 'Subway', color: '#ef4444', weight: 3, iconSvg: 'M3 6h18v12H3z' },
      2: { label: 'Rail', color: '#10b981', weight: 3, iconSvg: 'M4 6h16' },
      3: { label: 'Bus', color: '#2563eb', weight: 3, iconSvg: 'M5 6h14v8H5z' },
      4: { label: 'Ferry', color: '#0ea5a4', weight: 3, iconSvg: 'M2 16s3-4 10-4 10 4 10 4' },
      5: { label: 'Cable car', color: '#7c3aed', weight: 3, iconSvg: 'M4 6l8-4 8 4' },
      6: { label: 'Gondola', color: '#06b6d4', weight: 3, iconSvg: 'M4 6c4 0 8-4 12 0' },
      7: { label: 'Funicular', color: '#f97316', weight: 3, iconSvg: 'M3 18h18' },
      11:{ label: 'Trolleybus', color: '#8b5cf6', weight: 3, iconSvg: 'M4 6h16' },
      12:{ label: 'Monorail', color: '#06b6d4', weight: 3, iconSvg: 'M2 12h20' }
    };

    const ROUTE_TYPE_META_EXTENDED = {
100: { label: 'Railway service', color:'#10b981', weight:4 },          // ← ZMIEŃ
101: { label: 'High speed rail service', color:'#10b981', weight:4 },  // ← ZMIEŃ
102: { label: 'Long distance trains', color:'#10b981', weight:4 },     // ← ZMIEŃ
103: { label: 'Inter regional rail service', color:'#10b981', weight:4 }, // ← ZMIEŃ
      104: { label: 'Car transport rail service', color:'#6b7280', weight:3 }, 105: { label: 'Sleeper rail service', color:'#6b7280', weight:3 },
      106: { label: 'Regional rail service', color:'#059669', weight:4 }, 107: { label: 'Tourist railway service', color:'#f59e0b', weight:3 },
      108: { label: 'Rail shuttle (within complex)', color:'#9ca3af', weight:2 }, 109: { label: 'Suburban railway', color:'#059669', weight:4 },
      110: { label: 'Replacement rail service', color:'#9ca3af', weight:3 }, 111: { label: 'Special rail service', color:'#6b7280', weight:3 },
      112: { label: 'Lorry transport rail service', color:'#6b7280', weight:3 },
      113: { label: 'All rail services', color:'#10b981', weight:4 }, 
      114: { label: 'Cross-country rail service', color:'#10b981', weight: 4 }, 115: { label: 'Vehicle transport rail service', color:'#6b7280', weight:3 },
      116: { label: 'Rack and pinion railway', color:'#f97316', weight:3 }, 117: { label: 'Additional rail service', color:'#0b74de', weight:3 },

      200: { label: 'Coach service', color:'#1f2937', weight:3 }, 201: { label: 'International coach service', color:'#374151', weight:3 },
      202: { label: 'National coach service', color:'#374151', weight:3 }, 203: { label: 'Shuttle coach service', color:'#6b7280', weight:3 },
      204: { label: 'Regional coach service', color:'#374151', weight:3 }, 205: { label: 'Special coach service', color:'#6b7280', weight:3 },
      206: { label: 'Sightseeing coach service', color:'#f59e0b', weight:3 }, 207: { label: 'Tourist coach service', color:'#f59e0b', weight:3 },
      208: { label: 'Commuter coach service', color:'#2563eb', weight:3 }, 209: { label: 'All coach services', color:'#1f2937', weight:3 },

      300: { label: 'Suburban railway service', color:'#059669', weight:3 }, 400: { label: 'Urban railway service', color:'#ef4444', weight:3 },
      401: { label: 'Metro service', color:'#ef4444', weight:3 }, 402: { label: 'Underground service', color:'#ef4444', weight:3 },
      403: { label: 'Urban railway service (other)', color:'#ef4444', weight:3 }, 404: { label: 'All urban railway services', color:'#ef4444', weight:3 },
      405: { label: 'Monorail', color:'#7c3aed', weight:3 },

      500: { label: 'Water transport service', color:'#0ea5a4', weight:3 }, 501: { label: 'International car ferry service', color:'#0ea5a4', weight:3 },
      502: { label: 'National car ferry service', color:'#0ea5a4', weight:3 }, 503: { label: 'Regional car ferry service', color:'#0ea5a4', weight:3 },
      504: { label: 'Local car ferry service', color:'#0ea5a4', weight:3 }, 505: { label: 'International passenger ferry service', color:'#0ea5a4', weight:3 },
      506: { label: 'National passenger ferry service', color:'#0ea5a4', weight:3 }, 507: { label: 'Regional passenger ferry service', color:'#0ea5a4', weight:3 },
      508: { label: 'Local passenger ferry service', color:'#0ea5a4', weight:3 }, 509: { label: 'Post boat service', color:'#0ea5a4', weight:3 },
      510: { label: 'Water taxi', color:'#0ea5a4', weight:3 }, 511: { label: 'River bus service', color:'#0ea5a4', weight:3 },
      512: { label: 'Scheduled ferry service', color:'#0ea5a4', weight:3 }, 513: { label: 'Shuttle ferry service', color:'#0ea5a4', weight:3 },
      514: { label: 'All water transport services', color:'#0ea5a4', weight:3 },

      1100: { label: 'Air service', color:'#6b7280', weight:2 }, 1101: { label: 'International air service', color:'#6b7280', weight:2 },
      1102: { label: 'Domestic air service', color:'#6b7280', weight:2 }, 1103: { label: 'Intercontinental air service', color:'#6b7280', weight:2 },
      1104: { label: 'Domestic scheduled air service', color:'#6b7280', weight:2 }, 1105: { label: 'Shuttle air service', color:'#6b7280', weight:2 },
      1106: { label: 'Intercontinental charter air service', color:'#6b7280', weight:2 }, 1107: { label: 'International charter air service', color:'#6b7280', weight:2 },
      1108: { label: 'Round-trip charter air service', color:'#6b7280', weight:2 }, 1109: { label: 'Sightseeing air service', color:'#f59e0b', weight:2 },
      1110: { label: 'Helicopter air service', color:'#6b7280', weight:2 }, 1111: { label: 'Domestic charter air service', color:'#6b7280', weight:2 },
      1112: { label: 'Schengen-area air service', color:'#6b7280', weight:2 }, 1113: { label: 'Airship service', color:'#6b7280', weight:2 },
      1114: { label: 'All air services', color:'#6b7280', weight:2 },

      700: { label: 'Bus service', color:'#2563eb', weight:3 }, 701: { label: 'Regional bus service', color:'#2563eb', weight:3 },
      702: { label: 'Express bus service', color:'#1d4ed8', weight:3 }, 703: { label: 'Stopping bus service', color:'#2563eb', weight:3 },
      704: { label: 'Local bus service', color:'#2563eb', weight:3 }, 705: { label: 'Night bus service', color:'#0f172a', weight:3 },
      706: { label: 'Post bus service', color:'#6b7280', weight:3 }, 707: { label: 'Special needs bus', color:'#6b7280', weight:3 },
      708: { label: 'Mobility bus service', color:'#6b7280', weight:3 }, 709: { label: 'Mobility bus for registered disabled', color:'#6b7280', weight:3 },
      710: { label: 'Sightseeing bus', color:'#f59e0b', weight:3 }, 711: { label: 'Shuttle bus', color:'#6b7280', weight:3 },
      712: { label: 'School bus', color:'#6b7280', weight:3 }, 713: { label: 'School and public service bus', color:'#6b7280', weight:3 },
      714: { label: 'Rail replacement bus service', color:'#9ca3af', weight:3 }, 715: { label: 'Demand and response bus service', color:'#6b7280', weight:3 },
      716: { label: 'All bus services', color:'#2563eb', weight:3 },

      800: { label: 'Trolleybus service', color:'#8b5cf6', weight:3 },

      900: { label: 'Tram service', color:'#f59e0b', weight:3 }, 901: { label: 'City tram service', color:'#f59e0b', weight:3 },
      902: { label: 'Local tram service', color:'#f59e0b', weight:3 }, 903: { label: 'Regional tram service', color:'#f59e0b', weight:3 },
      904: { label: 'Sightseeing tram service', color:'#f59e0b', weight:3 }, 905: { label: 'Shuttle tram service', color:'#f59e0b', weight:3 },
      906: { label: 'All tram services', color:'#f59e0b', weight:3 },

      1300: { label: 'Telecabin / cable car', color:'#7c3aed', weight:3 }, 1301: { label: 'Gondola lift', color:'#06b6d4', weight:3 }
    };

const CANONICAL_CATEGORIES = {
  metro: { label: 'Metro', order: 10 },
  tram: { label: 'Tramwaj', order: 20 },
  trolleybus: { label: 'Trolejbus', order: 30 },
  bus: { label: 'Autobus', order: 40 },
  rail: { label: 'Kolej', order: 50 },
  other: { label: 'Inne', order: 60 },
  coach: { label: 'Autokar', order: 70 },
  ferry: { label: 'Promy', order: 80 },
  air: { label: 'Samolot', order: 90 },
  cable: { label: 'Koleje liniowe', order: 100 },
  gondola: { label: 'Gondola', order: 110 },
  funicular: { label: 'Funikular', order: 120 },
  monorail: { label: 'Monorail', order: 130 }
};
// --- END: Canonical route type collector

// ═══════════════════════════════════════════════════════════════
// 2. STATE MANAGEMENT
// ═══════════════════════════════════════════════════════════════

let lastRenderTime = 0;
const RENDER_THROTTLE_MS = 200; // Max 5 FPS

let state = {
  gtfsData: null,
  selectedRoute: null,
  loading: false,
  loadingStep: '',
  loadingProgress: 0,
  loadingProgressPercent: 0,
  error: '',
  selectedDate: '',
  availableDates: [],
  selectedDirection: '0',
  selectedVariant: 1,
  selectedVariantFilter: 0,  // 0 = wszystkie, 1+ = specific variant
  mapLoaded: false,
  showAllTrips: false,
  threshold: 10,
  currentWorker: null,
  // UI: group mode for routes list - 'route_id' or 'service_type'
  routeGroupMode: 'service_type',
  routesOptionsOpen: false,
  routesOptionsListenerAttached: false,
  // custom route type map can be injected/extended
  customRouteTypeMap: {},

  // NOWE:
  selectedRouteGroup: null,   // obecna logiczna grupa linii (dla listy linii)
  routeProfiles: {},          // profile tras (graf/core) per logical group + direction
  showStopsView: false,       // tryb „przystanki" vs „linie"
  routesListScrollPosition: 0, // scroll position for ROUTES_LIST view

  selectedStop: null,
  stopViewFilteredRoutes: [],
  
  // Stops list view state
  expandedStopGroup: null,
  stopsListMapState: null,
  stopsListSearchQuery: '',
  
  // Pagination state for stops list
  stopsListPage: 1,
  stopsListPageSize: 50,
  
  // Virtual scrolling state for large stop lists
  virtualListStartIndex: 0,
  virtualListItemHeight: 68, // px - height of stop-group element

  // Map layers for stop detail view
  stopDetailMapLayers: {},
  stopDetailMapInitialized: false,
  stopDetailMapInstance: null,
  stopDetailDepartures: [], // All departures for current stop

  // Cached timetable data for modal
  currentTimetableData: {
    allTrips: [],           // wszystkie trips (włącznie z ukrytymi)
    stopDepartures: {}      // mapa: stop_id -> lista odjazdów z trip_id i czasem
  },

  // Canonical master lists: stable row order per route/group + direction
  // Structure: canonicalMasterLists[key][direction] = { rows: [...], nodeTypeMap: {...} }
  // Rows are built from ALL trips (no date filter) and never reordered.
  // Only visibility is filtered at render time.
  canonicalMasterLists: {},

  // Column order cache: trips order per (key, dir, date, showAllTrips)
  // Structure: columnOrderCache[cacheKey] = [trip_id, ...]
  columnOrderCache: {},
  
  // Performance metrics from last load
  lastLoadMetrics: null
};

let stopsSearchIndex = null;
let cachedGroupsArray = null;
let lastStopsDataHash = null;
let stationNameToIdCache = null;

// ═══════════════════════════════════════════════════════════════
// 3. UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════

const $ = (id) => document.getElementById(id);
const $$ = (selector, root = document) => Array.from(root.querySelectorAll(selector));

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// ═══════════════════════════════════════════════════════════════
// 3.1. DATA NORMALIZATION MODULE
// ═══════════════════════════════════════════════════════════════
    function escapeHtml(s) {
      if (s === null || s === undefined) return '';
      return String(s).replace(/[&<>"']/g, function(m) { return ({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' })[m]; });
    }

    const keyCache = new Map();
    function normalizeKey(k) {
      if (k === null || k === undefined) return k;
      
      // Check cache first
      if (keyCache.has(k)) return keyCache.get(k);
      
      let key = String(k).replace(/^\uFEFF/,'').trim().toLowerCase();
      const normalized = KEY_ALIAS[key] || key.replace(/\s+/g,'_');
      
      keyCache.set(k, normalized);
      return normalized;
    }
    function normalizeRecord(rec) {
      if (!rec || typeof rec !== 'object') {
        console.warn('normalizeRecord: Invalid record, expected object');
        return {};
      }
      
      const out = Object.create(null); // Faster than {} (no prototype chain)
      const keys = Object.keys(rec);
      
      for (let i = 0; i < keys.length; i++) {
        const origKey = keys[i];
        const norm = normalizeKey(origKey);
        const val = rec[origKey];
        
        if (val === null || val === undefined) {
          out[norm] = '';
        } else {
          const str = String(val);
          // Optimize: Combined quote removal and trim
          const hasStartQuote = str[0] === '"';
          const hasEndQuote = str[str.length - 1] === '"';
          
          if (hasStartQuote && hasEndQuote) {
            // Remove surrounding quotes and trim
            out[norm] = str.substring(1, str.length - 1).trim();
          } else if (hasStartQuote || hasEndQuote) {
            // Only one quote - just remove and trim
            out[norm] = str.replace(/^"|"$/g, '').trim();
          } else {
            // No quotes - just trim
            out[norm] = str.trim();
          }
        }
      }
      return out;
    }

// ═══════════════════════════════════════════════════════════════
// 3.2. TIME AND DATE MODULE (GTFS-specific)
// ═══════════════════════════════════════════════════════════════
    function timeToMinutes(timeStr) {
      if (!timeStr) return 0;
      const parts = timeStr.split(':');
      const h = parseInt(parts[0] || '0', 10);
      const m = parseInt(parts[1] || '0', 10);
      return h * 60 + m;
    }
    function minutesToTime(minutes) {
      if (!minutes && minutes !== 0) return '';
      const h = Math.floor(minutes / 60);
      const m = minutes % 60;
      const s = 0;
      return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
    }
    function formatTime(time) {
      if (!time) return '<';
      const str = String(time);
      const parts = str.split(':');
      let hours = parseInt(parts[0]||'0',10);
      const minutes = parts[1]||'00';
      if (hours >= 24) hours = hours - 24;
      return `${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}`;
    }
    function parseGTFSDate(dateStr) {
      if(!dateStr || dateStr.length!==8) return null;
      return new Date(parseInt(dateStr.substring(0,4)), parseInt(dateStr.substring(4,6)) - 1, parseInt(dateStr.substring(6,8)));
    }
    function formatDateToGTFS(date) {
      return date.getFullYear() + String(date.getMonth()+1).padStart(2,'0') + String(date.getDate()).padStart(2,'0');
    }

// ═══════════════════════════════════════════════════════════════
// 3.3. GEOMETRY AND GEOGRAPHY MODULE
// ═══════════════════════════════════════════════════════════════
    function simplifyDouglasPeucker(points, tolerance = 0.0001) {
      if (!points || points.length <= 2) return points;
      
      function perpendicularDistance(point, lineStart, lineEnd) {
        const [x, y] = point;
        const [x1, y1] = lineStart;
        const [x2, y2] = lineEnd;
        
        const dx = x2 - x1;
        const dy = y2 - y1;
        
        if (dx === 0 && dy === 0) {
          return Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);
        }
        
        const numerator = Math.abs(dy * x - dx * y + x2 * y1 - y2 * x1);
        const denominator = Math.sqrt(dx ** 2 + dy ** 2);
        
        return numerator / denominator;
      }
      
      function simplifyRecursive(points, tolerance, startIdx, endIdx) {
        let maxDistance = 0;
        let maxIndex = 0;
        
        for (let i = startIdx + 1; i < endIdx; i++) {
          const distance = perpendicularDistance(
            points[i],
            points[startIdx],
            points[endIdx]
          );
          
          if (distance > maxDistance) {
            maxDistance = distance;
            maxIndex = i;
          }
        }
        
        // If max distance is greater than tolerance, recursively simplify
        if (maxDistance > tolerance) {
          const leftPart = simplifyRecursive(points, tolerance, startIdx, maxIndex);
          const rightPart = simplifyRecursive(points, tolerance, maxIndex, endIdx);
          
          // Combine results (remove duplicate point at junction)
          return leftPart.slice(0, -1).concat(rightPart);
        } else {
          // Return just endpoints
          return [points[startIdx], points[endIdx]];
        }
      }
      
      return simplifyRecursive(points, tolerance, 0, points.length - 1);
    }
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371000; // Earth radius in meters
  const φ1 = lat1 * Math.PI / 180;
  const φ2 = lat2 * Math.PI / 180;
  const Δφ = (lat2 - lat1) * Math.PI / 180;
  const Δλ = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) * Math.sin(Δλ / 2);

  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c;
}
function calculateShapeCoverage(stops, shapePoints) {
  const MAX_DISTANCE_METERS = 100; // 100m tolerance (configurable heuristic)
  const nearbyStops = [];
  
  stops.forEach((stop, index) => {
    const stopLat = parseFloat(stop.lat || stop.stop_lat);
    const stopLon = parseFloat(stop.lon || stop.stop_lon);
    
    if (isNaN(stopLat) || isNaN(stopLon)) return;
    
    let minDistance = Infinity;
    let nearestShapeIndex = -1;
    
    shapePoints.forEach((shapePoint, shapeIndex) => {
      const distance = haversineDistance(
        stopLat, stopLon,
        shapePoint[0], shapePoint[1]
      );
      
      if (distance < minDistance) {
        minDistance = distance;
        nearestShapeIndex = shapeIndex;
      }
    });
    
    if (minDistance < MAX_DISTANCE_METERS) {
      nearbyStops.push({
        stopIndex: index,
        shapeIndex: nearestShapeIndex,
        distance: minDistance
      });
    }
  });
  
  return {
    percentage: nearbyStops.length / stops.length,
    nearbyStops: nearbyStops
  };
}
function fillShapeGaps(stops, shapePoints, nearbyStops) {
  const result = [];
  
  for (let i = 0; i < stops.length - 1; i++) {
    const currentStop = stops[i];
    const nextStop = stops[i + 1];
    
    const currentNearby = nearbyStops.find(n => n.stopIndex === i);
    const nextNearby = nearbyStops.find(n => n.stopIndex === i + 1);
    
    // Case 1: Both stops covered by shape - use shape segment
    if (currentNearby && nextNearby) {
      const startIdx = currentNearby.shapeIndex;
      const endIdx = nextNearby.shapeIndex;
      
      if (endIdx > startIdx) {
        const segment = shapePoints.slice(startIdx, endIdx + 1);
        result.push(...segment);
      } else {
        // Shape goes backwards - use straight line
        result.push(
          [parseFloat(currentStop.lat || currentStop.stop_lat), parseFloat(currentStop.lon || currentStop.stop_lon)],
          [parseFloat(nextStop.lat || nextStop.stop_lat), parseFloat(nextStop.lon || nextStop.stop_lon)]
        );
      }
    }
    // Case 2: Gap in shape - fill with straight line
    else {
      if (i === 0 || result.length === 0) {
        result.push([parseFloat(currentStop.lat || currentStop.stop_lat), parseFloat(currentStop.lon || currentStop.stop_lon)]);
      }
      result.push([parseFloat(nextStop.lat || nextStop.stop_lat), parseFloat(nextStop.lon || nextStop.stop_lon)]);
    }
  }
  
  return result;
}

// ═══════════════════════════════════════════════════════════════
// 3.4. CACHE AND SERIALIZATION MODULE
// ═══════════════════════════════════════════════════════════════
    function compressCoordinates(coords) {
      if (!coords || coords.length === 0) return '';
      
      const deltas = [];
      let prevLat = 0, prevLon = 0;
      
      for (const [lat, lon] of coords) {
        const latInt = Math.round(lat * 1e6);
        const lonInt = Math.round(lon * 1e6);
        
        deltas.push(latInt - prevLat);
        deltas.push(lonInt - prevLon);
        
        prevLat = latInt;
        prevLon = lonInt;
      }
      
      return deltas.map(d => d.toString(36)).join(',');
    }

    function decompressCoordinates(compressed) {
      if (!compressed) return [];
      
      const deltas = compressed.split(',').map(s => parseInt(s, 36));
      const coords = [];
      let lat = 0, lon = 0;
      
      for (let i = 0; i < deltas.length; i += 2) {
        lat += deltas[i];
        lon += deltas[i + 1];
        
        // Divide by 1e6 to restore decimal coordinates
        coords.push([lat / 1e6, lon / 1e6]);
      }
      
      return coords;
    }

    function hashShapesData(shapesIndex) {
      const keys = Object.keys(shapesIndex).sort();
      const sample = keys.slice(0, 10).join(',') + keys.length;
      let hash = 0;
      for (let i = 0; i < sample.length; i++) {
        const char = sample.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return 'shapes_' + Math.abs(hash).toString(36);
    }

    function cacheShapes(shapesIndex, simplified) {
      try {
        const cacheKey = hashShapesData(shapesIndex);
        
        const compressed = {};
        Object.keys(simplified).forEach(shapeId => {
          compressed[shapeId] = compressCoordinates(simplified[shapeId]);
        });
        
        const cacheData = {
          version: 2, // version 2 uses compression
          timestamp: Date.now(),
          shapes: compressed
        };
        
        const jsonStr = JSON.stringify(cacheData);
        const originalSize = jsonStr.length;
        
        localStorage.setItem(cacheKey, jsonStr);
      } catch (e) {
        // If storage quota exceeded, try to clear old caches
        if (e.name === 'QuotaExceededError') {
          try {
            // Remove old shape caches
            for (let i = 0; i < localStorage.length; i++) {
              const key = localStorage.key(i);
              if (key && key.startsWith('shapes_')) {
                localStorage.removeItem(key);
              }
            }
          } catch (e2) {
            // Ignore cache cleanup errors - they don't affect core functionality
          }
        }
      }
    }

    function loadCachedShapes(shapesIndex) {
      try {
        const cacheKey = hashShapesData(shapesIndex);
        const cached = localStorage.getItem(cacheKey);
        if (!cached) return null;
        
        const data = JSON.parse(cached);
        
        const age = Date.now() - data.timestamp;
        if (age > 30 * 24 * 60 * 60 * 1000) {
          localStorage.removeItem(cacheKey);
          return null;
        }
        
        const shapes = {};
        Object.keys(data.shapes).forEach(shapeId => {
          if (data.version === 2) {
            // Version 2 uses compression
            shapes[shapeId] = decompressCoordinates(data.shapes[shapeId]);
          } else {
            // Version 1 or unversioned - direct coordinates
            shapes[shapeId] = data.shapes[shapeId];
          }
        });
        
        return shapes;
      } catch (e) {
        return null;
      }
    }

    function simplifyShapes(shapesIndex, tolerance = 0.0001) {
      const simplified = {};
      let totalOriginal = 0;
      let totalSimplified = 0;
      
      Object.keys(shapesIndex).forEach(shapeId => {
        const points = shapesIndex[shapeId];
        totalOriginal += points.length;
        
        if (points.length <= 2) {
          simplified[shapeId] = points;
          totalSimplified += points.length;
        } else {
          const simplifiedPoints = simplifyDouglasPeucker(points, tolerance);
          simplified[shapeId] = simplifiedPoints;
          totalSimplified += simplifiedPoints.length;
        }
      });
      
      const reduction = totalOriginal > 0 
        ? Math.round((1 - totalSimplified / totalOriginal) * 100) 
        : 0;
      
      return simplified;
    }

// ═══════════════════════════════════════════════════════════════
// 3.5. DATA QUALITY HEURISTICS MODULE
// ═══════════════════════════════════════════════════════════════
function mostCommonString(arr) {
  const counts = Object.create(null);
  for (const s of arr) {
    if (!s) continue;
    const t = String(s).trim();
    if (!t) continue;
    counts[t] = (counts[t] || 0) + 1;
  }
  let best = null, bestCount = 0;
  Object.keys(counts).forEach(k => { if (counts[k] > bestCount) { best = k; bestCount = counts[k]; }});
  return best;
}
function looksLikeGarbageLabel(s, shortName) {
  if (!s) return true;
  const t = String(s).trim();
  if (t.length < 2) return true;
  if (/^[0-9\-\s]+$/.test(t)) {
    if (!shortName) return true;
    if (t.replace(/\s+/g,'') === String(shortName).replace(/\s+/g,'')) return true;
  }
  return false;
}

// ═══════════════════════════════════════════════════════════════
// 3.6. DIRECTION_ID ENRICHMENT MODULE
// ═══════════════════════════════════════════════════════════════
const TO_RAD = Math.PI / 180;
const TO_DEG = 180 / Math.PI;
function calculateBearing(lat1, lon1, lat2, lon2) {
  const dLon = (lon2 - lon1) * TO_RAD;
  const y = Math.sin(dLon) * Math.cos(lat2 * TO_RAD);
  const x = Math.cos(lat1 * TO_RAD) * Math.sin(lat2 * TO_RAD) -
            Math.sin(lat1 * TO_RAD) * Math.cos(lat2 * TO_RAD) * Math.cos(dLon);
  
  let bearing = Math.atan2(y, x) * TO_DEG;
  return (bearing + 360) % 360; // Normalize to 0-360
}
function tripSequenceScore(tripSeq, pattern) {
  // Count how many stops from tripSeq appear in correct order in pattern
  const patternSet = new Set(pattern);
  const relevantStops = tripSeq.filter(stop => patternSet.has(stop));
  
  if (relevantStops.length === 0) return 0;
  
  let matchCount = 0;
  let idx = 0;
  
  for (let i = 0; i < relevantStops.length; i++) {
    const val = relevantStops[i];
    while (idx < pattern.length && pattern[idx] !== val) {
      idx++;
    }
    if (idx < pattern.length) {
      matchCount++;
      idx++;
    }
  }
  
  return matchCount / relevantStops.length;
}
function getTripStopSequence(tripId, stopTimesIndex) {
  const stopTimes = stopTimesIndex[tripId];
  if (!stopTimes || stopTimes.length === 0) return [];
  return stopTimes.map(st => st.stop_id);
}
function isCircularRoute(stopSequence) {
  if (!stopSequence || stopSequence.length < 2) return false;
  return stopSequence[0] === stopSequence[stopSequence.length - 1];
}
// Helper function to process a single route's direction enrichment
function enrichRouteDirections(routeTrips, stopTimesIndex, stopsIndex) {
  const tripsToProcess = routeTrips.filter(t => 
    !t.direction_id || t.direction_id === ''
  );
  
  if (tripsToProcess.length === 0) return;
  
  const tripPatterns = tripsToProcess.map(trip => ({
    tripId: trip.trip_id,
    trip: trip,
    sequence: getTripStopSequence(trip.trip_id, stopTimesIndex)
  }));
  
  const validPatterns = tripPatterns.filter(p => p.sequence.length > 0);
  
  if (validPatterns.length === 0) {
    tripsToProcess.forEach(trip => trip.direction_id = '0');
    return;
  }
  
  const isCircular = validPatterns.every(p => isCircularRoute(p.sequence));
  if (isCircular) {
    tripsToProcess.forEach(trip => trip.direction_id = '0');
    return;
  }
  
  let refPattern = null;
  let maxLen = 0;
  
  for (const pattern of validPatterns) {
    if (pattern.sequence.length > maxLen) {
      maxLen = pattern.sequence.length;
      refPattern = pattern;
    }
  }
  
  if (!refPattern || refPattern.sequence.length === 0) {
    tripsToProcess.forEach(trip => trip.direction_id = '0');
    return;
  }
  
  const patternFwd = refPattern.sequence;
  const patternRev = [...patternFwd].reverse();
  
  let refBearing = null;
  if (stopsIndex && patternFwd.length >= 2) {
    const firstStop = stopsIndex[patternFwd[0]];
    const lastStop = stopsIndex[patternFwd[patternFwd.length - 1]];
    
    if (firstStop && lastStop) {
      const lat1 = parseFloat(firstStop.stop_lat);
      const lon1 = parseFloat(firstStop.stop_lon);
      const lat2 = parseFloat(lastStop.stop_lat);
      const lon2 = parseFloat(lastStop.stop_lon);
      
      if (!isNaN(lat1) && !isNaN(lon1) && !isNaN(lat2) && !isNaN(lon2)) {
        refBearing = calculateBearing(lat1, lon1, lat2, lon2);
      }
    }
  }
  
  tripsToProcess.forEach(trip => {
    const seq = getTripStopSequence(trip.trip_id, stopTimesIndex);
    
    if (!seq || seq.length === 0) {
      trip.direction_id = '0';
      return;
    }
    
    const scoreFwd = tripSequenceScore(seq, patternFwd);
    const scoreRev = tripSequenceScore(seq, patternRev);
    
    if (scoreFwd > scoreRev + 0.1) {
      trip.direction_id = '0';
    } else if (scoreRev > scoreFwd + 0.1) {
      trip.direction_id = '1';
    } else {
      if (refBearing !== null && stopsIndex && seq.length >= 2) {
        const firstStop = stopsIndex[seq[0]];
        const lastStop = stopsIndex[seq[seq.length - 1]];
        
        if (firstStop && lastStop) {
          const lat1 = parseFloat(firstStop.stop_lat);
          const lon1 = parseFloat(firstStop.stop_lon);
          const lat2 = parseFloat(lastStop.stop_lat);
          const lon2 = parseFloat(lastStop.stop_lon);
          
          if (!isNaN(lat1) && !isNaN(lon1) && !isNaN(lat2) && !isNaN(lon2)) {
            const tripBearing = calculateBearing(lat1, lon1, lat2, lon2);
            
            let diff = Math.abs(tripBearing - refBearing);
            if (diff > 180) diff = 360 - diff;
            
            trip.direction_id = diff < 90 ? '0' : '1';
          } else {
            trip.direction_id = '0';
          }
        } else {
          trip.direction_id = '0';
        }
      } else {
        trip.direction_id = '0';
      }
    }
  });
}

// Async version with chunked processing to prevent UI freezes
async function enrichTripsWithDirectionIdAsync(trips, stopTimesIndex, stopsIndex, onProgress) {
  const tripsByRoute = {};
  
  for (const trip of trips) {
    if (!trip || !trip.trip_id) continue;
    
    const routeId = trip.route_id || 'unknown';
    if (!tripsByRoute[routeId]) {
      tripsByRoute[routeId] = [];
    }
    tripsByRoute[routeId].push(trip);
  }
  
  const routeIds = Object.keys(tripsByRoute);
  const CHUNK_SIZE = 10; // Process 10 routes at a time
  
  for (let i = 0; i < routeIds.length; i += CHUNK_SIZE) {
    const chunk = routeIds.slice(i, i + CHUNK_SIZE);
    
    chunk.forEach(routeId => {
      enrichRouteDirections(tripsByRoute[routeId], stopTimesIndex, stopsIndex);
    });
    
    // Update progress
    if (onProgress) {
      const percent = Math.round(((i + chunk.length) / routeIds.length) * 100);
      onProgress(i + chunk.length, routeIds.length, percent);
    }
    
    // Yield to browser to keep UI responsive
    if (i + CHUNK_SIZE < routeIds.length) {
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
}

// Synchronous version for backward compatibility
function enrichTripsWithDirectionId(trips, stopTimesIndex, stopsIndex) {
  const tripsByRoute = {};
  
  for (const trip of trips) {
    if (!trip || !trip.trip_id) continue;
    
    const routeId = trip.route_id || 'unknown';
    if (!tripsByRoute[routeId]) {
      tripsByRoute[routeId] = [];
    }
    tripsByRoute[routeId].push(trip);
  }
  
  for (const routeId in tripsByRoute) {
    enrichRouteDirections(tripsByRoute[routeId], stopTimesIndex, stopsIndex);
  }
}

// ═══════════════════════════════════════════════════════════════
// 4. DATA PARSING & LOADING
// ═══════════════════════════════════════════════════════════════
// Helper function to parse a single CSV line (handles quoted fields)
function parseCSVLine(line) {
  if (!line) return [];
  
  // Fast path: no quotes = simple split (much faster)
  if (!line.includes('"')) {
    return line.split(',');
  }
  
  // Slow path: handle quoted fields
  const result = [];
  const chars = [];
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        // Escaped quote ("")
        chars.push('"');
        i++; // Skip next quote
      } else {
        // Toggle quote mode
        inQuotes = !inQuotes;
      }
    } else if (char === ',' && !inQuotes) {
      // Field separator (outside quotes)
      result.push(chars.join(''));
      chars.length = 0; // Clear array (faster than creating new)
    } else {
      chars.push(char);
    }
  }
  
  // Add last field
  result.push(chars.join(''));
  
  // Warn if quotes are still open (malformed CSV)
  if (inQuotes) {
    console.warn('parseCSVLine: Unclosed quotes in line:', line.substring(0, 50) + '...');
  }
  
  return result;
}

// CSV parser - used for all files
function parseCSV(text) {
  if (!text || typeof text !== 'string') {
    console.warn('parseCSV: Invalid input, expected non-empty string');
    return [];
  }
  
  // Optimize: Replace \r\n with \n first (one-time operation), then simple split
  const normalized = text.includes('\r') ? text.replace(/\r\n/g, '\n').replace(/\r/g, '\n') : text;
  const lines = normalized.split('\n');
  if (lines.length === 0) return [];
  
  const headerLine = lines[0].replace(/^\uFEFF/, '');
  const headers = parseCSVLine(headerLine).map(h => h.trim());
  
  const result = [];
  
  // Parse data rows - optimized for speed
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    if (!line || !line.trim()) continue; // Skip empty lines
    
    const values = parseCSVLine(line);
    const row = {};
    
    // Use for loop instead of forEach (faster)
    for (let j = 0; j < headers.length; j++) {
      const value = values[j] || '';
      row[headers[j]] = value.trim();
    }
    
    result.push(normalizeRecord(row));
  }
  
  return result;
}

// Async CSV parser with chunked processing for better UI responsiveness

function parseStopTimesStreamWithWorker(zipFileEntry, onProgress) {
  return new Promise(async (resolve, reject) => {
    try {
      const arrayBuffer = await zipFileEntry.async('arraybuffer');
      const decoder = new TextDecoder('utf-8');
      
      let buffer = '';
      let lineCount = 0;
      let headers = null;
      const stopTimesIndex = Object.create(null);
      
      const PROGRESS_UPDATE_INTERVAL = 100000;  // ← Increased from 10k
      const ESTIMATED_LINES_FOR_PROGRESS = 100000;
      const CHUNK_SIZE = 1024 * 1024;
      
      // ═══ REMOVED smartSplit - use native split! ═══
      // NOTE: Using native split(',') for performance (100x faster than smartSplit).
      // This works for GTFS stop_times.txt because fields typically don't contain commas.
      // If a feed has quoted fields with embedded commas, use the full parseCSV function instead.
      
      const getCol = (cols, idx) => {
        if (idx === -1 || idx >= cols.length) return '';
        let val = cols[idx];
        if (!val) return '';
        
        // Remove quotes in-place
        if (val[0] === '"' && val[val.length-1] === '"') {
          val = val.substring(1, val.length - 1);
        }
        
        // Trim only if needed (check first/last char)
        if (val[0] === ' ' || val[val.length-1] === ' ') {
          return val.trim();
        }
        
        return val;
      };
      
      const processLine = (line) => {
        if (!line.trim()) return;
        
        if (!headers) {
          const rawHeaders = line.split(',').map(h => h.replace(/^"|"$/g, '').trim());
          headers = {
            tripIdx: -1,
            stopIdx: -1,
            seqIdx: -1,
            arrIdx: -1,
            depIdx: -1,
            pickupIdx: -1,
            dropoffIdx: -1
          };
          
          rawHeaders.forEach((h, i) => {
            const normalized = normalizeKey(h);
            if (normalized === 'trip_id') headers.tripIdx = i;
            else if (normalized === 'stop_id') headers.stopIdx = i;
            else if (normalized === 'stop_sequence') headers.seqIdx = i;
            else if (normalized === 'arrival_time') headers.arrIdx = i;
            else if (normalized === 'departure_time') headers.depIdx = i;
            else if (normalized === 'pickup_type') headers.pickupIdx = i;
            else if (normalized === 'drop_off_type') headers.dropoffIdx = i;
          });
          
          if (headers.tripIdx === -1 || headers.stopIdx === -1) {
            throw new Error('Brakuje wymaganych kolumn w stop_times.txt: trip_id lub stop_id');
          }
          return;
        }
        
        // ═══ NATIVE SPLIT - 100x faster than smartSplit! ═══
        const cols = line.split(',');
        
        if (cols.length <= Math.max(headers.tripIdx, headers.stopIdx)) return;
        
        const tripId = getCol(cols, headers.tripIdx);
        const stopId = getCol(cols, headers.stopIdx);
        
        if (!tripId || !stopId) return;
        
        if (!stopTimesIndex[tripId]) {
          stopTimesIndex[tripId] = [];
        }
        
        stopTimesIndex[tripId].push({
          stop_id: stopId,
          arrival_time: getCol(cols, headers.arrIdx),
          departure_time: getCol(cols, headers.depIdx),
          stop_sequence: parseInt(getCol(cols, headers.seqIdx) || '0', 10),
          pickup_type: getCol(cols, headers.pickupIdx) || '0',  // ← Removed String()
          drop_off_type: getCol(cols, headers.dropoffIdx) || '0'  // ← Removed String()
        });
        
        lineCount++;
        if (lineCount % PROGRESS_UPDATE_INTERVAL === 0) {  // ← Less frequent
          state.loadingProgress = lineCount;
          if (onProgress) {
            onProgress(lineCount, Math.min(99, Math.round(lineCount / ESTIMATED_LINES_FOR_PROGRESS * 100)));
          }
        }
      };
      
      let offset = 0;
      while (offset < arrayBuffer.byteLength) {
        try {
          const chunkEnd = Math.min(offset + CHUNK_SIZE, arrayBuffer.byteLength);
          const chunk = new Uint8Array(arrayBuffer, offset, chunkEnd - offset);
          const isLastChunk = chunkEnd === arrayBuffer.byteLength;
          const text = decoder.decode(chunk, { stream: !isLastChunk });
          buffer += text;
          
          let newlineIndex;
          // Optimize: Use lastIndexOf to process multiple lines at once
          while ((newlineIndex = buffer.indexOf('\n')) !== -1) {
            const line = buffer.slice(0, newlineIndex); // slice is faster for large strings
            processLine(line);
            buffer = buffer.slice(newlineIndex + 1);
          }
          
          offset = chunkEnd;
        } catch (err) {
          console.error('Error processing chunk at offset', offset, ':', err);
          // Continue processing next chunk instead of failing completely
          offset = Math.min(offset + CHUNK_SIZE, arrayBuffer.byteLength);
        }
      }
      
      if (buffer.trim()) {
        try {
          processLine(buffer);
        } catch (err) {
          console.error('Error processing final buffer:', err);
        }
      }
      
      // Sort (same as before)
      Object.keys(stopTimesIndex).forEach(tripId => {
        stopTimesIndex[tripId].sort((a, b) => a.stop_sequence - b.stop_sequence);
      });
      
      if (onProgress) onProgress(lineCount, 100);
      resolve(stopTimesIndex);
      
    } catch(err) {
      reject(err);
    }
  });
}

    function parseShapesWithWorker(zipFileEntry, onProgress) {
      return new Promise(async (resolve, reject) => {
        try {
          const text = await zipFileEntry.async('string');
          
          const workerCode = `
            const KEY_ALIAS = {
              'route id':'route_id','routeid':'route_id','route_id':'route_id','route short name':'route_short_name','route_short_name':'route_short_name',
              'route long name':'route_long_name','route_long_name':'route_long_name','trip id':'trip_id','tripid':'trip_id','trip_id':'trip_id',
              'service id':'service_id','serviceid':'service_id','service_id':'service_id','stop id':'stop_id','stopid':'stop_id','stop_id':'stop_id',
              'stop sequence':'stop_sequence','stop_sequence':'stop_sequence','arrival time':'arrival_time','arrival_time':'arrival_time',
              'departure time':'departure_time','departure_time':'departure_time','pickup type':'pickup_type','pickup_type':'pickup_type',
              'drop off type':'drop_off_type','drop_off_type':'drop_off_type','stop lat':'stop_lat','stop_lat':'stop_lat',
              'stop lon':'stop_lon','stop_lon':'stop_lon','direction id':'direction_id','direction_id':'direction_id',
              'trip headsign':'trip_headsign','trip_headsign':'trip_headsign','start date':'start_date','start_date':'start_date',
              'end date':'end_date','end_date':'end_date','monday':'monday','tuesday':'tuesday','wednesday':'wednesday','thursday':'thursday',
              'friday':'friday','saturday':'saturday','sunday':'sunday','exception type':'exception_type','exception_type':'exception_type','date':'date',
              'shape id':'shape_id','shape_id':'shape_id','shape pt lat':'shape_pt_lat','shape_pt_lat':'shape_pt_lat',
              'shape pt lon':'shape_pt_lon','shape_pt_lon':'shape_pt_lon','shape pt sequence':'shape_pt_sequence','shape_pt_sequence':'shape_pt_sequence'
            };
            
            function normalizeKey(k) {
              if (k === null || k === undefined) return k;
              let key = String(k).replace(/^\\uFEFF/,'').trim().toLowerCase();
              return KEY_ALIAS[key] || key.replace(/\\s+/g,'_');
            }
            
            function smartSplit(line) {
              if (!line.includes('"')) {
                return line.split(',');
              }
              
              const cols = [];
              let current = '';
              let inQuotes = false;
              
              for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                  if (i + 1 < line.length && line[i+1] === '"') {
                    current += '"';
                    i++;
                  } else {
                    inQuotes = !inQuotes;
                  }
                } else if (char === ',' && !inQuotes) {
                  cols.push(current);
                  current = '';
                } else {
                  current += char;
                }
              }
              cols.push(current);
              return cols;
            }
            
            self.onmessage = function(e) {
              const text = e.data.text;
              const lines = text.split(/\\r?\\n/);
              
              if (lines.length === 0) {
                self.postMessage({ type: 'done', shapesIndex: {} });
                return;
              }
              
              const headerLine = lines[0];
              const rawHeaders = smartSplit(headerLine);
              const headers = rawHeaders.map(h => normalizeKey(h));
              
              const shapeIdIdx = headers.indexOf('shape_id');
              const latIdx = headers.indexOf('shape_pt_lat');
              const lonIdx = headers.indexOf('shape_pt_lon');
              const seqIdx = headers.indexOf('shape_pt_sequence');
              
              if (shapeIdIdx === -1 || latIdx === -1 || lonIdx === -1 || seqIdx === -1) {
                self.postMessage({ 
                  type: 'error', 
                  message: 'shapes.txt missing required fields' 
                });
                return;
              }
              
              const shapesData = {};
              let processedRows = 0;
              const totalRows = lines.length - 1;
              
              // Parse all rows
              for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const cols = smartSplit(line);
                const shapeId = cols[shapeIdIdx];
                const lat = parseFloat(cols[latIdx]);
                const lon = parseFloat(cols[lonIdx]);
                const seq = parseInt(cols[seqIdx] || '0', 10);
                
                if (!shapeId || isNaN(lat) || isNaN(lon)) continue;
                
                if (!shapesData[shapeId]) {
                  shapesData[shapeId] = [];
                }
                
                shapesData[shapeId].push({ lat, lon, seq });
                processedRows++;
                
                // Report progress every 10000 rows
                if (processedRows % 10000 === 0) {
                  const percent = Math.round((processedRows / totalRows) * 100);
                  self.postMessage({ 
                    type: 'progress', 
                    processed: processedRows,
                    total: totalRows,
                    percent 
                  });
                }
              }
              
              const shapesIndex = {};
              Object.keys(shapesData).forEach(shapeId => {
                const points = shapesData[shapeId];
                points.sort((a, b) => a.seq - b.seq);
                shapesIndex[shapeId] = points.map(p => [p.lat, p.lon]);
              });
              
              self.postMessage({ 
                type: 'done', 
                shapesIndex,
                shapeCount: Object.keys(shapesIndex).length,
                pointCount: processedRows
              });
            };
          `;
          
          const blob = new Blob([workerCode], { type: 'application/javascript' });
          const workerUrl = URL.createObjectURL(blob);
          const worker = new Worker(workerUrl);
          state.currentWorker = worker;
          
          worker.onmessage = function(ev) {
            const msg = ev.data;
            
            if (msg.type === 'progress') {
              if (onProgress) {
                onProgress(msg.processed, msg.percent);
              }
            } else if (msg.type === 'done') {
              state.currentWorker = null;
              URL.revokeObjectURL(workerUrl);
              resolve(msg.shapesIndex);
            } else if (msg.type === 'error') {
              state.currentWorker = null;
              URL.revokeObjectURL(workerUrl);
              reject(new Error(msg.message));
            }
          };
          
          worker.onerror = function(ev) {
            state.currentWorker = null;
            URL.revokeObjectURL(workerUrl);
            reject(new Error(ev.message || 'Worker parse error'));
          };
          
          // Start parsing
          worker.postMessage({ text });
          
        } catch(err) {
          reject(err);
        }
      });
    }

    async function unzipWithFflate(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(e) {
          try {
            const arrayBuffer = e.target.result;
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // Use fflate.unzip to decompress
            fflate.unzip(uint8Array, (err, unzipped) => {
              if (err) {
                reject(new Error('Failed to decompress ZIP: ' + err.message));
                return;
              }
              
              const files = {};
              
              for (const [path, data] of Object.entries(unzipped)) {
                // Skip directories (they end with /)
                if (path.endsWith('/')) continue;
                
                files[path] = {
                  name: path,
                  _data: data,
                  async: function(type) {
                    return Promise.resolve().then(() => {
                      if (type === 'string') {
                        const decoder = new TextDecoder('utf-8');
                        return decoder.decode(this._data);
                      } else if (type === 'arraybuffer') {
                        // Return as ArrayBuffer
                        return this._data.buffer.slice(this._data.byteOffset, this._data.byteOffset + this._data.byteLength);
                      } else if (type === 'uint8array') {
                        // Return the Uint8Array directly
                        return this._data;
                      } else if (type === 'blob') {
                        // Create a Blob from the data
                        return new Blob([this._data]);
                      }
                      // For other types, return the raw Uint8Array
                      return this._data;
                    });
                  }
                };
              }
              
              resolve({ files });
            });
          } catch (err) {
            reject(new Error('Error reading ZIP file: ' + err.message));
          }
        };
        
        reader.onerror = function() {
          reject(new Error('Failed to read file'));
        };
        
        reader.readAsArrayBuffer(file);
      });
    }

    function findFile(filesObj, filename) {
      const lowerFilename = filename.toLowerCase();
      
      // Try exact match first
      if (filesObj[filename]) {
        return filesObj[filename];
      }
      
      // Try case-insensitive search
      for (const path in filesObj) {
        const lowerPath = path.toLowerCase();
        
        // Check if the path ends with the filename (handles subdirectories)
        if (lowerPath === lowerFilename || lowerPath.endsWith('/' + lowerFilename)) {
          return filesObj[path];
        }
      }
      
      return null;
    }

    async function handleFileUpload(e) {
      const file = e.target.files[0]; if (!file) return;
      
      // ═══ PERFORMANCE MEASUREMENT START ═══
      const perfTimings = {
        totalStart: performance.now(),
        unzipStart: 0,
        unzipEnd: 0,
        parseStart: 0,
        parseEnd: 0,
        stopTimesStart: 0,
        stopTimesEnd: 0,
        shapesStart: 0,
        shapesEnd: 0,
        indexStart: 0,
        indexEnd: 0,
        enrichStart: 0,
        enrichEnd: 0
      };
      
      state.loading = true; state.loadingStep = 'Odczytywanie archiwum GTFS...'; state.loadingProgress=0; state.loadingProgressPercent=0; state.error='';
      render();
      try {
        // Use fflate for fast ZIP decompression
        state.loadingStep = 'Rozpakowywanie ZIP (fflate)...'; render();
        perfTimings.unzipStart = performance.now();
        const zip = await unzipWithFflate(file);
        perfTimings.unzipEnd = performance.now();
        
        state.loadingStep = 'Wyodrębnianie plików...'; render();
        
        const [routesFile, tripsFile, stopTimesFile, stopsFile, calendarFile, calendarDatesFile, agenciesFile, shapesFile] = 
          ['routes.txt', 'trips.txt', 'stop_times.txt', 'stops.txt', 'calendar.txt', 'calendar_dates.txt', 'agency.txt', 'shapes.txt']
          .map(filename => findFile(zip.files, filename));
        
        // Validate required files
        if (!routesFile || !tripsFile || !stopTimesFile || !stopsFile) {
          throw new Error('Brakuje wymaganych plików GTFS (routes.txt, trips.txt, stop_times.txt, stops.txt)');
        }

// ==========================================
// PARALLEL LOADING & PARSING - parse CSV files synchronously
// ==========================================
state.loadingStep = 'Przetwarzanie plików GTFS...'; render();

perfTimings.parseStart = performance.now();

// Parse all CSV files synchronously (fastest approach)
const [routes, trips, stops, calendar, calendarDates, agencies] = await Promise.all([
  routesFile.async('string').then(text => parseCSV(text)),
  tripsFile.async('string').then(text => parseCSV(text)),
  stopsFile.async('string').then(text => parseCSV(text)),
  calendarFile ? calendarFile.async('string').then(text => parseCSV(text)) : Promise.resolve([]),
  calendarDatesFile ? calendarDatesFile.async('string').then(text => parseCSV(text)) : Promise.resolve([]),
  agenciesFile ? agenciesFile.async('string').then(text => parseCSV(text)) : Promise.resolve([])
]);

perfTimings.parseEnd = performance.now();

        state.loadingStep = 'Parsowanie stop_times (streaming)...'; render();
        perfTimings.stopTimesStart = performance.now();
        const stopTimesIndex = await parseStopTimesStreamWithWorker(stopTimesFile, (rowsProcessed, percent) => {
          state.loadingStep = `Parsowanie stop_times: ${rowsProcessed.toLocaleString()} wierszy`;
          state.loadingProgressPercent = percent || state.loadingProgressPercent;
          render();
        });
        perfTimings.stopTimesEnd = performance.now();
        
        let shapesIndex = {};
        if (shapesFile) {
          state.loadingStep = 'Parsowanie shapes.txt (streaming)...'; render();
          perfTimings.shapesStart = performance.now();
          try {
            const rawShapes = await parseShapesWithWorker(shapesFile, (rowsProcessed, percent) => {
              state.loadingStep = `Parsowanie shapes: ${rowsProcessed.toLocaleString()} punktów`;
              state.loadingProgressPercent = percent || state.loadingProgressPercent;
              render();
            });
            
            let simplifiedShapes = loadCachedShapes(rawShapes);
            
            if (!simplifiedShapes) {
              // Simplify and cache
              state.loadingStep = 'Upraszczanie tras (Douglas-Peucker)...'; render();
              simplifiedShapes = simplifyShapes(rawShapes, 0.0001);
              cacheShapes(rawShapes, simplifiedShapes);
            }
            
            shapesIndex = simplifiedShapes;
            perfTimings.shapesEnd = performance.now();
          } catch (err) {
            perfTimings.shapesEnd = performance.now();
            // Continue without shapes - they're optional
          }
        }
        
        state.loadingStep = 'Budowanie indeksów...'; render();
        perfTimings.indexStart = performance.now();
        const stopsIndex = {}; stops.forEach(s=>{ if (s && s.stop_id) stopsIndex[s.stop_id]=s; });
        
        // Generate missing direction_id values with chunked processing
        state.loadingStep = 'Generowanie brakujących direction_id...'; render();
        perfTimings.enrichStart = performance.now();
        await enrichTripsWithDirectionIdAsync(trips, stopTimesIndex, stopsIndex, (processed, total, percent) => {
          state.loadingStep = `Generowanie direction_id: ${processed}/${total} tras`;
          state.loadingProgressPercent = percent;
          render();
        });
        perfTimings.enrichEnd = performance.now();
        
        const tripsIndex = {}; trips.forEach(t=>{ if(!t) return; const rid=t.route_id; if(!rid) return; if(!tripsIndex[rid]) tripsIndex[rid]=[]; tripsIndex[rid].push(t); });
const agenciesIndex = {};
agencies.forEach(a => {
  if (a && (a.agency_id || a.agency_name)) {
    agenciesIndex[a.agency_id || a.agency_name] = a;
  }
});

const logicalRoutes = buildLogicalRoutes(routes, agenciesIndex);

// Clear all caches when loading new GTFS data
clearStationCache();
clearStopsSearchIndex();
clearStopToRoutesCache();
cachedGroupsArray = null;
lastStopsDataHash = null;

state.gtfsData = {
  routes,
  agencies,
  agenciesIndex,
  calendar,
  calendarDates,
  stopTimesIndex,
  stopsIndex,
  tripsIndex,
  logicalRoutes,
  trips,
  stops,
  shapesIndex
};
state.selectedRouteGroup = null;
// Invalidate canonical master lists and column order cache on new GTFS load
state.canonicalMasterLists = {};
state.columnOrderCache = {};
        if (routes.length === 1) {
          state.selectedRoute = routes[0];
          const routeTrips = state.gtfsData.tripsIndex[state.selectedRoute.route_id] || [];
          if (routeTrips.length>0) state.selectedDirection = [...new Set(routeTrips.map(t=>t.direction_id||'0'))][0];
        }
const dates = generateAvailableDates(calendar, calendarDates);
state.availableDates = dates;
if (dates.length > 0) {
  const today = new Date();
  const todayStr = today.getFullYear() + 
    String(today.getMonth() + 1).padStart(2, '0') + 
    String(today.getDate()).padStart(2, '0');
  
  let selectedDate = null;
  
  // Check if today exists in dates
  if (dates.some(d => d.value === todayStr)) {
    selectedDate = todayStr;
  } else {
    const earlierDates = dates.filter(d => d.value <= todayStr);
    if (earlierDates.length > 0) {
      selectedDate = earlierDates[earlierDates.length - 1].value;
    } else {
      // If no earlier dates, use the first available date
      selectedDate = dates[0].value;
    }
  }
  
  state.selectedDate = selectedDate;
}

        // ═══ PERFORMANCE MEASUREMENT END ═══
        perfTimings.indexEnd = performance.now();
        const totalTime = perfTimings.indexEnd - perfTimings.totalStart;
        const unzipTime = perfTimings.unzipEnd - perfTimings.unzipStart;
        const parseTime = perfTimings.parseEnd - perfTimings.parseStart;
        const stopTimesTime = perfTimings.stopTimesEnd - perfTimings.stopTimesStart;
        const shapesTime = perfTimings.shapesEnd > 0 ? perfTimings.shapesEnd - perfTimings.shapesStart : 0;
        const indexTime = perfTimings.indexEnd - perfTimings.indexStart;
        const enrichTime = perfTimings.enrichEnd - perfTimings.enrichStart;
        
        // Console performance benchmark
        console.log('═══════════════════════════════════════════════');
        console.log('GTFS LOADING PERFORMANCE REPORT');
        console.log('═══════════════════════════════════════════════');
        console.log(`Total loading time: ${totalTime.toFixed(2)} ms (${(totalTime/1000).toFixed(2)} s)`);
        console.log('');
        console.log('Breakdown by phase:');
        console.log(`  1. Unzip:           ${unzipTime.toFixed(2)} ms (${((unzipTime/totalTime)*100).toFixed(1)}%)`);
        console.log(`  2. Parse CSV files: ${parseTime.toFixed(2)} ms (${((parseTime/totalTime)*100).toFixed(1)}%)`);
        console.log(`  3. Parse stop_times:${stopTimesTime.toFixed(2)} ms (${((stopTimesTime/totalTime)*100).toFixed(1)}%)`);
        if (shapesTime > 0) {
          console.log(`  4. Parse shapes:    ${shapesTime.toFixed(2)} ms (${((shapesTime/totalTime)*100).toFixed(1)}%)`);
        }
        console.log(`  5. Build indexes:   ${indexTime.toFixed(2)} ms (${((indexTime/totalTime)*100).toFixed(1)}%)`);
        console.log(`  6. Enrich data:     ${enrichTime.toFixed(2)} ms (${((enrichTime/totalTime)*100).toFixed(1)}%)`);
        console.log('');
        console.log('Data summary:');
        console.log(`  Routes: ${routes.length.toLocaleString()}`);
        console.log(`  Trips: ${trips.length.toLocaleString()}`);
        console.log(`  Stops: ${stops.length.toLocaleString()}`);
        console.log(`  Stop times: ${Object.keys(stopTimesIndex).length.toLocaleString()} trips`);
        if (Object.keys(shapesIndex).length > 0) {
          console.log(`  Shapes: ${Object.keys(shapesIndex).length.toLocaleString()}`);
        }
        console.log('═══════════════════════════════════════════════');
        
        // Store metrics in state for optional display
        const perfMetrics = {
          totalTime: performance.now() - perfTimings.totalStart,
          unzipTime: perfTimings.unzipEnd - perfTimings.unzipStart,
          parseTime: perfTimings.parseEnd - perfTimings.parseStart,
          stopTimesTime: perfTimings.stopTimesEnd - perfTimings.stopTimesStart,
          shapesTime: perfTimings.shapesEnd > 0 ? perfTimings.shapesEnd - perfTimings.shapesStart : 0,
          indexTime: perfTimings.indexEnd - perfTimings.indexStart,
          enrichTime: perfTimings.enrichEnd - perfTimings.enrichStart,
          dataSummary: {
            routes: routes.length,
            trips: trips.length,
            stops: stops.length,
            stopTimes: Object.keys(stopTimesIndex).length,
            shapes: Object.keys(shapesIndex).length
          }
        };
        state.lastLoadMetrics = perfMetrics;

        state.loading=false; state.loadingStep=''; state.loadingProgress=0; state.loadingProgressPercent=0;
        render();
      } catch(err) {
        console.error('Error loading GTFS:', err);
        state.error = 'Błąd ładowania pliku GTFS: ' + err.message;
        state.loading=false; state.loadingProgress=0; state.loadingProgressPercent=0;
        render();
      }
    }

    function cancelParsing() {
      if (state.currentWorker) {
        try { state.currentWorker.terminate(); } catch(e){}
        state.currentWorker = null;
      }
      state.loading=false; state.loadingStep=''; state.loadingProgress=0; state.loadingProgressPercent=0;
      state.error = 'Parsowanie anulowane przez użytkownika';
      render();
    }

// ═══════════════════════════════════════════════════════════════
// 5. GTFS DATA PROCESSING
// ═══════════════════════════════════════════════════════════════
function canonicalFromCode(t) {
  if (t === null || t === undefined || t === '') return null;
  const n = parseInt(t, 10);
  if (isNaN(n)) return null;

  if (n === 0) return 'tram';
  if (n === 1) return 'metro';
  if (n === 2) return 'rail';
  if (n === 3) return 'bus';
  if (n === 4) return 'ferry';
  if (n === 5) return 'cable';
  if (n === 6) return 'gondola';
  if (n === 7) return 'funicular';
  if (n === 11) return 'trolleybus';
  if (n === 12) return 'monorail';
  if (n === 300) return 'rail';
  if (n >= 100 && n < 200) return 'rail';
  if (n >= 200 && n < 300) return 'coach';
  if (n >= 301 && n < 500) return 'metro';
  if (n >= 500 && n < 600) return 'ferry';
  if (n >= 700 && n < 800) return 'bus';
  if (n >= 800 && n < 900) return 'bus';
  if (n >= 900 && n < 1000) return 'tram';
  if (n >= 1100 && n < 1200) return 'air';
  if (n >= 1300 && n < 1400) return 'cable';
  return null;
}

function collectRouteType(route) {
  const reasons = [];
  if (!route || typeof route !== 'object') return { canonical: 'other', reasons: ['no-route'] };

  const rt = (route.route_type !== undefined && route.route_type !== '') ? route.route_type
           : (route.route_type_id !== undefined && route.route_type_id !== '') ? route.route_type_id
           : (route.type !== undefined && route.type !== '') ? route.type
           : '';

  if (rt !== '') {
    const byCode = canonicalFromCode(rt);
    if (byCode) {
      reasons.push(`code:${rt}->${byCode}`);
      return { canonical: byCode, reasons };
    } else {
      reasons.push(`code:${rt}`);
    }
  } else {
    reasons.push('no-code');
  }

  reasons.push('fallback:other');
  return { canonical: 'other', reasons: reasons };
}

    function getRouteTypeMeta(routeType) {
      const t = (routeType === null || routeType === undefined || routeType === '') ? null : parseInt(routeType, 10);
      const cm = state.customRouteTypeMap || {};
      if (t !== null && !isNaN(t)) {
        if (cm[t]) return cm[t];
        if (ROUTE_TYPE_META_EXTENDED[t]) return ROUTE_TYPE_META_EXTENDED[t];
        if (ROUTE_TYPE_META_BASIC[t]) return ROUTE_TYPE_META_BASIC[t];
      }
      return cm[3] || ROUTE_TYPE_META_BASIC[3] || { label:'Other', color:'#6b7280', weight:2 };
    }

function buildLogicalRoutes(routes, agenciesIndex) {
  const groupsMap = new Map();

  for (const r of routes) {
    if (!r) continue;

    const agencyKey = (r.agency_id || '').trim().toLowerCase();
    const shortRaw = (r.route_short_name || r.route_id || '').trim();
    const shortKey = shortRaw.toLowerCase();

    const catInfo = collectRouteType(r);
    const cat = (catInfo && catInfo.canonical) ? catInfo.canonical : 'other';

    const key = agencyKey + '||' + cat + '||' + shortKey;

    if (!groupsMap.has(key)) {
      groupsMap.set(key, {
        id: key,
        agency_id: r.agency_id || '',
        route_short_name: shortRaw || r.route_id || '',
        canonical_type: cat,
        members: [],
      });
    }
    groupsMap.get(key).members.push(r);
  }

  const logicalRoutes = Array.from(groupsMap.values());

  logicalRoutes.sort((a, b) => {
    const ca = CANONICAL_CATEGORIES[a.canonical_type]?.order ?? 999;
    const cb = CANONICAL_CATEGORIES[b.canonical_type]?.order ?? 999;
    if (ca !== cb) return ca - cb;

    const na = String(a.route_short_name || '').trim();
    const nb = String(b.route_short_name || '').trim();
    return na.localeCompare(nb, undefined, { numeric: true, sensitivity: 'base' });
  });

  return logicalRoutes;
}

function getLogicalRouteKeyFromGroup(group) {
  if (!group) return null;
  return group.id || (group.agency_id || '') + '::' + (group.route_short_name || '');
}

function generateAvailableDates(calendar, calendarDates) {
  // Helper: get day of week from GTFS date
  const getDayOfWeek = (gtfsDate) => {
    const y = parseInt(gtfsDate.substring(0, 4));
    const m = parseInt(gtfsDate.substring(4, 6)) - 1;
    const d = parseInt(gtfsDate.substring(6, 8));
    return DAY_NAMES[new Date(y, m, d).getDay()];
  };
  
  // Helper: increment GTFS date by 1 day
  const incrementGTFSDate = (gtfsDate) => {
    const y = parseInt(gtfsDate.substring(0, 4));
    const m = parseInt(gtfsDate.substring(4, 6)) - 1;
    const d = parseInt(gtfsDate.substring(6, 8));
    const date = new Date(y, m, d);
    date.setDate(date.getDate() + 1);
    return formatDateToGTFS(date);
  };
  
  // 🆕 KROK 1: Zbierz WSZYSTKIE możliwe daty (z calendar.txt)
  const allPossibleDates = new Set();
  
  calendar.forEach(cal => {
    if (!cal.start_date || !cal.end_date) return;
    
    let current = cal.start_date;
    while (current <= cal.end_date) {
      const dayOfWeek = getDayOfWeek(current);
      if (cal[dayOfWeek] === '1') {
        allPossibleDates.add(current);
      }
      current = incrementGTFSDate(current);
    }
  });
  
  // 🆕 KROK 2: Dla każdej daty, policz finalne serwisy
  const dateServiceCounts = new Map();
  
  allPossibleDates.forEach(dateStr => {
    const dayOfWeek = getDayOfWeek(dateStr);
    
    // Bazowe serwisy z calendar.txt
    const services = new Set();
    calendar.forEach(cal => {
      if (dateStr >= cal.start_date && dateStr <= cal.end_date && cal[dayOfWeek] === '1') {
        services.add(cal.service_id);
      }
    });
    
    // Zastosuj wyjątki z calendar_dates.txt
    calendarDates.forEach(cd => {
      if (cd.date === dateStr) {
        if (cd.exception_type === '1') services.add(cd.service_id);
        else if (cd.exception_type === '2') services.delete(cd.service_id);
      }
    });
    
    // Zapisz liczbę serwisów
    dateServiceCounts.set(dateStr, services.size);
  });
  
  // 🆕 KROK 3: Dodaj daty z calendar_dates.txt (exception_type=1)
  calendarDates.forEach(cd => {
    if (cd.exception_type === '1' && !dateServiceCounts.has(cd.date)) {
      // Nowa data nie w calendar.txt - policz serwisy
      const services = new Set();
      
      calendarDates.forEach(cd2 => {
        if (cd2.date === cd.date) {
          if (cd2.exception_type === '1') services.add(cd2.service_id);
        }
      });
      
      dateServiceCounts.set(cd.date, services.size);
    }
  });
  
  // 🆕 KROK 4: Filtruj - zostaw tylko daty z > 0 serwisów
  const finalDates = Array.from(dateServiceCounts.entries())
    .filter(([date, count]) => count > 0)
    .map(([date, count]) => date)
    .sort();
  
  // KROK 5: Formatuj do UI
  return finalDates.map(dateStr => {
    const date = parseGTFSDate(dateStr);
    if (!date) return { value: dateStr, label: dateStr };
    const dd = String(date.getDate()).padStart(2, '0');
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const yyyy = String(date.getFullYear());
    return { value: dateStr, label: `${dd}-${mm}-${yyyy}` };
  });
}
	  
function getServicesForDate(dateStr) {
  if (!state.gtfsData) return [];
  
  // Helper: get day of week from GTFS date string (YYYYMMDD)
  const getDayOfWeek = (gtfsDate) => {
    const y = parseInt(gtfsDate.substring(0, 4));
    const m = parseInt(gtfsDate.substring(4, 6)) - 1;
    const d = parseInt(gtfsDate.substring(6, 8));
    return new Date(y, m, d).getDay();
  };
  
  const dayOfWeek = DAY_NAMES[getDayOfWeek(dateStr)];
  const services = new Set();
  
  // ✅ String comparison instead of Date
  state.gtfsData.calendar.forEach(cal => {
    if (dateStr >= cal.start_date && dateStr <= cal.end_date && cal[dayOfWeek] === '1') {
      services.add(cal.service_id);
    }
  });
  
  // ✅ String equality check
  if (state.gtfsData.calendarDates) {
    state.gtfsData.calendarDates.forEach(cd => {
      if (cd.date === dateStr) {
        if (cd.exception_type === '1') services.add(cd.service_id);
        else if (cd.exception_type === '2') services.delete(cd.service_id);
      }
    });
  }
  
  return Array.from(services);
}

    /**
     * Get a representative weekday date (Monday-Friday)
     * Prefers FUTURE dates, falls back to PAST if no future weekday exists
     */
    function getWeekdayDate() {
      const today = parseGTFSDate(state.selectedDate);
      if (!today) return findDateForDayOfWeek(3); // Wednesday as fallback
      const currentDayOfWeek = today.getDay();
      
      // If today is a weekday (Mon-Fri), use it
      if (currentDayOfWeek >= 1 && currentDayOfWeek <= 5) return state.selectedDate;
      
      // Otherwise find nearest future or past weekday (prefer Wednesday)
      return findDateForDayOfWeek(3); // Wednesday
    }

    /**
     * Find a date for a specific day of week
     * Strategy: prefer FUTURE dates, fallback to PAST
     * @param {number} targetDayOfWeek - 0=Sunday, 1=Monday, ..., 6=Saturday
     * @returns {string|null} - GTFS date string (YYYYMMDD)
     */
function findDateForDayOfWeek(targetDayOfWeek) {
  if (!state.selectedDate) return null;
  
  // Helper: get day of week from GTFS date
  const getDayOfWeek = (gtfsDate) => {
    const y = parseInt(gtfsDate.substring(0, 4));
    const m = parseInt(gtfsDate.substring(4, 6)) - 1;
    const d = parseInt(gtfsDate.substring(6, 8));
    return new Date(y, m, d).getDay();
  };
  
  // Helper: add days to GTFS date
  const addDays = (gtfsDate, days) => {
    const y = parseInt(gtfsDate.substring(0, 4));
    const m = parseInt(gtfsDate.substring(4, 6)) - 1;
    const d = parseInt(gtfsDate.substring(6, 8));
    const date = new Date(y, m, d);
    date.setDate(date.getDate() + days);
    return formatDateToGTFS(date);
  };
  
  const currentDayOfWeek = getDayOfWeek(state.selectedDate);
  
  // If today matches, use it
  if (currentDayOfWeek === targetDayOfWeek) return state.selectedDate;
  
  // Try FUTURE dates first (next 7 days)
  for (let i = 1; i <= 7; i++) {
    const testDate = addDays(state.selectedDate, i);
    if (getDayOfWeek(testDate) === targetDayOfWeek) {
      return testDate;
    }
  }
  
  // Fallback to PAST dates (previous 7 days)
  for (let i = 1; i <= 7; i++) {
    const testDate = addDays(state.selectedDate, -i);
    if (getDayOfWeek(testDate) === targetDayOfWeek) {
      return testDate;
    }
  }
  
  return null;
}
    function calculateEaster(year) {
      const a = year % 19;
      const b = Math.floor(year / 100);
      const c = year % 100;
      const d = Math.floor(b / 4);
      const e = b % 4;
      const f = Math.floor((b + 8) / 25);
      const g = Math.floor((b - f + 1) / 3);
      const h = (19 * a + b - d - g + 15) % 30;
      const i = Math.floor(c / 4);
      const k = c % 4;
      const l = (32 + 2 * e + 2 * i - h - k) % 7;
      const m = Math.floor((a + 11 * h + 22 * l) / 451);
      const month = Math.floor((h + l - 7 * m + 114) / 31);
      const day = ((h + l - 7 * m + 114) % 31) + 1;
      return new Date(year, month - 1, day);
    }
    function getPolishHolidays(year) {
      const holidays = [];
      
      // Fixed-date holidays
      holidays.push({ date: `${year}0101`, name: 'Nowy Rok' });
      holidays.push({ date: `${year}0102`, name: 'Dzień po Nowym Roku' });
      holidays.push({ date: `${year}0501`, name: 'Święto Pracy' });
      holidays.push({ date: `${year}0815`, name: 'Wniebowzięcie Najświętszej Maryi Panny' });
      holidays.push({ date: `${year}1101`, name: 'Wszystkich Świętych' });
      holidays.push({ date: `${year}1224`, name: 'Wigilia' });
      holidays.push({ date: `${year}1225`, name: 'Boże Narodzenie' });
      holidays.push({ date: `${year}1226`, name: 'Drugi dzień Świąt Bożego Narodzenia' });
      holidays.push({ date: `${year}1231`, name: 'Sylwester' });
      
      const easter = calculateEaster(year);
      
      const maundyThursday = new Date(easter);
      maundyThursday.setDate(easter.getDate() - 3);
      holidays.push({
        date: formatDateToGTFS(maundyThursday),
        name: 'Wielki Czwartek'
      });
      
      const goodFriday = new Date(easter);
      goodFriday.setDate(easter.getDate() - 2);
      holidays.push({
        date: formatDateToGTFS(goodFriday),
        name: 'Wielki Piątek'
      });
      
      // Easter Sunday
      holidays.push({
        date: formatDateToGTFS(easter),
        name: 'Wielkanoc'
      });
      
      const easterMonday = new Date(easter);
      easterMonday.setDate(easter.getDate() + 1);
      holidays.push({
        date: formatDateToGTFS(easterMonday),
        name: 'Poniedziałek Wielkanocny'
      });
      
      const corpusChristi = new Date(easter);
      corpusChristi.setDate(easter.getDate() + 60);
      holidays.push({
        date: formatDateToGTFS(corpusChristi),
        name: 'Boże Ciało'
      });
      
      return holidays;
    }
    function findNearbyHolidays(referenceDateStr) {
      const refDate = parseGTFSDate(referenceDateStr);
      if (!refDate) return [];
      
      const year = refDate.getFullYear();
      const holidays = [
        ...getPolishHolidays(year),
        ...getPolishHolidays(year + 1)  // Include next year for edge cases
      ];
      
      const nearby = [];
      holidays.forEach(holiday => {
        const holidayDate = parseGTFSDate(holiday.date);
        if (!holidayDate) return;
        
        const diffMs = holidayDate - refDate;
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        
        // Include holidays only in the upcoming week (0 to 7 days in the future)
        if (diffDays >= 0 && diffDays <= 7) {
          nearby.push({
            ...holiday,
            dateObj: holidayDate,
            daysFromRef: diffDays
          });
        }
      });
      
      return nearby;
    }

    /**
     * Calculate Easter Sunday for a given year using Meeus/Jones/Butcher algorithm
     * @param {number} year - The year to calculate Easter for
     * @returns {Date} - Easter Sunday as a Date object
     */
    function calculateEaster(year) {
      const a = year % 19;
      const b = Math.floor(year / 100);
      const c = year % 100;
      const d = Math.floor(b / 4);
      const e = b % 4;
      const f = Math.floor((b + 8) / 25);
      const g = Math.floor((b - f + 1) / 3);
      const h = (19 * a + b - d - g + 15) % 30;
      const i = Math.floor(c / 4);
      const k = c % 4;
      const l = (32 + 2 * e + 2 * i - h - k) % 7;
      const m = Math.floor((a + 11 * h + 22 * l) / 451);
      const month = Math.floor((h + l - 7 * m + 114) / 31);
      const day = ((h + l - 7 * m + 114) % 31) + 1;
      return new Date(year, month - 1, day);
    }

    /**
     * Get all Polish holidays for a given year
     * @param {number} year - The year to get holidays for
     * @returns {Array} - Array of {date: 'YYYYMMDD', name: 'Holiday Name'}
     */
    function getPolishHolidays(year) {
      const holidays = [];
      
      // Fixed-date holidays
      holidays.push({ date: `${year}0101`, name: 'Nowy Rok' });
      holidays.push({ date: `${year}0102`, name: 'Dzień po Nowym Roku' });
      holidays.push({ date: `${year}0501`, name: 'Święto Pracy' });
      holidays.push({ date: `${year}0815`, name: 'Wniebowzięcie Najświętszej Maryi Panny' });
      holidays.push({ date: `${year}1101`, name: 'Wszystkich Świętych' });
      holidays.push({ date: `${year}1224`, name: 'Wigilia' });
      holidays.push({ date: `${year}1225`, name: 'Boże Narodzenie' });
      holidays.push({ date: `${year}1226`, name: 'Drugi dzień Świąt Bożego Narodzenia' });
      holidays.push({ date: `${year}1231`, name: 'Sylwester' });
      
      // Movable holidays based on Easter
      const easter = calculateEaster(year);
      
      // Maundy Thursday (3 days before Easter)
      const maundyThursday = new Date(easter);
      maundyThursday.setDate(easter.getDate() - 3);
      holidays.push({
        date: formatDateToGTFS(maundyThursday),
        name: 'Wielki Czwartek'
      });
      
      // Good Friday (2 days before Easter)
      const goodFriday = new Date(easter);
      goodFriday.setDate(easter.getDate() - 2);
      holidays.push({
        date: formatDateToGTFS(goodFriday),
        name: 'Wielki Piątek'
      });
      
      // Easter Sunday
      holidays.push({
        date: formatDateToGTFS(easter),
        name: 'Wielkanoc'
      });
      
      // Easter Monday
      const easterMonday = new Date(easter);
      easterMonday.setDate(easter.getDate() + 1);
      holidays.push({
        date: formatDateToGTFS(easterMonday),
        name: 'Poniedziałek Wielkanocny'
      });
      
      // Corpus Christi (60 days after Easter, always Thursday)
      const corpusChristi = new Date(easter);
      corpusChristi.setDate(easter.getDate() + 60);
      holidays.push({
        date: formatDateToGTFS(corpusChristi),
        name: 'Boże Ciało'
      });
      
      return holidays;
    }

    /**
     * Find holidays in the upcoming week from a reference date
     * @param {string} referenceDateStr - GTFS date string (YYYYMMDD)
     * @returns {Array} - Array of holiday objects that fall within the next 7 days
     */
function findNearbyHolidays(referenceDateStr) {
  // Helper: difference in days between two GTFS dates
  const daysDiff = (date1, date2) => {
    const y1 = parseInt(date1.substring(0, 4));
    const m1 = parseInt(date1.substring(4, 6)) - 1;
    const d1 = parseInt(date1.substring(6, 8));
    const y2 = parseInt(date2.substring(0, 4));
    const m2 = parseInt(date2.substring(4, 6)) - 1;
    const d2 = parseInt(date2.substring(6, 8));
    
    const ms1 = new Date(y1, m1, d1).getTime();
    const ms2 = new Date(y2, m2, d2).getTime();
    return Math.floor((ms2 - ms1) / (1000 * 60 * 60 * 24));
  };
  
  const y = parseInt(referenceDateStr.substring(0, 4));
  const holidays = [
    ...getPolishHolidays(y),
    ...getPolishHolidays(y + 1)
  ];
  
  const nearby = [];
  holidays.forEach(holiday => {
    const diffDays = daysDiff(referenceDateStr, holiday.date);
    
    // ✅ Include holidays only in the upcoming week (0 to 7 days in the future)
    if (diffDays >= 0 && diffDays <= 7) {
      nearby.push({
        ...holiday,
        dateObj: parseGTFSDate(holiday.date),  // Only for display
        daysFromRef: diffDays
      });
    }
  });
  
  return nearby;
}

function buildStationNameCache(stopsIndex) {
  if (stationNameToIdCache) return stationNameToIdCache;
  
  stationNameToIdCache = new Map();
  
  const parentStationIds = new Set();
  Object.values(stopsIndex).forEach(stop => {
    if (stop.parent_station && stop.parent_station.trim()) {
      parentStationIds.add(stop.parent_station.trim());
    }
  });
  
  // For each parent station, save the mapping name → stop_id
  parentStationIds.forEach(parentId => {
    const parentStop = stopsIndex[parentId];
    if (parentStop?.stop_name) {
      const normalizedName = parentStop.stop_name.trim().replace(/\s+/g, ' ');
      stationNameToIdCache.set(normalizedName, parentId);
    }
  });
  
  return stationNameToIdCache;
}

function clearStationCache() {
  stationNameToIdCache = null;
}

function getStationId(stopId, stopsIndex) {
  const stop = stopsIndex[stopId];
  if (!stop) return stopId;
  
  const parent = stop.parent_station;
  if (parent && parent.trim() !== '') {
    return parent.trim();
  }
  
  // PRIORYTET 2: Sprawdź czy nazwa pasuje do znanej stacji głównej
  if (stop.stop_name) {
    const normalizedName = stop.stop_name.trim().replace(/\s+/g, ' ');
    const cache = buildStationNameCache(stopsIndex);
    
    if (cache.has(normalizedName)) {
      return cache. get(normalizedName);
    }
    
    // Fallback: zwróć znormalizowaną nazwę
    return normalizedName;
  }
  
  return stopId;
}

function getStationIdWithPolicy(stopId, stopsIndex, allowedStationSet) {
  const stationId = getStationId(stopId, stopsIndex);
  if (!allowedStationSet || allowedStationSet.has(stationId)) return stationId;
  return stopId; // no merge if not allowed
}

// ═══════════════════════════════════════════════════════════════
// 6. ROUTE PROFILE & ANALYSIS
// ═══════════════════════════════════════════════════════════════
// === KROK 1: Budowa grafu trasy i profilu core dla logical route ===

// Note: This is used during classification to treat on-demand (2,3) as regular passenger (0)
function normalizePickupDropoffType(value) {
  const normalized = String(value || '0').trim();
  // 2 = phone agency, 3 = coordinate with driver → treat as 0 (passenger)
  if (normalized === '2' || normalized === '3') return '0';
  return normalized;
}

function calculateStopEdgeFrequency(trips, tripStopMaps, stopsIndex) {
  const edgeFrequency = {};
  const totalTrips = trips.length;
  
  if (totalTrips === 0) {
    return edgeFrequency;
  }
  
  trips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    
    // Convert stops to stations first
    const stationIds = stops.map(st => getStationId(st.stop_id, stopsIndex));
    
    // Count STATION-level edges
    for (let i = 0; i < stationIds.length - 1; i++) {
      const edge = stationIds[i] + '->' + stationIds[i + 1];
      edgeFrequency[edge] = (edgeFrequency[edge] || 0) + 1;
    }
  });
  
  // Normalize to frequencies (0-1 range)
  Object.keys(edgeFrequency).forEach(key => {
    edgeFrequency[key] = edgeFrequency[key] / totalTrips;
  });
  
  return edgeFrequency;
}

function computeCoreBoundaryFrequency(edgeFrequency, coreStops) {
  // For each non-core stop, compute max frequency of edges connecting to any core stop
  const boundaryFreq = new Map();
  const coreSet = new Set(coreStops);
  
  Object.entries(edgeFrequency).forEach(([edge, freq]) => {
    const [from, to] = edge.split('->');
    
    const fromIsCore = coreSet.has(from);
    const toIsCore = coreSet.has(to);
    
    if (fromIsCore && !toIsCore) {
      const current = boundaryFreq.get(to) || 0;
      boundaryFreq.set(to, Math.max(current, freq));
    } else if (!fromIsCore && toIsCore) {
      const current = boundaryFreq.get(from) || 0;
      boundaryFreq.set(from, Math.max(current, freq));
    }
  });
  
  return boundaryFreq;
}

function findLowFrequencyCandidates(edgeFrequency, allStationIds, threshold = 0.10) {
  const tier1 = new Set();  // <6%
  const tier2 = new Set();  // 6-10%
  
  allStationIds.forEach(stationId => {
    const edges = Object.keys(edgeFrequency).filter(e => 
      e.startsWith(stationId + '->') || e.endsWith('->' + stationId)
    );
    
    const allLowFreq = edges.every(e => edgeFrequency[e] < threshold);
    
    // Skip if not a low-frequency candidate or has no edges
    if (!allLowFreq || edges.length === 0) return;
    
    const maxEdgeFreq = Math.max(...edges.map(e => edgeFrequency[e]));
    
    // Classify into tiers
    if (maxEdgeFreq < 0.06) {
      tier1.add(stationId);
    } else if (maxEdgeFreq < threshold) {
      tier2.add(stationId);
    }
  });
  
  return { tier1, tier2 };
}

function isStopBetweenCore(stopId, trip, coreStart, coreEnd, stopsIndex) {
  let stopIdx = -1;
  let coreStartIdx = -1;
  let coreEndIdx = -1;
  
  // Convert to station IDs for comparison
  const stationId = getStationId(stopId, stopsIndex);
  
  for (let i = 0; i < trip.length; i++) {
    const tripStationId = getStationId(trip[i].stop_id, stopsIndex);
    if (tripStationId === stationId) stopIdx = i;
    if (tripStationId === coreStart) coreStartIdx = i;
    if (tripStationId === coreEnd) coreEndIdx = i;
  }
  
  // If stop is between coreStart and coreEnd → it's a passenger branch
  // Handle both forward and reverse directions
  if (coreStartIdx !== -1 && coreEndIdx !== -1 && stopIdx !== -1) {
    const minCoreIdx = Math.min(coreStartIdx, coreEndIdx);
    const maxCoreIdx = Math.max(coreStartIdx, coreEndIdx);
    return stopIdx > minCoreIdx && stopIdx < maxCoreIdx;
  }
  
  return false;
}

function classifyTailStopsRecursive(candidateTiers, trips, tripStopMaps, stopTimesIndex, coreStations, stopsIndex) {
  const nodeTypes = {};
  const coreSet = new Set(coreStations);
  
  if (!coreStations || coreStations.length === 0) {
    return nodeTypes;
  }
  
  const coreStart = coreStations[0];
  const coreEnd = coreStations[coreStations.length - 1];
  
  const tier1Candidates = candidateTiers.tier1 || new Set();
  const tier2Candidates = candidateTiers.tier2 || new Set();
  
  let changed = true;
  let iterations = 0;
  const MAX_ITERATIONS = 10;
  
  // Initialize core stations with 'core' classification
  coreStations.forEach(stationId => {
    nodeTypes[stationId] = 'core';
  });
  
  const classifyCandidate = (candidateId, fallbackType) => {
    // Skip if already classified
    if (nodeTypes[candidateId]) return false;
    
    let appearsBetweenCore = false;
    
    for (const trip of trips) {
      const stops = tripStopMaps[trip.trip_id] || [];
      if (isStopBetweenCore(candidateId, stops, coreStart, coreEnd, stopsIndex)) {
        appearsBetweenCore = true;
        break;
      }
    }
    
    if (appearsBetweenCore) {
      // Appears between core → passenger branch
      nodeTypes[candidateId] = 'passenger';
      return true;
    }
    
    let hasPickup1 = false;
    let hasDropoff1 = false;
    let hasNormalFlags = false;
    
    // Check all stops that belong to this station
    trips.forEach(trip => {
      const stopTimes = stopTimesIndex[trip.trip_id] || [];
      stopTimes.forEach(st => {
        const stationId = getStationId(st.stop_id, stopsIndex);
        if (stationId === candidateId) {
          const pickup = normalizePickupDropoffType(st.pickup_type);
          const dropoff = normalizePickupDropoffType(st.drop_off_type);
          
          if (pickup === '1' || dropoff === '1') {
            if (pickup === '1') hasPickup1 = true;
            if (dropoff === '1') hasDropoff1 = true;
          } else {
            hasNormalFlags = true;
          }
        }
      });
    });
    
    // If ANY occurrence has pickup=1 OR dropoff=1 → tail
    if (hasPickup1 || hasDropoff1) {
      nodeTypes[candidateId] = 'tail';
      return true;
    }
    
    // TEST 3: If all flags are 0/0 (after normalization) → recursive test
    if (hasNormalFlags) {
      const tripsWithCandidate = trips.filter(trip => {
        const stops = tripStopMaps[trip.trip_id] || [];
        return stops.some(s => getStationId(s.stop_id, stopsIndex) === candidateId);
      });
      
      let allTripsHaveOtherTails = true;
      
      for (const trip of tripsWithCandidate) {
        const stops = tripStopMaps[trip.trip_id] || [];
        
        const stopsOutsideCore = stops.filter(s => !coreSet.has(getStationId(s.stop_id, stopsIndex)));
        
        const hasTailOnRoute = stopsOutsideCore.some(s => {
          const stationId = getStationId(s.stop_id, stopsIndex);
          return stationId !== candidateId && nodeTypes[stationId] === 'tail';
        });
        
        if (!hasTailOnRoute) {
          allTripsHaveOtherTails = false;
          break;
        }
      }
      
      if (allTripsHaveOtherTails && tripsWithCandidate.length > 0) {
        // All trips with this stop have a tail → this is part of depot route
        nodeTypes[candidateId] = 'tail';
        return true;
      }
    }
    
    // FALLBACK: Apply tier-specific default
    if (!nodeTypes[candidateId]) {
      nodeTypes[candidateId] = fallbackType;
      return true; // Count as changed when we make any classification
    }
    
    return false;
  };
  
  while (changed && iterations < MAX_ITERATIONS) {
    changed = false;
    iterations++;
    
    // Process TIER 1 first (ultra-low, bias: TAIL)
    tier1Candidates.forEach(candidateId => {
      if (classifyCandidate(candidateId, 'tail')) {
        changed = true;
      }
    });
    
    // Then process TIER 2 (low, bias: PASSENGER)
    tier2Candidates.forEach(candidateId => {
      if (classifyCandidate(candidateId, 'passenger')) {
        changed = true;
      }
    });
  }
  
  return nodeTypes;
}

function getCurrentRouteProfile() {
  if (!state.selectedRoute || !state.gtfsData) return null;

  const dir = state.selectedDirection || '0';

  let key;
  if (state.selectedRouteGroup) {
    key = getLogicalRouteKeyFromGroup(state.selectedRouteGroup);
    if (!key) return null;
  } else {
    key = 'raw::' + (state.selectedRoute.route_id || '');
  }

  // Sprawdź czy pełny profile już istnieje (cache)
  if (state.routeProfiles[key] && state.routeProfiles[key][dir]) {
    return state.routeProfiles[key][dir];
  }

  // NIE MA - zbuduj teraz (lazy loading)
  return buildRouteProfileForCurrentSelection();
}

function buildRouteProfileForCurrentSelection() {
  if (!state.selectedRoute || !state.gtfsData) return null;

  const dir = state.selectedDirection || '0';

  // 1. Ustal klucz logicznej linii
  let key;
  let memberRoutes = [];

  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    key = getLogicalRouteKeyFromGroup(state.selectedRouteGroup);
    memberRoutes = state.selectedRouteGroup.members;
  } else {
    key = 'raw::' + (state.selectedRoute.route_id || '');
    memberRoutes = [state.selectedRoute];
  }

  if (!key) return null;

  // 2. Cache
  if (state.routeProfiles[key] && state.routeProfiles[key][dir]) {
    return state.routeProfiles[key][dir];
  }

  const { stopTimesIndex, tripsIndex, stopsIndex } = state.gtfsData;
  if (!stopTimesIndex || !tripsIndex || !stopsIndex) return null;

  // 3. Zbierz trips tej logical linii + kierunku (bez filtra daty)
  let routeIds = memberRoutes.map(r => r.route_id).filter(Boolean);
  if (!routeIds.length) return null;

  let allTrips = [];
  routeIds.forEach(rid => {
    const ts = tripsIndex[rid] || [];
    allTrips = allTrips.concat(ts);
  });

  allTrips = allTrips.filter(t => (t.direction_id || '0') === dir);
  if (!allTrips.length) return null;

  const CORE_THRESHOLD = 0.10; // 10%

  const stationEdgeFrequency = {};
  const allTripStationData = []; // będziemy potrzebować później

  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];
    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));
    
    const stationIds = sts.map(st => getStationId(st.stop_id, stopsIndex));
    
    // Zapisz dane tripu do późniejszego użycia
    allTripStationData.push({
      tripId: trip.trip_id,
      stationIds: stationIds,
      stopIds: sts.map(st => st.stop_id)
    });
    
    // Zlicz krawędzie
    for (let i = 0; i < stationIds.length - 1; i++) {
      const edge = stationIds[i] + '→' + stationIds[i + 1];
      stationEdgeFrequency[edge] = (stationEdgeFrequency[edge] || 0) + 1;
    }
  });

  const stationMaxOccurrence = new Map();
  allTripStationData.forEach(({ stationIds }) => {
    const stationCounts = new Map();
    stationIds.forEach(stationId => {
      stationCounts.set(stationId, (stationCounts.get(stationId) || 0) + 1);
    });
    stationCounts.forEach((count, stationId) => {
      const currentMax = stationMaxOccurrence.get(stationId) || 0;
      if (count > currentMax) {
        stationMaxOccurrence.set(stationId, count);
      }
    });
  });
  const stationMergeAllowed = new Set();
  stationMaxOccurrence.forEach((maxCount, stationId) => {
    if (maxCount <= 1) {
      stationMergeAllowed.add(stationId);
    }
  });

  const totalTripsCount = allTrips.length;
  const coreStationsSet = new Set();

  Object.entries(stationEdgeFrequency).forEach(([edge, count]) => {
    if (count / totalTripsCount >= CORE_THRESHOLD) {
      const [from, to] = edge.split('→');
      coreStationsSet.add(from);
      coreStationsSet.add(to);
    }
  });

  const tripCoreIndices = {};
  allTripStationData.forEach(({ tripId, stationIds, stopIds }) => {
    const isCore = stationIds.map(sid => coreStationsSet.has(sid));
    const firstCoreIdx = isCore.indexOf(true);
    const lastCoreIdx = isCore.lastIndexOf(true);
    
    tripCoreIndices[tripId] = {
      firstCoreIdx,
      lastCoreIdx,
      stationIds,
      stopIds
    };
  });

  // 4. Graf z stop_sequence + pickup/drop_off (pasażerski)
  const nodes = {}; // stationId → info
  const edges = {}; // "A->B" → info
  const tripCount = allTrips.length;
  const stationToStopIds = new Map(); // stationId → Set of stop_ids

  function edgeKey(a, b) {
    return a + '->' + b;
  }

  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];

    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => (parseInt(a.stop_sequence || '0', 10) - parseInt(b.stop_sequence || '0', 10)));

    // First pass: track all stop IDs for each station (for core expansion later)
    sts.forEach(st => {
      const stationId = getStationId(st.stop_id, stopsIndex);
      if (!stationToStopIds.has(stationId)) {
        stationToStopIds.set(stationId, new Set());
      }
      stationToStopIds.get(stationId).add(st.stop_id);
    });

    // Second pass: build passenger graph
    const passengerStops = [];
    sts.forEach(st => {
      const pickup = st.pickup_type;
      const dropoff = st.drop_off_type;

      // GTFS: 1 = no pickup/dropoff; 0 = normal
      if (pickup === '1' && dropoff === '1') {
        return; // stricte techniczne – pomijamy
      }

      // Use station_id for classification (merge platforms)
      const stationId = getStationId(st.stop_id, stopsIndex);
      
      passengerStops.push({ ...st, stationId });
      
      if (!nodes[stationId]) {
        const stop = stopsIndex[st.stop_id] || {};
        nodes[stationId] = {
          id: stationId,
          name: stop.stop_name || stationId,
          visitCount: 0,
          inDegree: 0,
          outDegree: 0,
        };
      }
      nodes[stationId].visitCount++;
    });

    for (let i = 0; i < passengerStops.length - 1; i++) {
      const a = passengerStops[i].stationId;
      const b = passengerStops[i + 1].stationId;
      const k = edgeKey(a, b);
      if (!edges[k]) {
        edges[k] = {
          from: a,
          to: b,
          count: 0,
          trips: new Set(),
        };
      }
      edges[k].count++;
      edges[k].trips.add(trip.trip_id);
      if (nodes[a]) nodes[a].outDegree++;
      if (nodes[b]) nodes[b].inDegree++;
    }
  });

  // 5. Wstępne „mocne” krawędzie jako kandydaci kręgosłupa
  const coreEdges = new Set();
  const minCoreFraction = 0.4; // heurystyka: ≥ 40% trips

  Object.values(edges).forEach(e => {
    const frac = e.count / tripCount;
    if (frac >= minCoreFraction) {
      coreEdges.add(edgeKey(e.from, e.to));
    }
  });

  // 6. Z coreEdges spróbuj zbudować najdłuższą ścieżkę
  const coreAdj = {};
  const coreInDeg = {};
  coreEdges.forEach(k => {
    const e = edges[k];
    if (!e) return;
    if (!coreAdj[e.from]) coreAdj[e.from] = [];
    coreAdj[e.from].push(e.to);
    coreInDeg[e.to] = (coreInDeg[e.to] || 0) + 1;
    if (!coreInDeg[e.from]) coreInDeg[e.from] = coreInDeg[e.from] || 0;
  });

  const coreStartCandidates = Object.keys(coreInDeg).filter(sid => (coreInDeg[sid] || 0) === 0);
  const visitedCore = new Set();
  let bestCorePath = [];

  function dfsCore(startId, path) {
    path.push(startId);
    visitedCore.add(startId);
    const nexts = coreAdj[startId] || [];
    if (!nexts.length) {
      if (path.length > bestCorePath.length) {
        bestCorePath = path.slice();
      }
    } else {
      nexts.forEach(nid => {
        if (!visitedCore.has(nid)) {
          dfsCore(nid, path);
        } else {
          if (path.length > bestCorePath.length) {
            bestCorePath = path.slice();
          }
        }
      });
    }
    path.pop();
    visitedCore.delete(startId);
  }

  if (coreStartCandidates.length) {
    coreStartCandidates.forEach(sid => dfsCore(sid, []));
  } else {
    Object.keys(coreAdj).forEach(sid => dfsCore(sid, []));
  }

  // bestCorePath contains station IDs; expand to stop IDs for backward compatibility
  const coreStationIds = bestCorePath.filter(sid => nodes[sid]);
  const coreStops = coreStationIds.flatMap(stationId => 
    Array.from(stationToStopIds.get(stationId) || [])
  );

  const coreStationIdsSet = new Set(coreStationIds);

  const edgeTypes = {};
  Object.keys(edges).forEach(k => {
    const e = edges[k];
    if (coreStationIdsSet.has(e.from) && coreStationIdsSet.has(e.to) && coreEdges.has(k)) {
      edgeTypes[k] = 'core';
    } else {
      edgeTypes[k] = 'noncore';
    }
  });

// --- 7. NEW: Recursive Tail Detection Algorithm ---
  
  // 7.1: Build tripStopMaps for the helper functions
  const tripStopMaps = {};
  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];
    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));
    tripStopMaps[trip.trip_id] = sts;
  });
  
  // 7.2: Calculate edge frequency at STATION level
  const edgeFrequency = calculateStopEdgeFrequency(allTrips, tripStopMaps, stopsIndex);
  
  // 7.3: Find all STATION IDs (not stop IDs)
  const allStationIds = new Set();
  allTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(st => {
      const stationId = getStationId(st.stop_id, stopsIndex);
      allStationIds.add(stationId);
    });
  });
  
  // 7.4: Find low-frequency candidates at STATION level
  const candidateTiers = findLowFrequencyCandidates(edgeFrequency, Array.from(allStationIds), 0.10);
  
  // 7.4b: Core-boundary frequency gating
  const boundaryFreq = computeCoreBoundaryFrequency(edgeFrequency, coreStationIds);
  const tier1Boundary = new Set();
  const tier2Boundary = new Set();
  
  boundaryFreq.forEach((freq, stationId) => {
    if (freq < 0.06) {
      tier1Boundary.add(stationId);
    } else if (freq < 0.10) {
      tier2Boundary.add(stationId);
    }
  });
  
  const mergedTiers = {
    tier1: new Set([...candidateTiers.tier1, ...tier1Boundary]),
    tier2: new Set([...candidateTiers.tier2, ...tier2Boundary])
  };
  
  // 7.5: Classify stations recursively with tier-specific fallbacks
  const stationNodeTypes = classifyTailStopsRecursive(
    mergedTiers,
    allTrips,
    tripStopMaps,
    stopTimesIndex,
    coreStationIds,
    stopsIndex
  );
  
  // 7.6: Expand station-level classifications to individual stops
  const nodeTypes = {};
  allTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(st => {
      const stationId = getStationId(st.stop_id, stopsIndex);
      const classification = stationNodeTypes[stationId] || 'passenger';
      nodeTypes[st.stop_id] = classification;
    });
  });
  
  // 7.7: Ensure all stops have a classification (fallback to 'passenger' for safety)
  // Using 'passenger' instead of 'noncore' ensures unclassified stops are visible
  allTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(st => {
      if (!nodeTypes[st.stop_id]) {
        nodeTypes[st.stop_id] = 'passenger';
      }
    });
  });

  // 8. Collect detailed stop metadata (pickup/drop_off types, positions in routes)
  const stopMetadata = {}; // stop_id → { hasPickup1: bool, hasDropOff1: bool, isOnDemand: bool, isFirstWithNoPickup: bool, isLastWithNoDropOff: bool }
  
  allTrips.forEach(trip => {
    const stsRaw = stopTimesIndex[trip.trip_id] || [];
    const sts = stsRaw
      .filter(st => st && st.stop_id)
      .sort((a, b) => (parseInt(a.stop_sequence || '0', 10) - parseInt(b.stop_sequence || '0', 10)));
    
    sts.forEach((st, i) => {
      const stId = st.stop_id;
      const pType = String(st.pickup_type || '0').trim();
      const dType = String(st.drop_off_type || '0').trim();
      
      if (!stopMetadata[stId]) {
        stopMetadata[stId] = {
          hasPickup1: false,
          hasDropOff1: false,
          isStrictlyTechnical: false,
          isOnDemand: false,
          isFirstWithNoPickup: false,
          isLastWithNoDropOff: false,
        };
      }
      
      const meta = stopMetadata[stId];
      
      // Zbierz informacje o pickup/drop_off types
      if (pType === '1') meta.hasPickup1 = true;
      if (dType === '1') meta.hasDropOff1 = true;
      if (pType === '1' && dType === '1') meta.isStrictlyTechnical = true;
      if (pType === '2' || pType === '3' || dType === '2' || dType === '3') {
        meta.isOnDemand = true;
      }
      
      // Sprawdź czy to pierwszy przystanek z pickup_type=1
      if (i === 0 && pType === '1') {
        meta.isFirstWithNoPickup = true;
      }
      
      // Sprawdź czy to ostatni przystanek z drop_off_type=1
      if (i === sts.length - 1 && dType === '1') {
        meta.isLastWithNoDropOff = true;
      }
    });
  });

  // 10. Process trips: detect passenger stops, classify service vs depot
  const processedTrips = {};
  
  // Threshold for short trip classification: trips with ≤2 passenger stops
  // use simpler classification (just check if any passenger stops exist)
  const SHORT_TRIP_THRESHOLD = 2;
  
  allTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    let pStops = [];
    let firstCoreIdx = -1;
    let lastCoreIdx = -1;
    
    // Find core boundaries (in RAW stops, not filtered)
    if (coreStops && coreStops.length > 0) {
      const coreStopsSet = new Set(coreStops);
      for (let i = 0; i < stops.length; i++) {
        if (coreStopsSet.has(stops[i].stop_id)) {
          if (firstCoreIdx === -1) firstCoreIdx = i;
          lastCoreIdx = i;
        }
      }
    }
    
    let hasPassenger = false;
    let hasPassengerInsideCore = false;
    
    // Filter stops: remove tail stops, build pStops
    for (let i = 0; i < stops.length; i++) {
      const st = stops[i];
      const sId = st.stop_id;
      
      // Use nodeTypes from profile (already computed at station-level!)
      const profileNodeType = nodeTypes[sId];
      
      let isStopTech = false;
      
      if (profileNodeType === 'tail') {
        // Depot/technical stop
        isStopTech = true;
      } else {
        // 'passenger' or 'core' or undefined → show as passenger
        isStopTech = false;
      }
      
      if (!isStopTech) {
        // Check for on-demand service
        const pType = st.pickup_type ? String(st.pickup_type).trim() : "0";
        const dType = st.drop_off_type ? String(st.drop_off_type).trim() : "0";
        const isOnDemand = (pType === "2" || pType === "3" || dType === "2" || dType === "3");
        
        pStops.push({ ...st, isOnDemand });
        hasPassenger = true;
        
        // Check if inside core segment
        if (firstCoreIdx !== -1 && lastCoreIdx !== -1 && i >= firstCoreIdx && i <= lastCoreIdx) {
          hasPassengerInsideCore = true;
        }
      }
    }
    
    // Classify as service or depot trip
    // Business rule:
    // - For trips with ≤SHORT_TRIP_THRESHOLD passenger stops: if ANY passenger stops exist, it's a service trip
    // - For trips with 3+ passenger stops: requires passenger stops BETWEEN first and last core stops
    //   (this distinguishes regular service from depot/yard movements that only touch core at endpoints)
    const isServiceTrip = pStops.length <= SHORT_TRIP_THRESHOLD 
      ? hasPassenger 
      : hasPassengerInsideCore;
    
    processedTrips[trip.trip_id] = {
      pStops: pStops,
      hasPassenger: hasPassenger,
      hasPassengerInsideCore: hasPassengerInsideCore,
      isServiceTrip: isServiceTrip,
      firstCoreIdx: firstCoreIdx,
      lastCoreIdx: lastCoreIdx
    };
  });

  // 11. Save profile to state
  if (!state.routeProfiles[key]) state.routeProfiles[key] = {};
  const profile = {
    key,
    direction: dir,
    tripCount,
    nodes,
    edges: Object.fromEntries(
      Object.entries(edges).map(([k, e]) => [k, { ...e, trips: Array.from(e.trips), type: edgeTypes[k] }])
    ),
    coreStops,
    nodeTypes,
    stopMetadata,
    coreStationsSet,
    tripCoreIndices,
    stationMergeAllowed,
    processedTrips,
    version: 3,
  };
  state.routeProfiles[key][dir] = profile;
  return profile;
}

function buildMasterList(sortedTrips, tripStopMaps, stopsIndex) {
  const profile = getCurrentRouteProfile();
  if (!profile || !profile.coreStops) {
    // This should never happen, but fail gracefully
    return [];
  }
  
  const coreStops = profile.coreStops;
  const allowedSet = profile.stationMergeAllowed;
  
  const stopsByStation = new Map();
  
  coreStops.forEach(stopId => {
    const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
    if (!stopsByStation.has(stationId)) {
      stopsByStation.set(stationId, []);
    }
    stopsByStation.get(stationId).push(stopId);
  });
  
  const getStationDisplayName = (stationId, stopIds) => {
    if (stopsIndex[stationId]?.stop_name) {
      return stopsIndex[stationId].stop_name;
    }
    const firstStop = stopsIndex[stopIds[0]];
    return firstStop?.stop_name || stationId;
  };

  const masterList = Array.from(stopsByStation.entries()).map(([stationId, stopIds]) => ({
    id: stopIds[0],
    name: getStationDisplayName(stationId, stopIds),
    stopIds: stopIds
  }));
  
  // Step 4: Add branch stops (stops outside core)
  const masterListStationIds = masterList.map(entry => {
    return getStationIdWithPolicy(entry.stopIds[0], stopsIndex, allowedSet);
  });
  
  // Process all trips to add stops not in core
  sortedTrips.forEach(trip => {
    const tripStops = tripStopMaps[trip.trip_id] || [];
    let lastMasterIdx = -1;
    
    tripStops.forEach(stopTime => {
      const stopId = stopTime.stop_id;
      const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
      
      let existingIdx = -1;
      for (let i = 0; i < masterListStationIds.length; i++) {
        if (masterListStationIds[i] === stationId) {
          existingIdx = i;
          break;
        }
      }
      
      if (existingIdx !== -1) {
        // Station already exists - add stop_id if not present
        if (!masterList[existingIdx].stopIds.includes(stopId)) {
          masterList[existingIdx].stopIds.push(stopId);
        }
        lastMasterIdx = existingIdx;
      } else {
        const newEntry = {
          id: stopId,
          name: getStationDisplayName(stationId, [stopId]),
          stopIds: [stopId]
        };
        
        const insertPos = lastMasterIdx + 1;
        masterList.splice(insertPos, 0, newEntry);
        masterListStationIds.splice(insertPos, 0, stationId);
        lastMasterIdx = insertPos;
      }
    });
  });
  
  return masterList;
}

function createTripMappings(sortedTrips, tripStopMaps, masterList) {
  return sortedTrips.map(trip => {
    const mapping = {}; let lastM = -1;
    const tripStops = tripStopMaps[trip.trip_id] || [];
    tripStops.forEach(s => {
      const sId = s.stop_id;
      for (let i = lastM+1;i<masterList.length;i++){
if ((masterList[i].stopIds && masterList[i].stopIds.includes(sId)) || 
    (!masterList[i].stopIds && masterList[i].id === sId)) {
  mapping[i] = s;
  lastM = i;
  break;
}
      }
    });
    return mapping;
  });
}

// ═══════════════════════════════════════════════════════════════
// 6B. CANONICAL MASTER LIST (STABLE ROW ORDER)
// ═══════════════════════════════════════════════════════════════
// 
// PURPOSE: Create a stable, canonical master list of stops (rows) per route/group and direction.
// The canonical list is built ONCE from ALL trips (no date filter, tail included) and cached.
// At render time, only row VISIBILITY is filtered - rows are never reordered.
// 
// ALGORITHM:
// 1. Use route profile's coreStops to define segments:
//    - Pre-core: stops before first core (variant starting points)
//    - Windows: stops between consecutive core stations (branches)
//    - Post-core: stops after last core (variant ending points)
// 2. For each segment, collect all stations that appear in that segment
// 3. Rank stations by median normalized position within the segment
// 4. Stable tie-breaking: name (alphabetical), then stop_id
// 5. Build canonical rows: pre-core, first core, [windows with branches], last core, post-core
// 6. Preserve nodeType (tail/passenger/core) from profile for each row
// 
// RENDERING:
// - Rows are filtered by: (a) tail toggle, (b) date (no departures = hidden)
// - Row order NEVER changes - only visibility
// - Columns (trips) are reordered separately using adjacent-swaps algorithm for chronological order
// 
// CACHE INVALIDATION:
// - On GTFS load (new data)
// - On route/group change
// - On direction change
// ═══════════════════════════════════════════════════════════════
function getCanonicalKeyForCurrentSelection() {
  if (!state.selectedRoute) return null;
  
  let key;
  if (state.selectedRouteGroup) {
    key = getLogicalRouteKeyFromGroup(state.selectedRouteGroup);
  } else {
    key = 'raw::' + (state.selectedRoute.route_id || '');
  }
  return key;
}

function buildCanonicalMasterList(profile, allTrips, stopTimesIndex, stopsIndex) {
  if (!profile || !profile.coreStops || profile.coreStops.length === 0) {
    return null; // Fallback to old behavior
  }

  const coreStops = profile.coreStops;
  const nodeTypes = profile.nodeTypes || {};
  const allowedSet = profile.stationMergeAllowed;
  
  const getStationDisplayName = (stationId, stopIds) => {
    if (stopsIndex[stationId]?.stop_name) {
      return stopsIndex[stationId].stop_name;
    }
    const firstStop = stopsIndex[stopIds[0]];
    return firstStop?.stop_name || stationId;
  };

  // Helper function to merge chunks with signature collision handling
  const mergeChunkStops = (existingChunk, newStops, signature) => {
    const originalLength = existingChunk.stops.length;
    if (originalLength !== newStops.length) {
      console.warn(`Signature collision detected for ${signature}: expected ${originalLength} stops, got ${newStops.length}`);
      // Extend chunk to accommodate all stops from both versions
      if (newStops.length > originalLength) {
        for (let idx = originalLength; idx < newStops.length; idx++) {
          existingChunk.stops.push({
            stationId: newStops[idx].stationId,
            name: newStops[idx].name,
            stopIds: [newStops[idx].stop_id]
          });
        }
      }
      // Note: If newStops.length < originalLength, we keep the existing stops
      // and only merge stopIds up to newStops.length
    }
    // Merge stopIds for all available positions in newStops
    for (let idx = 0; idx < newStops.length; idx++) {
      if (!existingChunk.stops[idx].stopIds.includes(newStops[idx].stop_id)) {
        existingChunk.stops[idx].stopIds.push(newStops[idx].stop_id);
      }
    }
  };

  const coreStationGroups = [];
  const seenStations = new Set();
  
  coreStops.forEach(stopId => {
    const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
    if (!seenStations.has(stationId)) {
      seenStations.add(stationId);
      coreStationGroups.push({
        stationId,
        stopIds: [stopId],
        isCore: true
      });
    } else {
      const group = coreStationGroups.find(g => g.stationId === stationId);
      if (group && !group.stopIds.includes(stopId)) {
        group.stopIds.push(stopId);
      }
    }
  });

  // Step 2: Build windows between consecutive core stations
  const windows = [];
  for (let i = 0; i < coreStationGroups.length - 1; i++) {
    windows.push({
      startCore: coreStationGroups[i],
      endCore: coreStationGroups[i + 1],
      chunks: new Map() // signature -> { stops: [], positions: [] }
    });
  }

  const preCore = new Map(); // signature -> { stops: [], positions: [] }
  const postCore = new Map(); // signature -> { stops: [], positions: [] }

  // Step 3: Process all trips to collect branch stations and their positions
  allTrips.forEach(trip => {
    const stopTimes = stopTimesIndex[trip.trip_id] || [];
    const sortedStops = stopTimes
      .filter(st => st && st.stop_id)
      .sort((a, b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));

    if (sortedStops.length === 0) return;

    const stopPositions = new Map();
    sortedStops.forEach((st, idx) => {
      stopPositions.set(st.stop_id, idx);
    });

    const corePositions = coreStationGroups.map(coreGroup => {
      for (const stopId of coreGroup.stopIds) {
        if (stopPositions.has(stopId)) {
          return { coreGroup, position: stopPositions.get(stopId), stopId };
        }
      }
      return null;
    }).filter(x => x !== null);

    const firstCorePos = corePositions.length > 0 
      ? Math.min(...corePositions.map(cp => cp.position))
      : -1;
    const lastCorePos = corePositions.length > 0
      ? Math.max(...corePositions.map(cp => cp.position))
      : -1;

    if (firstCorePos > 0) {
      // Collect stops before first core as a chunk
      const preCoreStops = [];
      for (let pos = 0; pos < firstCorePos; pos++) {
        const stopTime = sortedStops[pos];
        const stopId = stopTime.stop_id;
        const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
        
        // Skip if this is a core station
        if (seenStations.has(stationId)) continue;
        
        preCoreStops.push({
          stop_id: stopId,
          stationId: stationId,
          name: (stopsIndex[stopId] || {}).stop_name || stopId,
          position: pos
        });
      }
      
      if (preCoreStops.length > 0) {
        // Create signature for this sub-path
        const signature = preCoreStops.map(st => st.stationId).join('|');
        
        // Calculate normalized position of first stop
        const firstStopPos = preCoreStops[0].position;
        const normalizedPos = firstStopPos / firstCorePos;
        
        if (!preCore.has(signature)) {
          // Store stops with arrays for stop_ids (to handle multiple platforms)
          preCore.set(signature, {
            stops: preCoreStops.map(st => ({
              stationId: st.stationId,
              name: st.name,
              stopIds: [st.stop_id]
            })),
            positions: [normalizedPos]
          });
        } else {
          const chunk = preCore.get(signature);
          mergeChunkStops(chunk, preCoreStops, signature);
          chunk.positions.push(normalizedPos);
        }
      }
    }

    if (lastCorePos >= 0 && lastCorePos < sortedStops.length - 1) {
      const tripLength = sortedStops.length;
      
      // Collect stops after last core as a chunk
      const postCoreStops = [];
      for (let pos = lastCorePos + 1; pos < tripLength; pos++) {
        const stopTime = sortedStops[pos];
        const stopId = stopTime.stop_id;
        const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
        
        // Skip if this is a core station
        if (seenStations.has(stationId)) continue;
        
        postCoreStops.push({
          stop_id: stopId,
          stationId: stationId,
          name: (stopsIndex[stopId] || {}).stop_name || stopId,
          position: pos
        });
      }
      
      if (postCoreStops.length > 0) {
        // Create signature for this sub-path
        const signature = postCoreStops.map(st => st.stationId).join('|');
        
        // Calculate normalized position of first stop
        const firstStopPos = postCoreStops[0].position;
        const normalizedPos = (firstStopPos - lastCorePos) / (tripLength - lastCorePos);
        
        if (!postCore.has(signature)) {
          // Store stops with arrays for stop_ids (to handle multiple platforms)
          postCore.set(signature, {
            stops: postCoreStops.map(st => ({
              stationId: st.stationId,
              name: st.name,
              stopIds: [st.stop_id]
            })),
            positions: [normalizedPos]
          });
        } else {
          const chunk = postCore.get(signature);
          mergeChunkStops(chunk, postCoreStops, signature);
          chunk.positions.push(normalizedPos);
        }
      }
    }

    // For each window, collect branches as chunks
    for (let winIdx = 0; winIdx < windows.length; winIdx++) {
      const window = windows[winIdx];
      
      const startPos = corePositions.find(cp => cp.coreGroup === window.startCore);
      const endPos = corePositions.find(cp => cp.coreGroup === window.endCore);
      
      if (!startPos || !endPos || startPos.position >= endPos.position) {
        continue; // Skip if window not traversed in this trip
      }

      const windowLength = endPos.position - startPos.position;
      
      // Collect stops between cores as a chunk
      const windowStops = [];
      for (let pos = startPos.position + 1; pos < endPos.position; pos++) {
        const stopTime = sortedStops[pos];
        const stopId = stopTime.stop_id;
        const stationId = getStationIdWithPolicy(stopId, stopsIndex, allowedSet);
        
        // Skip if this is a core station
        if (seenStations.has(stationId)) continue;
        
        windowStops.push({
          stop_id: stopId,
          stationId: stationId,
          name: (stopsIndex[stopId] || {}).stop_name || stopId,
          position: pos
        });
      }
      
      if (windowStops.length > 0) {
        // Create signature for this sub-path
        const signature = windowStops.map(st => st.stationId).join('|');
        
        // Calculate normalized position of first stop
        const firstStopPos = windowStops[0].position;
        const normalizedPos = (firstStopPos - startPos.position) / windowLength;
        
        if (!window.chunks.has(signature)) {
          // Store stops with arrays for stop_ids (to handle multiple platforms)
          window.chunks.set(signature, {
            stops: windowStops.map(st => ({
              stationId: st.stationId,
              name: st.name,
              stopIds: [st.stop_id]
            })),
            positions: [normalizedPos]
          });
        } else {
          const chunk = window.chunks.get(signature);
          mergeChunkStops(chunk, windowStops, signature);
          chunk.positions.push(normalizedPos);
        }
      }
    }
  });

  const finalRows = [];
  
  const createSortedChunkEntries = (chunkMap) => {
    const chunkEntries = Array.from(chunkMap.entries()).map(([signature, data]) => {
      const sorted = data.positions.slice().sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      const median = sorted.length % 2 === 0
        ? (sorted[mid - 1] + sorted[mid]) / 2
        : sorted[mid];
      
      // Get the name of the first stop in the chunk for tie-breaking
      const firstStopName = data.stops[0].name;
      
      return {
        signature,
        stops: data.stops,
        median,
        name: firstStopName
      };
    });

    // Sort chunks by median, then by name, then by signature (stable)
    chunkEntries.sort((a, b) => {
      if (a.median !== b.median) return a.median - b.median;
      if (a.name !== b.name) return a.name.localeCompare(b.name);
      return a.signature.localeCompare(b.signature);
    });

    return chunkEntries;
  };

  const preCoreBranches = createSortedChunkEntries(preCore);
  preCoreBranches.forEach(chunk => {
    // Insert all stops from the chunk in order
    chunk.stops.forEach(stop => {
      finalRows.push({
        id: stop.stopIds[0],
        name: stop.name,
        stopIds: stop.stopIds,
        nodeType: nodeTypes[stop.stopIds[0]] || 'passenger'
      });
    });
  });
  
  // Add first core station
  finalRows.push({
    id: coreStationGroups[0].stopIds[0],
    name: getStationDisplayName(coreStationGroups[0].stationId, coreStationGroups[0].stopIds),
    stopIds: coreStationGroups[0].stopIds,
    nodeType: nodeTypes[coreStationGroups[0].stopIds[0]] || 'core'
  });

  // For each window, add sorted chunks, then the next core station
  windows.forEach((window, winIdx) => {
    const chunkEntries = createSortedChunkEntries(window.chunks);

    // Add chunks to final list (each chunk contains multiple stops in order)
    chunkEntries.forEach(chunk => {
      chunk.stops.forEach(stop => {
        finalRows.push({
          id: stop.stopIds[0],
          name: stop.name,
          stopIds: stop.stopIds,
          nodeType: nodeTypes[stop.stopIds[0]] || 'passenger'
        });
      });
    });

    const nextCore = window.endCore;
    finalRows.push({
      id: nextCore.stopIds[0],
      name: getStationDisplayName(nextCore.stationId, nextCore.stopIds),
      stopIds: nextCore.stopIds,
      nodeType: nodeTypes[nextCore.stopIds[0]] || 'core'
    });
  });

  const postCoreBranches = createSortedChunkEntries(postCore);
  postCoreBranches.forEach(chunk => {
    // Insert all stops from the chunk in order
    chunk.stops.forEach(stop => {
      finalRows.push({
        id: stop.stopIds[0],
        name: stop.name,
        stopIds: stop.stopIds,
        nodeType: nodeTypes[stop.stopIds[0]] || 'passenger'
      });
    });
  });

  return finalRows;
}
function ensureCanonicalMasterListForCurrentSelection() {
  const key = getCanonicalKeyForCurrentSelection();
  if (!key) return null;
  
  const dir = state.selectedDirection || '0';
  
  // Check cache
  if (state.canonicalMasterLists[key] && state.canonicalMasterLists[key][dir]) {
    return state.canonicalMasterLists[key][dir];
  }

  const profile = getCurrentRouteProfile();
  if (!profile || !profile.coreStops || profile.coreStops.length === 0) {
    return null; // Fallback
  }

  const { stopTimesIndex, tripsIndex, stopsIndex } = state.gtfsData;
  if (!stopTimesIndex || !tripsIndex || !stopsIndex) return null;

  let routeIds = [];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members.map(r => r.route_id).filter(Boolean);
  } else if (state.selectedRoute) {
    routeIds = [state.selectedRoute.route_id];
  }

  if (!routeIds.length) return null;

  let allTrips = [];
  routeIds.forEach(rid => {
    const ts = tripsIndex[rid] || [];
    allTrips = allTrips.concat(ts);
  });

  allTrips = allTrips.filter(t => (t.direction_id || '0') === dir);
  if (!allTrips.length) return null;

  const rows = buildCanonicalMasterList(profile, allTrips, stopTimesIndex, stopsIndex);
  
  if (!rows) return null;

  // Cache it
  if (!state.canonicalMasterLists[key]) {
    state.canonicalMasterLists[key] = {};
  }
  state.canonicalMasterLists[key][dir] = rows;

  return rows;
}
function invalidateCanonicalCacheForCurrentSelection() {
  const key = getCanonicalKeyForCurrentSelection();
  if (key && state.canonicalMasterLists[key]) {
    delete state.canonicalMasterLists[key];
  }
  // Also clear column order cache
  state.columnOrderCache = {};
}

// ═══════════════════════════════════════════════════════════════
// 7. TRIP & VARIANT PROCESSING
// ═══════════════════════════════════════════════════════════════
function getAllTripsForRoute() {
  if (!state.selectedRoute || !state.gtfsData || !state.selectedDate) return [];

  let routeIds = [state.selectedRoute.route_id];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members
      .map(r => r.route_id)
      .filter(Boolean);
  }

  let routeTrips = [];
  routeIds.forEach(rid => {
    const arr = state.gtfsData.tripsIndex[rid] || [];
    routeTrips = routeTrips.concat(arr);
  });

  routeTrips = routeTrips.filter(t => (t.direction_id || '0') === state.selectedDirection);
  const activeServices = getServicesForDate(state.selectedDate);
  return routeTrips.filter(t => activeServices.includes(t.service_id));
}

    function computeVariantsForRoute() {
      if (!state.selectedRoute || !state.gtfsData || !state.selectedDate) return null;
      const trips = getAllTripsForRoute();
      if (trips.length === 0) return null;
      const tripStopMaps = {};
      trips.forEach(trip => {
        const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
        stopTimes.sort((a,b) => parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0'));
        tripStopMaps[trip.trip_id] = stopTimes;
      });
      const patternToVariant = {}, tripToVariant = {}; let variantNum = 1;
      trips.forEach(trip => {
        const stops = tripStopMaps[trip.trip_id] || [];
        const patternKey = stops.map(st => st.stop_id).join(',');
        if (!patternToVariant[patternKey]) patternToVariant[patternKey] = variantNum++;
        tripToVariant[trip.trip_id] = patternToVariant[patternKey];
      });
      const variantDetails = {};
      Object.keys(patternToVariant).forEach(patternKey => {
        const vNum = patternToVariant[patternKey];
        const stopIds = patternKey ? patternKey.split(',') : [];
        variantDetails[vNum] = { stops: stopIds, stopDetails: stopIds.map(id => state.gtfsData.stopsIndex[id]) };
      });
      return { trips, tripStopMaps, tripToVariant, patternToVariant, variantDetails };
    }

function sortTripsByMostFrequentStop(trips, tripStopMaps, stopsIndex) {
  if (!trips || trips.length === 0) return trips;
  if (!stopsIndex) {
    // Fallback: chronological sort
    return trips.sort((a, b) => {
      const aStops = tripStopMaps[a.trip_id] || [];
      const bStops = tripStopMaps[b.trip_id] || [];
      let aTime = aStops[0]?.departure_time || "99:99:99";
      let bTime = bStops[0]?.departure_time || "99:99:99";
      if (String(aTime).match(/^\d:/)) aTime = "0" + aTime;
      if (String(bTime).match(/^\d:/)) bTime = "0" + bTime;
      return timeToMinutes(aTime) - timeToMinutes(bTime);
    });
  }
  
  // 1. Znajdź most frequent STATION (merged stop aware)
  const stationCounts = new Map();
  
  trips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(s => {
      const stationId = getStationId(s.stop_id, stopsIndex);
      stationCounts.set(stationId, (stationCounts.get(stationId) || 0) + 1);
    });
  });
  
  let maxCount = 0;
  let anchorStationId = null;
  stationCounts.forEach((count, stId) => {
    if (count > maxCount) {
      maxCount = count;
      anchorStationId = stId;
    }
  });
  
  if (!anchorStationId) {
    // Fallback: chronological
    return trips.sort((a, b) => {
      const aStops = tripStopMaps[a.trip_id] || [];
      const bStops = tripStopMaps[b.trip_id] || [];
      let aTime = aStops[0]?.departure_time || "99:99:99";
      let bTime = bStops[0]?.departure_time || "99:99:99";
      if (String(aTime).match(/^\d:/)) aTime = "0" + aTime;
      if (String(bTime).match(/^\d:/)) bTime = "0" + bTime;
      return timeToMinutes(aTime) - timeToMinutes(bTime);
    });
  }
  
  // 2. Znajdź wszystkie stop_ids dla anchor station (wszystkie perony, etc.)
  const anchorStopIds = [];
  Object.values(stopsIndex).forEach(stop => {
    if (getStationId(stop.stop_id, stopsIndex) === anchorStationId) {
      anchorStopIds.push(stop.stop_id);
    }
  });
  
  // 3. Podziel tripy na core (przez anchor) i non-core (bez anchor)
  const coreTrips = [];
  const nonCoreTrips = [];
  
  trips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    const hasAnchor = stops.some(s => anchorStopIds.includes(s.stop_id));
    
    if (hasAnchor) {
      coreTrips.push(trip);
    } else {
      nonCoreTrips.push(trip);
    }
  });
  
  // 4. Zbierz wszystkie stop_ids z core trips (wspólne przystanki)
  const coreStopIds = new Set();
  coreTrips.forEach(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    stops.forEach(s => {
      coreStopIds.add(s.stop_id);
    });
  });
  
  // 5. Sort core trips by anchorTime (ascending)
  const coreData = coreTrips.map(trip => {
    const stops = tripStopMaps[trip.trip_id] || [];
    
    let anchorTime = null;
    for (let i = 0; i < stops.length; i++) {
      if (anchorStopIds.includes(stops[i].stop_id)) {
        anchorTime = stops[i].departure_time || stops[i].arrival_time;
        break;
      }
    }
    
    // Normalize time
    if (anchorTime && String(anchorTime).match(/^\d:/)) {
      anchorTime = "0" + anchorTime;
    }
    
    if (!anchorTime) {
      anchorTime = "99:99:99";
    }
    
    return {
      trip,
      anchorTime,
      totalStops: stops.length
    };
  });
  
  // Sort core trips by anchor time
  coreData.sort((a, b) => {
    const timeDiff = timeToMinutes(a.anchorTime) - timeToMinutes(b.anchorTime);
    if (timeDiff !== 0) return timeDiff;
    return b.totalStops - a.totalStops;
  });
  
  // 6. Inject non-core trips into sorted core list chronologically
  const result = [...coreData.map(cd => cd.trip)]; // Start with sorted core trips
  
  nonCoreTrips.forEach(nonCoreTrip => {
    const nonCoreStops = tripStopMaps[nonCoreTrip.trip_id] || [];
    
    let insertionTime = null;
    let commonStopId = null;
    for (let i = 0; i < nonCoreStops.length; i++) {
      if (coreStopIds.has(nonCoreStops[i].stop_id)) {
        insertionTime = nonCoreStops[i].departure_time || nonCoreStops[i].arrival_time;
        commonStopId = nonCoreStops[i].stop_id;
        break;
      }
    }
    
    // Normalize time
    if (insertionTime && String(insertionTime).match(/^\d:/)) {
      insertionTime = "0" + insertionTime;
    }
    
    // Fallback: if no common stop, use first stop time
    if (!insertionTime) {
      insertionTime = nonCoreStops[0]?.departure_time || "99:99:99";
      if (String(insertionTime).match(/^\d:/)) {
        insertionTime = "0" + insertionTime;
      }
    }
    
    let insertIdx = result.length; // Default: append at end
    
    for (let i = 0; i < result.length; i++) {
      const coreTrip = result[i];
      const coreStops = tripStopMaps[coreTrip.trip_id] || [];
      
      let coreTimeAtCommon = null;
      if (commonStopId) {
        const coreStop = coreStops.find(s => s.stop_id === commonStopId);
        if (coreStop) {
          coreTimeAtCommon = coreStop.departure_time || coreStop.arrival_time;
          if (String(coreTimeAtCommon).match(/^\d:/)) {
            coreTimeAtCommon = "0" + coreTimeAtCommon;
          }
        }
      }
      
      // If core trip doesn't have the common stop, use its anchor time as fallback
      if (!coreTimeAtCommon) {
        for (let j = 0; j < coreStops.length; j++) {
          if (anchorStopIds.includes(coreStops[j].stop_id)) {
            coreTimeAtCommon = coreStops[j].departure_time || coreStops[j].arrival_time;
            if (String(coreTimeAtCommon).match(/^\d:/)) {
              coreTimeAtCommon = "0" + coreTimeAtCommon;
            }
            break;
          }
        }
      }
      
      // Insert before this core trip if non-core comes earlier
      if (coreTimeAtCommon && timeToMinutes(insertionTime) < timeToMinutes(coreTimeAtCommon)) {
        insertIdx = i;
        break;
      }
    }
    
    // Insert at found position
    result.splice(insertIdx, 0, nonCoreTrip);
  });
  
  return result;
}
const adjacentSwapOrderConfig = {
  voteThreshold: 4,
  marginMinutes: 2,
  maxPasses: 8
};
function adjacentSwapOrder(trips, tripMappings, visiblePassengerRowIndices, params) {
  if (!trips || trips.length <= 1) return trips;
  
  const { voteThreshold, marginMinutes, maxPasses } = params;
  
  const orderedTrips = trips.slice();
  const orderedMappings = tripMappings.slice();
  
  // Perform multiple passes of adjacent comparisons
  for (let pass = 0; pass < maxPasses; pass++) {
    let swapped = false;
    
    // Compare each adjacent pair
    for (let i = 0; i < orderedTrips.length - 1; i++) {
      let votesSwap = 0;
      let votesKeep = 0;
      
      // Count votes across visible passenger rows
      for (const rowIdx of visiblePassengerRowIndices) {
        const stopL = orderedMappings[i][rowIdx];
        const stopR = orderedMappings[i + 1][rowIdx];
        
        // Skip if either trip doesn't stop at this row
        if (!stopL || !stopR) continue;
        
        const timeL = stopL.departure_time || stopL.arrival_time;
        const timeR = stopR.departure_time || stopR.arrival_time;
        
        // Skip if either time is missing
        if (!timeL || !timeR) continue;
        
        const minutesL = timeToMinutes(timeL);
        const minutesR = timeToMinutes(timeR);
        
        // Vote to swap if left is significantly later than right
        if (minutesL > minutesR + marginMinutes) {
          votesSwap++;
        } else if (minutesR > minutesL + marginMinutes) {
          votesKeep++;
        }
        // Within margin: no vote
      }
      
      // Swap if we have enough votes
      if (votesSwap >= voteThreshold) {
        // Swap trips
        [orderedTrips[i], orderedTrips[i + 1]] = [orderedTrips[i + 1], orderedTrips[i]];
        // Swap corresponding mappings to stay in sync
        [orderedMappings[i], orderedMappings[i + 1]] = [orderedMappings[i + 1], orderedMappings[i]];
        swapped = true;
      }
    }
    
    // Early exit if no swaps were made in this pass
    if (!swapped) break;
  }
  
  return orderedTrips;
}
function findMostFrequentTripPattern(trips, stopTimesIndex, stopId, activeServices) {
  const patternCounts = new Map(); // klucz: "stop1,stop2,stop3...", wartość: count
  const patternToTrip = new Map(); // mapowanie pattern → przykładowy trip_id
  
  trips.forEach(trip => {
    if (!activeServices.includes(trip.service_id)) return;
    
    const stopTimes = stopTimesIndex[trip.trip_id] || [];
    // Sprawdź czy trip przechodzi przez nasz przystanek
    if (!stopTimes.some(st => st.stop_id === stopId)) return;
    
    const sorted = [...stopTimes].sort((a, b) => 
      parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0')
    );
    const pattern = sorted.map(st => st.stop_id).join(',');
    
    patternCounts.set(pattern, (patternCounts.get(pattern) || 0) + 1);
    if (!patternToTrip.has(pattern)) {
      patternToTrip.set(pattern, trip.trip_id);
    }
  });
  
  let maxCount = 0;
  let mostFrequentPattern = null;
  
  patternCounts.forEach((count, pattern) => {
    if (count > maxCount) {
      maxCount = count;
      mostFrequentPattern = pattern;
    }
  });
  
  if (!mostFrequentPattern) return null;
  
  const representativeTripId = patternToTrip.get(mostFrequentPattern);
  return {
    tripId: representativeTripId,
    stopIds: mostFrequentPattern.split(','),
    frequency: maxCount
  };
}

// ═══════════════════════════════════════════════════════════════
// 8. DIRECTION & HEADSIGN LOGIC
// ═══════════════════════════════════════════════════════════════
function getAvailableDirections() {
  if (!state.selectedRoute || !state.gtfsData) return [];

  let routeIds = [state.selectedRoute.route_id];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members
      .map(r => r.route_id)
      .filter(Boolean);
  }

  let routeTripsAll = [];
  routeIds.forEach(rid => {
    const arr = state.gtfsData.tripsIndex[rid] || [];
    routeTripsAll = routeTripsAll.concat(arr);
  });

  const dirs = Object.create(null);
  for (const t of routeTripsAll) {
    const dirId = String(t.direction_id === undefined || t.direction_id === null ? '0' : t.direction_id);
    if (!dirs[dirId]) dirs[dirId] = { id: dirId, rows: 0, tripIds: new Set(), byFinalStop: Object.create(null), trips: [] };
    dirs[dirId].rows++;
    if (t.trip_id) dirs[dirId].tripIds.add(t.trip_id);
    
    // Extract final stop name from stop_times
    const stopTimes = state.gtfsData.stopTimesIndex[t.trip_id] || [];
    const sorted = stopTimes.slice().sort((a, b) => a.stop_sequence - b.stop_sequence);
    const lastStopId = sorted[sorted.length - 1]?.stop_id;
    const lastStop = state.gtfsData.stopsIndex[lastStopId];
    const directionName = lastStop?.stop_name || '';
    
    if (directionName) dirs[dirId].byFinalStop[directionName] = (dirs[dirId].byFinalStop[directionName] || 0) + 1;
    dirs[dirId].trips.push(t);
  }

  const perDir = Object.keys(dirs).map(id => {
    const info = dirs[id];
    const finalStopEntries = Object.entries(info.byFinalStop).sort((a,b) => b[1] - a[1]);
    const top1Count = finalStopEntries.length ? finalStopEntries[0][1] : 0;
    const top1Label = finalStopEntries.length ? finalStopEntries[0][0] : '';
    const top2Count = finalStopEntries.length > 1 ? finalStopEntries[1][1] : 0;
    const top2Label = finalStopEntries.length > 1 ? finalStopEntries[1][0] : '';

    const commonFinalStop = finalStopEntries.length ? finalStopEntries[0][0] : '';
    let termini = '';
    let bestStops = null, bestLen = 0;
    for (const t of info.trips) {
      const sts = (state.gtfsData.stopTimesIndex && state.gtfsData.stopTimesIndex[t.trip_id]) || [];
      if (sts.length > bestLen) { bestLen = sts.length; bestStops = sts; }
    }
    if (bestStops && bestStops.length > 0) {
      const first = state.gtfsData.stopsIndex[bestStops[0].stop_id];
      const last  = state.gtfsData.stopsIndex[bestStops[bestStops.length - 1].stop_id];
      const firstName = first?.stop_name || bestStops[0].stop_id;
      const lastName  = last?.stop_name  || bestStops[bestStops.length - 1].stop_id;
      termini = (firstName && lastName && firstName !== lastName) ? `${firstName} – ${lastName}` : (lastName || firstName || '');
    }
    const fullName = commonFinalStop || termini || `Direction ${id}`;
    const score = (top1Count || 0) * 3 + (info.rows || 0);

    return {
      dir: id,
      rows: info.rows,
      distinctTripIds: info.tripIds.size,
      top1Count,
      top1Label,
      top2Count,
      top2Label,
      fullName,
      score,
      trips: info.trips
    };
  });

  perDir.sort((a,b) => (b.top1Count - a.top1Count) || (b.rows - a.rows));
  const heuristicResult = applyDirectionHeuristic(perDir, 1, 0.30);
  const labelsMap = heuristicResult.labels || {};

  const result = perDir.map((d, idx) => {
    const l = labelsMap[d.dir];
    const displayName = (l && l.display) ? l.display : (d.top1Label || d.fullName || d.dir);
    const safeDisplay = (displayName && String(displayName).trim()) ? displayName : (d.fullName || d.top1Label || d.dir);
    return { id: d.dir, name: safeDisplay, fullName: d.fullName, score: d.score };
  });

  return result;
}

function applyDirectionHeuristic(perDir, absDiff = 1, relRatio = 0.30) {
  const num = v => (typeof v === 'number' && !Number.isNaN(v)) ? v : 0;
  function closeEnough(x, y, absD, relR) {
    x = num(x); y = num(y);
    const diff = Math.abs(x - y);
    if (diff <= absD) return true;
    const denom = Math.max(Math.abs(x), Math.abs(y), 1);
    return (diff / denom) <= relR;
  }
  const list = Array.isArray(perDir) ? perDir.slice() : [];
  list.sort((a,b) => num(b.top1Count) - num(a.top1Count));
  const labels = {};
  const reason = { text: '', matched: null };
  if (list.length === 0) {
    reason.text = 'no directions';
    reason.matched = 'none';
    return { labels, reason };
  }
  if (list.length === 1) {
    const d = list[0];
    labels[d.dir] = { display: d.top1Label || '', mode: 'single' };
    reason.text = 'single direction';
    reason.matched = 'single';
    return { labels, reason };
  }
  const A = list[0];
  const B = list[1];
  const A_top1 = num(A.top1Count);
  const B_top1 = num(B.top1Count);
  const A_top2sum = A_top1 + num(A.top2Count);
  const B_top2sum = B_top1 + num(B.top2Count);
  if (closeEnough(A_top1, B_top1, absDiff, relRatio)) {
    labels[A.dir] = { display: A.top1Label || '', mode: 'top1-equal' };
    labels[B.dir] = { display: B.top1Label || '', mode: 'top1-equal' };
    reason.text = 'top1 equal';
    reason.matched = 'top1-equal';
    return { labels, reason };
  }
  function combinedLabel(d) {
    const left = d.top1Label || '';
    const right = d.top2Label || '';
    if (!left && !right) return '';
    if (!right) return left;
    if (!left) return right;
    return `${left} / ${right}`;
  }
  if (closeEnough(B_top2sum, A_top1, absDiff, relRatio)) {
    labels[A.dir] = { display: A.top1Label || '', mode: 'top1' };
    labels[B.dir] = { display: combinedLabel(B), mode: 'B_top2≈A_top1' };
    reason.text = 'B top2sum ≈ A top1';
    reason.matched = 'B_top2≈A_top1';
    return { labels, reason };
  }
  if (closeEnough(A_top2sum, B_top1, absDiff, relRatio)) {
    labels[A.dir] = { display: combinedLabel(A), mode: 'A_top2≈B_top1' };
    labels[B.dir] = { display: B.top1Label || '', mode: 'top1' };
    reason.text = 'A top2sum ≈ B top1';
    reason.matched = 'A_top2≈B_top1';
    return { labels, reason };
  }
  labels[A.dir] = { display: A.top1Label || '', mode: 'top1' };
  labels[B.dir] = { display: B.top1Label || '', mode: 'top1' };
  reason.text = 'default top1';
  reason.matched = 'default';
  return { labels, reason };
}

// ═══════════════════════════════════════════════════════════════
// 9. MAP RENDERING
// ═══════════════════════════════════════════════════════════════
    function resetMap() {
      if (window.leafletMap) {
        try { window.leafletMap.remove(); } catch(e) {}
        window.leafletMap = null;
        window.leafletFeatureGroup = null;
      }
    }

    function ensureMap(containerId = 'map-container', center=[51.94,13.88], zoom=11) {
      const mapContainer = $(containerId);
      if (!mapContainer) return null;
      if (!window.leafletMap) {
        mapContainer.innerHTML = '';
        const map = window.L.map(mapContainer).setView(center, zoom);
        window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution:'© OpenStreetMap contributors', maxZoom:19 }).addTo(map);
        window.leafletMap = map;
        window.leafletFeatureGroup = window.L.featureGroup().addTo(map);
      }
      return window.leafletMap;
    }

    // Helper function to create SVG icon with dynamic color
    function createSvgIcon(color, baseSize = 96) {
      const width = baseSize;
      const height = Math.round(baseSize * 1.41);
      
      const svgIcon = `
        <svg version="1.2" width="${width}" height="${height}" viewBox="0 0 21000 29700" preserveAspectRatio="xMidYMid" fill-rule="evenodd" xmlns="http://www.w3.org/2000/svg">
          <g>
            <path fill="#FFF" d="M10913 16775H8225v-5375h5375v5375h-2687z"/>
            <path fill="${color}" d="M10913 16098H8908v-4020h4009v4020h-2004z"/>
            <path fill="#FFF" d="M11460 13253c0 95-25 188-73 272-47 82-117 150-200 198-29 17-60 31-91 42v1520c0 31-9 62-25 89s-38 51-66 66c-28 16-61 24-92 24-32 0-63-8-91-24-28-15-51-39-67-66-15-27-24-58-24-89v-1520c-31-12-62-25-91-42-83-48-152-116-200-198-48-84-73-177-73-272s25-188 73-272c48-82 117-150 200-198 84-47 178-73 274-73s190 26 273 73c83 48 153 116 200 198 48 84 73 177 73 272z"/>
          </g>
        </svg>
      `;
      return window.L.divIcon({
        html: svgIcon,
        className: 'custom-svg-icon',
        iconSize: [width, height],
        iconAnchor: [width/2, height/2],
        popupAnchor: [0, -height/2 - 5]  // Popup appears above icon with 5px offset
      });
    }
    
    // Helper function to create circle marker (scales automatically with zoom)
    function createCircleMarker(lat, lon, color, radius = 6) {
      return window.L.circleMarker([lat, lon], {
        radius: radius,
        fillColor: color,
        color: '#fff',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.8
      });
    }

async function generateLineGeometry(stopDetails, routeType) {
  // Generate straight line route from stops
  if (!Array.isArray(stopDetails) || stopDetails.length < 2) return [];
  
  const coordinates = stopDetails
    .map(s => [parseFloat(s.lat || s.stop_lat), parseFloat(s.lon || s.stop_lon)])
    .filter(([lat, lon]) => !isNaN(lat) && !isNaN(lon));
  
  return coordinates;
}

async function generateHybridLineGeometry(stops, shapeId, routeType) {
  if (!stops || stops.length < 2) return [];
  
  const shapesIndex = state.gtfsData?.shapesIndex;
  
  // If no shapes.txt, use straight lines
  if (!shapeId || !shapesIndex || !shapesIndex[shapeId]) {
    return await generateLineGeometry(stops, routeType);
  }
  
  const shapePoints = shapesIndex[shapeId];
  
  const coverage = calculateShapeCoverage(stops, shapePoints);
  
  // If good coverage (>70%), use hybrid approach
  if (coverage.percentage >= 0.7) {
    return fillShapeGaps(stops, shapePoints, coverage.nearbyStops);
  }
  
  // Poor coverage - use straight lines
  return await generateLineGeometry(stops, routeType);
}

async function updateMap() {
  const mapContainer = $('map-container');
  if (!mapContainer || !state.selectedRoute) return;
  
  const variantsData = state._lastVariants || computeVariantsForRoute();

  let routeIds = [state.selectedRoute.route_id];
  if (state.selectedRouteGroup && Array.isArray(state.selectedRouteGroup.members)) {
    routeIds = state.selectedRouteGroup.members
      .map(r => r.route_id)
      .filter(Boolean);
  }

  let routeTripsAll = [];
  routeIds.forEach(rid => {
    const arr = state.gtfsData.tripsIndex[rid] || [];
    routeTripsAll = routeTripsAll.concat(arr);
  });

  let initialCenter = [51.94, 13.88]; // Default fallback
  let initialZoom = 11;
  
  if (variantsData && variantsData.variantDetails) {
    let variantId = state.selectedVariant;
    if (!variantsData.variantDetails[variantId]) {
      const keys = Object.keys(variantsData.variantDetails);
      variantId = keys.length ? keys[0] : variantId;
    }
    const sel = variantsData.variantDetails[variantId];
    if (sel && Array.isArray(sel.stopDetails) && sel.stopDetails.length > 0) {
      const validStops = sel.stopDetails.filter(s => s && s.stop_lat && s.stop_lon && !isNaN(parseFloat(s.stop_lat)) && !isNaN(parseFloat(s.stop_lon)));
      if (validStops.length > 0) {
        const lats = validStops.map(s => parseFloat(s.stop_lat));
        const lons = validStops.map(s => parseFloat(s.stop_lon));
        const centerLat = (Math.min(...lats) + Math.max(...lats)) / 2;
        const centerLon = (Math.min(...lons) + Math.max(...lons)) / 2;
        initialCenter = [centerLat, centerLon];
        initialZoom = 13;
      }
    }
  }
  
  ensureMap('map-container', initialCenter, initialZoom);
  const map = window.leafletMap;
  const fg = window.leafletFeatureGroup;
  
  // Wyczyść tylko warstwy
  fg.clearLayers();

  const routeColor = getRouteTypeMeta(state.selectedRoute?.route_type).color || '#3b82f6';
  const routeType = state.selectedRoute.route_type;
  
const addMarker = (lat, lon, name, color) => {
  if (isNaN(lat) || isNaN(lon)) return;
  fg.addLayer(window.L.marker([lat, lon], { 
      icon: createSvgIcon(color || '#3b82f6')
    }).bindPopup(name || ''));
  };
  
  let drawnVariantCoords = [];
  if (variantsData && variantsData.variantDetails) {
    let variantId = state.selectedVariant;
    if (!variantsData.variantDetails[variantId]) {
      const keys = Object.keys(variantsData.variantDetails);
      variantId = keys.length ? keys[0] : variantId;
    }
const sel = variantsData.variantDetails[variantId];
if (sel && Array.isArray(sel.stopDetails) && sel.stopDetails.length > 0) {
  let lineGeometry = null;
  
  // ===== HIERARCHY FOR ROUTE DRAWING =====
  // 1. Try shapes.txt (best quality - from GTFS)
  if (state.gtfsData. shapesIndex && Object.keys(state.gtfsData.shapesIndex).length > 0) {
    const variantTrips = variantsData.trips.filter(t => variantsData.tripToVariant[t.trip_id] === variantId);
    
    if (variantTrips. length > 0) {
      const shapeId = variantTrips[0].shape_id;
      
      if (shapeId && state.gtfsData. shapesIndex[shapeId]) {
        lineGeometry = state.gtfsData.shapesIndex[shapeId];
      }
    }
  }
  
  // 2. Final fallback: Simple straight lines between stops
  if (!lineGeometry) {
    lineGeometry = sel.stopDetails
      .map(s => [parseFloat(s.stop_lat), parseFloat(s.stop_lon)])
      .filter(([lat, lon]) => !isNaN(lat) && !isNaN(lon));
  }

  if (lineGeometry && lineGeometry.length > 1) {
    fg.addLayer(window.L.polyline(lineGeometry, { 
      color: routeColor, 
      weight: 5,
      opacity: 0.9,
      smoothFactor: 0.5 
    }));
  }

  // Dodaj markery przystanków...
      sel.stopDetails.forEach(s => {
        if (s && s.stop_lat && s.stop_lon) {
          const lat = parseFloat(s.stop_lat), lon = parseFloat(s.stop_lon);
          if (!isNaN(lat) && !isNaN(lon)) {
            addMarker(lat, lon, s.stop_name, routeColor);
            drawnVariantCoords.push([lat, lon]);
          }
        }
      });
    }
  }
  
  // Fallback jeśli nie ma wariantu
  if (drawnVariantCoords.length < 2) {
    const allStopIds = new Set();
    routeTripsAll.forEach(trip => {
      const sts = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
      sts.forEach(st => { if (st && st.stop_id) allStopIds.add(st.stop_id); });
    });
    const allCoords = [];
    allStopIds.forEach(stopId => {
      const stop = state.gtfsData.stopsIndex[stopId];
      if (stop && stop.stop_lat && stop.stop_lon) {
        const lat = parseFloat(stop.stop_lat), lon = parseFloat(stop.stop_lon);
        if (!isNaN(lat) && !isNaN(lon)) {
          addMarker(lat, lon, stop.stop_name, routeColor);
          allCoords.push([lat, lon]);
        }
      }
    });
    if (allCoords.length > 1) fg.addLayer(window.L.polyline(allCoords, { color:'#9ca3af', weight:2, opacity:0.6 }));
  }
  
  if (fg.getLayers().length === 0) {
    map.remove();
    resetMap();
    mapContainer.innerHTML = '<div class="p-4 text-gray-500">No map data available for this route</div>';
    return;
  }
  
  let bounds = fg.getBounds();
  if (!bounds || !bounds.isValid || (bounds.getNorthEast && bounds.getSouthWest &&
      Math.abs(bounds.getNorthEast().lat - bounds.getSouthWest().lat) < 0.0005 &&
      Math.abs(bounds.getNorthEast().lng - bounds.getSouthWest().lng) < 0.0005)) {
    const firstLayer = fg.getLayers()[0];
    let p = null;
    if (firstLayer && firstLayer.getLatLng) p = firstLayer.getLatLng();
    if (p) {
      const delta = 0.005;
      bounds = window.L.latLngBounds([[p.lat - delta, p.lng - delta], [p.lat + delta, p.lng + delta]]);
    }
  }
  
  try {
    if (bounds && bounds.isValid && !(bounds.getNorthEast().equals(bounds.getSouthWest()))) {
      map.fitBounds(bounds, { padding: [20,20], maxZoom: 18 });
    } else {
      const layer = fg.getLayers()[0];
      if (layer && layer.getLatLng) map.setView(layer.getLatLng(), 13);
    }
  } catch (err) {
    // Ignore map fit errors - they don't prevent map from displaying
  }
}

async function renderStopDetailMap(stopId, selectedDate, filteredRouteIds = []) {
  const mapContainer = $('stop-detail-map');
  if (!mapContainer) return;
  
  const stop = state.gtfsData.stopsIndex[stopId];
  if (!stop || !stop.stop_lat || !stop.stop_lon) {
    mapContainer.innerHTML = '<div class="p-4 text-gray-500">Brak danych lokalizacyjnych dla przystanku</div>';
    return;
  }
  
  const lat = parseFloat(stop.stop_lat);
  const lon = parseFloat(stop.stop_lon);
  if (isNaN(lat) || isNaN(lon)) {
    mapContainer.innerHTML = '<div class="p-4 text-gray-500">Nieprawidłowe współrzędne przystanku</div>';
    return;
  }
  
  const result = collectRoutesForStop(stopId, selectedDate, []);
  
  const routesData = result.routes || [];
  
  // Initialize map only once
  if (!state.stopDetailMapInitialized) {
    mapContainer.innerHTML = '';
    const map = window.L.map(mapContainer).setView([lat, lon], 14);
    window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);
    
    state.stopDetailMapInstance = map;
    state.stopDetailMapLayers = {};
    
    const allBounds = [];
    
    // Create layers for each route
    for (const routeData of routesData) {
      const { route, stops, color, direction, shapeId } = routeData;
      const layerKey = `${route.route_id}_${direction}`;
      
      const layer = window.L.featureGroup();
      
      const mainRouteStops = stops.filter(s => s.type === 'core' || s.type === 'branch');
      
      if (mainRouteStops.length > 1) {
        let lineGeometry = null;
        
        // Use hybrid approach: shapes.txt + gap filling, or straight lines
        lineGeometry = await generateHybridLineGeometry(mainRouteStops, shapeId, route.route_type);

        // Draw polyline if we have at least 2 points
        if (Array.isArray(lineGeometry) && lineGeometry.length > 1) {
          window.L.polyline(lineGeometry, {
            color: color,
            weight: 3,
            opacity: 0.7,
            smoothFactor: 0.5
          }).addTo(layer);
        }
      }

      // Add main route stops as small markers and collect bounds
      mainRouteStops.forEach(s => {
        if (!s || isNaN(parseFloat(s.lat)) || isNaN(parseFloat(s.lon))) return;
        const sLat = parseFloat(s.lat);
        const sLon = parseFloat(s.lon);
        window.L.marker([sLat, sLon], {
          icon: createSvgIcon(color)
        }).addTo(layer).bindPopup(s.name);

        allBounds.push([sLat, sLon]);
      });
      
      // Store layer and add to map
      state.stopDetailMapLayers[layerKey] = layer;
      layer.addTo(map);
    }
    
    // Add main stop (selected) as larger marker
    window.L.marker([lat, lon], {
      icon: createSvgIcon('#ef4444')
    }).addTo(map).bindPopup(`<b>${stop.stop_name}</b>`).openPopup();
    
    allBounds.push([lat, lon]);
    
    // Fit view to all points once
    if (allBounds.length > 0) {
      map.fitBounds(allBounds, { padding: [30, 30], maxZoom: 16 });
    }
    
    state.stopDetailMapInitialized = true;
  }
} // << zamknięcie funkcji renderującej mapę szczegółową

function filterStopDetailMapLayers(filteredRouteIds = []) {
  if (!state.stopDetailMapInstance || !state.stopDetailMapInitialized) {
    return;
  }

  const filterIds = (filteredRouteIds || []).map(String);
  const map = state.stopDetailMapInstance;

  Object.entries(state.stopDetailMapLayers).forEach(([layerKey, layer]) => {
    const routeId = layerKey.split('_')[0]; // Extract route_id from "route_id_direction"
    const shouldShow = filterIds.length === 0 || filterIds.includes(routeId);

    if (shouldShow) {
      if (!map.hasLayer(layer)) {
        layer.addTo(map);
      }
    } else {
      if (map.hasLayer(layer)) {
        map.removeLayer(layer);
      }
    }
  });
}

// ═══════════════════════════════════════════════════════════════
// 10. SHARED UI HELPERS
// ═══════════════════════════════════════════════════════════════
    function findRouteById(routeId) {
      return (state.gtfsData && state.gtfsData.routes || []).find(r => String(r.route_id) === String(routeId));
    }

    function routeBadgeHtml(route, meta) {
      const label = escapeHtml(route.route_short_name || route.route_id || '');
      const color = (meta && meta.color) || '#3b82f6';
      return `<a href="#" class="route-link" data-route-id="${escapeHtml(route.route_id)}" style="text-decoration:none;">
        <span
          style="
            display:inline-block;
            padding:2px 8px;
            font-weight:600;
            border-radius:4px;
            background:${color}20;
            color:${color};
            border-left:3px solid ${color};
          "
        >
          ${label}
        </span>
      </a>`;
    }

// ═══════════════════════════════════════════════════════════════
// 11. UI RENDERING - ROUTES VIEW
// ═══════════════════════════════════════════════════════════════
function renderRouteTable() {
  const container = $('routes-tbody');
  if (!container || !state.gtfsData) return;
  container.innerHTML = '';

  const logicalRoutes = state.gtfsData.logicalRoutes || [];
  const baseRoutes = (state.gtfsData.routes || []).slice();

  function reprOf(group) {
    return (group && group.members && group.members[0]) || null;
  }

function labelOf(group) {
    const r = reprOf(group);
    if (!r) return group?.route_short_name || '';
    return r.route_short_name || r.route_id || group.route_short_name || '';
}

  function sortGroupsByRouteId(arr) {
    return arr.slice().sort((a, b) => {
      const la = String(labelOf(a) || '').trim();
      const lb = String(labelOf(b) || '').trim();
      return la.localeCompare(lb, undefined, { numeric: true, sensitivity: 'base' });
    });
  }

  function sortRoutesById(routes) {
    return routes.slice().sort((a, b) => {
      const la = String(a.route_short_name || a.route_id || '').trim();
      const lb = String(b.route_short_name || b.route_id || '').trim();
      return la.localeCompare(lb, undefined, { numeric: true, sensitivity: 'base' });
    });
  }

  // === TRYB 1: LOGICAL (DOMYŚLNY) – jedna siatka z logicznymi liniami ===
  if (state.routeGroupMode === 'logical') {
    if (!logicalRoutes.length) return;

    const grid = document.createElement('div');
    grid.className = 'routes-grid';

    sortGroupsByRouteId(logicalRoutes).forEach(group => {
      const repr = reprOf(group);
      if (!repr) return;
      const metaRt = getRouteTypeMeta(repr.route_type);
      const btn = document.createElement('button');
      btn.className = 'route-card';
      btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

const label = labelOf(group);

btn.innerHTML = `
  <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
    <div style="font-weight:700;">${escapeHtml(label)}</div>
  </div>
`;

      btn.onclick = () => {
        state.selectedRouteGroup = group;
        selectRoute(repr);
      };

      grid.appendChild(btn);
    });

    container.appendChild(grid);
    return;
  }

  // === TRYB 2: SERVICE_TYPE – logiczne linie zgrupowane wg canonical_type ===
  if (state.routeGroupMode === 'service_type') {
    if (!logicalRoutes.length) return;

    const groupsByCat = new Map();

    logicalRoutes.forEach(group => {
      const repr = reprOf(group);
      const cat = repr ? (collectRouteType(repr).canonical || 'other') : 'other';
      if (!groupsByCat.has(cat)) groupsByCat.set(cat, []);
      groupsByCat.get(cat).push(group);
    });

    const catKeys = Array.from(groupsByCat.keys()).sort((a, b) => {
      const oa = (CANONICAL_CATEGORIES[a] && CANONICAL_CATEGORIES[a].order) || 999;
      const ob = (CANONICAL_CATEGORIES[b] && CANONICAL_CATEGORIES[b].order) || 999;
      if (oa !== ob) return oa - ob;
      const la = (CANONICAL_CATEGORIES[a] && CANONICAL_CATEGORIES[a].label) || String(a);
      const lb = (CANONICAL_CATEGORIES[b] && CANONICAL_CATEGORIES[b].label) || String(b);
      return la.localeCompare(lb, undefined, { sensitivity: 'base' });
    });

    catKeys.forEach(cat => {
      const titleEl = document.createElement('div');
      titleEl.className = 'agency-title';
      titleEl.textContent = (CANONICAL_CATEGORIES[cat] && CANONICAL_CATEGORIES[cat].label) || cat || 'Other';
      container.appendChild(titleEl);

      const grid = document.createElement('div');
      grid.className = 'routes-grid';

      const list = sortGroupsByRouteId(groupsByCat.get(cat) || []);
      list.forEach(group => {
        const repr = reprOf(group);
        if (!repr) return;
        const metaRt = getRouteTypeMeta(repr.route_type);
        const btn = document.createElement('button');
        btn.className = 'route-card';
        btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

const label = labelOf(group);

btn.innerHTML = `
  <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
    <div style="font-weight:700;">${escapeHtml(label)}</div>
  </div>
`;

        btn.onclick = () => {
          state.selectedRouteGroup = group;
          selectRoute(repr);
        };

        grid.appendChild(btn);
      });

      grid.style.marginBottom = '28px';
      container.appendChild(grid);
    });

    return;
  }

  // === TRYB 3: AGENCY – logiczne linie zgrupowane wg przewoźnika ===
  if (state.routeGroupMode === 'agency') {
    if (!logicalRoutes.length) return;

    const byAgency = new Map();

    logicalRoutes.forEach(group => {
      const repr = reprOf(group);
      const agencyId = repr?.agency_id || group.agency_id || '';
      const agencyName = agencyId && state.gtfsData.agenciesIndex[agencyId]
        ? (state.gtfsData.agenciesIndex[agencyId].agency_name || agencyId)
        : 'Nieznany przewoźnik';

      if (!byAgency.has(agencyName)) byAgency.set(agencyName, []);
      byAgency.get(agencyName).push(group);
    });

    const agencyKeys = Array.from(byAgency.keys()).sort((a, b) =>
      a.localeCompare(b, undefined, { sensitivity: 'base' })
    );

    agencyKeys.forEach(agencyName => {
      const titleEl = document.createElement('div');
      titleEl.className = 'agency-title';
      titleEl.textContent = agencyName;
      container.appendChild(titleEl);

      const grid = document.createElement('div');
      grid.className = 'routes-grid';

      const list = sortGroupsByRouteId(byAgency.get(agencyName) || []);
      list.forEach(group => {
        const repr = reprOf(group);
        if (!repr) return;
        const metaRt = getRouteTypeMeta(repr.route_type);
        const btn = document.createElement('button');
        btn.className = 'route-card';
        btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

    const label = labelOf(group);

    btn.innerHTML = `
      <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <div style="font-weight:700;">${escapeHtml(label)}</div>
      </div>
    `;

        btn.onclick = () => {
          state.selectedRouteGroup = group;
          selectRoute(repr);
        };

        grid.appendChild(btn);
      });

      grid.style.marginBottom = '28px';
      container.appendChild(grid);
    });

    return;
  }

  // === TRYB 4: RAW_ROUTES – awaryjny: każdy rekord routes osobno, sort po numerze ===
  if (state.routeGroupMode === 'raw_routes') {
    const routes = sortRoutesById(baseRoutes);
    const grid = document.createElement('div');
    grid.className = 'routes-grid';

    routes.forEach(route => {
      const btn = document.createElement('button');
      btn.className = 'route-card';
      btn.textContent = route.route_short_name || route.route_id || '';
      const metaRt = getRouteTypeMeta(route.route_type);
      btn.style.borderLeft = `6px solid ${metaRt.color || '#e6eefb'}`;

      btn.onclick = () => {
        state.selectedRouteGroup = null; // w tym trybie świadomie patrzymy na pojedynczy route_id
        selectRoute(route);
      };

      grid.appendChild(btn);
    });

    container.appendChild(grid);
    return;
  }

  // fallback – jeśli coś poszło nie tak, wracamy do logical
  state.routeGroupMode = 'logical';
  renderRouteTable();
}

function selectRoute(route) {
  const container = document.querySelector('#routes-list-container');
  if (container) {
    state.routesListScrollPosition = container.scrollTop || 0;
  }
  
  state.selectedRoute = route;

  // Jeśli bieżąca grupa logiczna NIE zawiera tej trasy, czyścimy grupę
  if (!state.selectedRouteGroup ||
      !(state.selectedRouteGroup.members || []).some(r => r.route_id === route.route_id)) {
    state.selectedRouteGroup = null;
  }

  const routeTrips = state.gtfsData.tripsIndex[route.route_id] || [];
  if (routeTrips.length > 0) {
    state.selectedDirection = [...new Set(routeTrips.map(t => t.direction_id || '0'))][0];
  }

  // Invalidate canonical cache when route changes
  invalidateCanonicalCacheForCurrentSelection();

  resetMap();
  render();
}

// ═══════════════════════════════════════════════════════════════
// 12. UI RENDERING - STOPS VIEW
// ═══════════════════════════════════════════════════════════════
// Search index for fast stop name filtering

function buildStopsSearchIndex(groupsArray) {
  if (stopsSearchIndex) return stopsSearchIndex;
  
  stopsSearchIndex = groupsArray.map(group => ({
    id: group.id,
    name: group.name,
    searchText: group.name.toLowerCase().trim(), // pre-normalized
    routeCount: group.routeCount,
    stops: group.stops,
    routeSet: group.routeSet
  }));
  
  return stopsSearchIndex;
}

function clearStopsSearchIndex() {
  stopsSearchIndex = null;
}

function searchStopsInIndex(query, groupsArray) {
  if (!query || query.trim() === '') return groupsArray;
  
  const index = buildStopsSearchIndex(groupsArray);
  const lowerQuery = query.toLowerCase().trim();
  
  return index
    .filter(item => item.searchText.includes(lowerQuery))
    .map(item => ({
      id: item.id,
      name: item.name,
      routeCount: item.routeCount,
      stops: item.stops,
      routeSet: item.routeSet
    }));
}

// Async search with chunked processing to prevent UI freeze on large datasets
async function searchStopsInIndexAsync(query, groupsArray, onProgress) {
  if (!query || query.trim() === '') return groupsArray;
  
  const index = buildStopsSearchIndex(groupsArray);
  const lowerQuery = query.toLowerCase().trim();
  const results = [];
  
  const CHUNK_SIZE = 200; // Process 200 items at a time
  
  for (let i = 0; i < index.length; i += CHUNK_SIZE) {
    const chunk = index.slice(i, i + CHUNK_SIZE);
    
    chunk.forEach(item => {
      if (item.searchText.includes(lowerQuery)) {
        results.push({
          id: item.id,
          name: item.name,
          routeCount: item.routeCount,
          stops: item.stops,
          routeSet: item.routeSet
        });
      }
    });
    
    // Report progress for very large datasets
    if (onProgress && index.length > 1000) {
      const percent = Math.round(((i + chunk.length) / index.length) * 100);
      onProgress(percent);
    }
    
    // Yield to browser every 200 items to keep UI responsive
    if (i + CHUNK_SIZE < index.length) {
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
  
  return results;
}

function getOrBuildGroupsArray(stopsData) {
  const currentHash = stopsData.length + '_' + (stopsData[0]?.stop_id || '');
  
  if (cachedGroupsArray && lastStopsDataHash === currentHash) {
    return cachedGroupsArray;
  }
  
  const stopGroups = new Map();
  stopsData.forEach(stop => {
    const stopName = stop.stop_name || '';
    const baseName = stopName.replace(/\s+\d+[A-Za-z]?$/, '').trim();
    
    if (!stopGroups.has(baseName)) {
      stopGroups.set(baseName, {
        id: baseName,
        name: baseName,
        stops: [],
        routeSet: new Set()
      });
    }
    
    const group = stopGroups.get(baseName);
    group.stops.push(stop);
    stop.routes.forEach(route => group.routeSet.add(route.route_id));
  });
  
  const groupsArray = Array.from(stopGroups.values()).map(group => ({
    ...group,
    routeCount: group.routeSet.size,
    // Mark if this is a single-stop group (no grouping needed)
    isSingleStop: group.stops.length === 1
  }));
  
  groupsArray.sort((a, b) => a.name.localeCompare(b.name));
  
  cachedGroupsArray = groupsArray;
  lastStopsDataHash = currentHash;
  
  return groupsArray;
}

function measureStopItemHeight() {
  const firstItem = document.querySelector('.stop-group');
  if (firstItem) {
    const height = firstItem.offsetHeight;
    if (height > 0 && height !== state.virtualListItemHeight) {
      state.virtualListItemHeight = height;
    }
  }
}

function renderVirtualStopsList(groupsToRender) {
  const stopsList = $('stops-list');
  if (!stopsList) return;
  
  const container = stopsList.parentElement; // scrollable container
  if (!container) return;
  
  const containerHeight = container.clientHeight || 600;
  const scrollTop = container.scrollTop || 0;
  const itemHeight = state.virtualListItemHeight;
  
  const bufferSize = 5;
  const visibleCount = Math.ceil(containerHeight / itemHeight) + bufferSize * 2;
  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - bufferSize);
  const endIndex = Math.min(startIndex + visibleCount, groupsToRender.length);
  
  state.virtualListStartIndex = startIndex;
  
  const visibleGroups = groupsToRender.slice(startIndex, endIndex);
  const totalHeight = groupsToRender.length * itemHeight;
  const offsetY = startIndex * itemHeight;
  
  let html = `<div style="height: ${totalHeight}px;position:relative;">`;
  html += `<div style="position:absolute;top:${offsetY}px;left:0;right:0;">`;
  
  visibleGroups.forEach((group, idx) => {
    const actualIndex = startIndex + idx;
    const isGroupExpanded = state.expandedStopGroup === group.id;
    const pluralForm = group.routeCount === 1 ? 'linia' : 
      (group.routeCount % 10 >= 2 && group.routeCount % 10 <= 4 && (group.routeCount % 100 < 10 || group.routeCount % 100 >= 20)) 
      ? 'linie' : 'linii';
    
    // For single-stop groups, make them directly clickable
    if (group.isSingleStop) {
      const stop = group.stops[0];
      html += `
        <div class="stop-group p-3 border-b hover:bg-blue-50 cursor-pointer" 
             data-stop-id="${stop.stop_id}" 
             data-index="${actualIndex}">
          <div class="font-semibold">${escapeHtml(group.name)}</div>
          <div class="text-xs text-gray-600">${group.routeCount} ${pluralForm}</div>
        </div>
      `;
    } else {
      // Multi-stop groups: show as expandable
      html += `
        <div class="stop-group p-3 border-b hover:bg-blue-50 cursor-pointer ${isGroupExpanded ? 'bg-blue-50' : ''}" 
             data-group-id="${escapeHtml(group.id)}" 
             data-index="${actualIndex}">
          <div class="font-semibold">${escapeHtml(group.name)}</div>
          <div class="text-xs text-gray-600">${group.routeCount} ${pluralForm}</div>
        </div>
      `;
      
      // Expanded stops (non-virtualized for simplicity)
      if (isGroupExpanded) {
        group.stops.forEach(stop => {
          const stopPluralForm = stop.routeCount === 1 ? 'linia' : 
            (stop.routeCount % 10 >= 2 && stop.routeCount % 10 <= 4 && (stop.routeCount % 100 < 10 || stop.routeCount % 100 >= 20)) 
            ? 'linie' : 'linii';
          
          html += `
            <div class="stop-item p-2 pl-6 border-b hover:bg-blue-100 cursor-pointer bg-white" data-stop-id="${stop.stop_id}">
              <div class="font-medium text-sm">${escapeHtml(stop.stop_name)}</div>
              <div class="text-xs text-gray-600">${stop.routeCount} ${stopPluralForm}</div>
            </div>
          `;
        });
      }
    }
  });
  
  html += `</div></div>`;
  stopsList.innerHTML = html;
  
  // Measure height on first render
  if (state.virtualListItemHeight === 68) {
    setTimeout(measureStopItemHeight, 50);
  }
}

// Cached stop-to-routes mapping to avoid rebuilding
let cachedStopToRoutesMap = null;
let cachedStopToRoutesHash = null;

// Build stop-to-routes mapping with chunked processing to prevent UI freeze
async function buildStopToRoutesMapAsync(routes, tripsIndex, stopTimesIndex, onProgress) {
  const stopToRoutes = new Map();
  const CHUNK_SIZE = 20; // Process 20 routes at a time
  
  for (let i = 0; i < routes.length; i += CHUNK_SIZE) {
    const routeChunk = routes.slice(i, i + CHUNK_SIZE);
    
    routeChunk.forEach(route => {
      const trips = tripsIndex[route.route_id] || [];
      const stopIds = new Set();
      
      trips.forEach(trip => {
        const stopTimes = stopTimesIndex[trip.trip_id] || [];
        stopTimes.forEach(st => stopIds.add(st.stop_id));
      });
      
      stopIds.forEach(stopId => {
        if (!stopToRoutes.has(stopId)) stopToRoutes.set(stopId, []);
        stopToRoutes.get(stopId).push(route);
      });
    });
    
    // Report progress
    if (onProgress) {
      const percent = Math.round(((i + routeChunk.length) / routes.length) * 100);
      onProgress(i + routeChunk.length, routes.length, percent);
    }
    
    // Yield to browser to keep UI responsive
    if (i + CHUNK_SIZE < routes.length) {
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
  
  return stopToRoutes;
}

// Get or build stop-to-routes mapping with caching
async function getStopToRoutesMap(routes, tripsIndex, stopTimesIndex, onProgress) {
  const currentHash = routes.length + '_' + Object.keys(tripsIndex).length;
  
  if (cachedStopToRoutesMap && cachedStopToRoutesHash === currentHash) {
    return cachedStopToRoutesMap;
  }
  
  const stopToRoutes = await buildStopToRoutesMapAsync(routes, tripsIndex, stopTimesIndex, onProgress);
  
  cachedStopToRoutesMap = stopToRoutes;
  cachedStopToRoutesHash = currentHash;
  
  return stopToRoutes;
}

function clearStopToRoutesCache() {
  cachedStopToRoutesMap = null;
  cachedStopToRoutesHash = null;
}

async function renderStopsView() {
  if (!state.gtfsData || !state.showStopsView) return;
  
  const stopsList = $('stops-list');
  const stopsMap = $('stops-map');
  if (!stopsList || !stopsMap) return;
  
  // Show loading indicator for initial data preparation
  const isInitialLoad = !cachedStopToRoutesMap;
  if (isInitialLoad) {
    stopsList.innerHTML = '<div class="p-4 text-center text-gray-600">Przygotowywanie danych przystanków...</div>';
  }
  
  const stopToRoutes = await getStopToRoutesMap(
    state.gtfsData.routes,
    state.gtfsData.tripsIndex,
    state.gtfsData.stopTimesIndex,
    isInitialLoad ? (processed, total, percent) => {
      stopsList.innerHTML = `<div class="p-4 text-center text-gray-600">Przygotowywanie danych przystanków... ${percent}%</div>`;
    } : null
  );
  
  const stopsData = [];
  Object.values(state.gtfsData.stopsIndex).forEach(stop => {
    const routes = stopToRoutes.get(stop.stop_id) || [];
    if (routes.length > 0) {
      stopsData.push({
        ...stop,
        routeCount: routes.length,
        routes: routes
      });
    }
  });
  
  // Sortuj alfabetycznie
  stopsData.sort((a, b) => (a.stop_name || '').localeCompare(b.stop_name || ''));
  
  const groupsArray = getOrBuildGroupsArray(stopsData);
  
  const searchQuery = state.stopsListSearchQuery;
  
  // Use async search for large datasets to prevent UI freeze
  let filteredGroups;
  if (groupsArray.length > 1000 && searchQuery && searchQuery.trim() !== '') {
    // Show searching indicator
    stopsList.innerHTML = '<div class="p-4 text-center text-gray-600">Wyszukiwanie...</div>';
    filteredGroups = await searchStopsInIndexAsync(searchQuery, groupsArray, (percent) => {
      stopsList.innerHTML = `<div class="p-4 text-center text-gray-600">Wyszukiwanie... ${percent}%</div>`;
    });
  } else {
    // For smaller datasets, use synchronous search
    filteredGroups = searchStopsInIndex(searchQuery, groupsArray);
  }
  
  const useVirtualList = filteredGroups.length > 100; // Threshold

  if (useVirtualList) {
    renderVirtualStopsList(filteredGroups);
  } else {
    const groupsPerPage = state.stopsListPageSize;
    const totalGroups = filteredGroups.length;
    const groupsToShow = filteredGroups.slice(0, state.stopsListPage * groupsPerPage);

    let html = '';

    groupsToShow.forEach(group => {
      const isExpanded = state.expandedStopGroup === group.id;
      const pluralForm = group.routeCount === 1 ? 'linia' : 
        (group.routeCount % 10 >= 2 && group.routeCount % 10 <= 4 && (group.routeCount % 100 < 10 || group.routeCount % 100 >= 20)) 
        ? 'linie' : 'linii';
      
      // For single-stop groups, make them directly clickable
      if (group.isSingleStop) {
        const stop = group.stops[0];
        html += `
          <div class="stop-group p-3 border-b hover:bg-blue-50 cursor-pointer" data-stop-id="${stop.stop_id}">
            <div class="font-semibold">${escapeHtml(group.name)}</div>
            <div class="text-xs text-gray-600">${group.routeCount} ${pluralForm}</div>
          </div>
        `;
      } else {
        // Multi-stop groups: show as expandable
        html += `
          <div class="stop-group p-3 border-b hover:bg-blue-50 cursor-pointer ${isExpanded ? 'bg-blue-50' : ''}" data-group-id="${escapeHtml(group.id)}">
            <div class="font-semibold">${escapeHtml(group.name)}</div>
            <div class="text-xs text-gray-600">${group.routeCount} ${pluralForm}</div>
          </div>
        `;
        
        // Poziom 2: Konkretne przystanki w grupie (tylko jeśli rozwinięta)
        if (isExpanded) {
          group.stops.forEach(stop => {
            const stopPluralForm = stop.routeCount === 1 ? 'linia' : 
              (stop.routeCount % 10 >= 2 && stop.routeCount % 10 <= 4 && (stop.routeCount % 100 < 10 || stop.routeCount % 100 >= 20)) 
              ? 'linie' : 'linii';
            
            html += `
              <div class="stop-item p-2 pl-6 border-b hover:bg-blue-100 cursor-pointer bg-white" data-stop-id="${stop.stop_id}">
                <div class="font-medium text-sm">${escapeHtml(stop.stop_name)}</div>
                <div class="text-xs text-gray-600">${stop.routeCount} ${stopPluralForm}</div>
              </div>
            `;
          });
        }
      }
    });

    // Add "Load More" button if there are more groups to display
    if (groupsToShow.length < totalGroups) {
      const remaining = totalGroups - groupsToShow.length;
      html += `
        <div class="p-4 text-center">
          <button id="load-more-stops" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition">
            Pokaż więcej (${remaining} pozostało)
          </button>
        </div>
      `;
    }

    stopsList.innerHTML = html;

    const loadMoreBtn = $('load-more-stops');
    if (loadMoreBtn) {
      loadMoreBtn.addEventListener('click', () => {
        state.stopsListPage++;
        renderStopsView();
      });
    }
  }

  // Setup scroll listener for virtual list rendering
  if (useVirtualList) {
    const container = stopsList.parentElement;
    if (container) {
      // Remove old listener if exists
      if (container._virtualScrollHandler) {
        container.removeEventListener('scroll', container._virtualScrollHandler);
      }
      
      const scrollHandler = debounce(() => {
        renderVirtualStopsList(filteredGroups);
      }, 50);
      
      container._virtualScrollHandler = scrollHandler;
      container.addEventListener('scroll', scrollHandler);
    }
  }

  const searchInput = $('stops-search-input-header');
  if (searchInput) {
    // Update value to match current state
    searchInput.value = state.stopsListSearchQuery;
    
    const oldHandler = searchInput._searchHandler;
    if (oldHandler) {
      searchInput.removeEventListener('input', oldHandler);
    }
    
    const debouncedSearch = debounce((value) => {
      state.stopsListSearchQuery = value;
      state.stopsListPage = 1; // Reset pagination on new search
      renderStopsView();
    }, 500); // Debounce delay: 500ms for better UX
    
    const newHandler = (e) => {
      debouncedSearch(e.target.value);
    };
    searchInput._searchHandler = newHandler;
    searchInput.addEventListener('input', newHandler);
  }

  // Inicjalizuj mapę
  stopsMap.innerHTML = '';
  
  // Store reference to map in window for reuse
  if (window.stopsListMap) {
    try {
      window.stopsListMap.remove();
    } catch (e) {}
    window.stopsListMap = null;
  }
  
  // Initialize map immediately (removed setTimeout for better responsiveness)
  if (!stopsMap || stopsMap.offsetParent === null) return;
  
  let initialCenter = [52.23, 21.01];
  let initialZoom = 12;
  
  if (state.stopsListMapState) {
    initialCenter = [state.stopsListMapState.center.lat, state.stopsListMapState.center.lng];
    initialZoom = state.stopsListMapState.zoom;
  }
  
  const map = window.L.map(stopsMap).setView(initialCenter, initialZoom);
  window.stopsListMap = map;
	
    window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);
    
    const markers = window.L.markerClusterGroup({
      maxClusterRadius: 30,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      disableClusteringAtZoom: 17,
      iconCreateFunction: function(cluster) {
        const count = cluster.getChildCount();
        let c = ' marker-cluster-';
        if (count < 10) {
          c += 'small';
        } else if (count < 100) {
          c += 'medium';
        } else {
          c += 'large';
        }
        
        return new window.L.DivIcon({ 
          html: '<div><span>' + count + '</span></div>',
          className: 'marker-cluster marker-cluster-neutral' + c,
          iconSize: new window.L.Point(40, 40)
        });
      }
    });
    
    const bounds = [];
    
    // Always show all stops as markers
    stopsData.forEach(stop => {
      if (!stop.stop_lat || !stop.stop_lon) return;
      const lat = parseFloat(stop.stop_lat);
      const lon = parseFloat(stop.stop_lon);
      if (isNaN(lat) || isNaN(lon)) return;
      
      const marker = window.L.marker([lat, lon], {
        icon: createSvgIcon('#3b82f6')
      });
      
      // Popup behavior depends on whether a group is expanded
      if (state.expandedStopGroup === null) {
        // State 1: Lista pokazuje grupy - popup z klikalnym linkiem
        marker.bindPopup(`
          <a href="#" onclick="event.preventDefault(); 
            state.selectedStop = state.gtfsData.stopsIndex['${stop.stop_id}']; 
            state.stopViewFilteredRoutes = []; 
			state.stopsListMapState = null;
            render(); 
            return false;" 
            style="text-decoration: none; color:inherit;">
            <strong>${escapeHtml(stop.stop_name)}</strong><br>
            ${stop.routeCount} ${stop.routeCount === 1 ? 'linia' : 
              (stop.routeCount % 10 >= 2 && stop.routeCount % 10 <= 4 && (stop.routeCount % 100 < 10 || stop.routeCount % 100 >= 20)) 
              ? 'linie' : 'linii'}
          </a>
        `, { 
          closeButton: false  // Usuń "x"
        });
      } else {
        // State 2: Lista pokazuje przystanki - bezpośrednie przejście do STOP_DETAIL
        marker.on('click', () => {
          state.selectedStop = stop;
          state.stopViewFilteredRoutes = [];
          render();
        });
      }
      
      markers.addLayer(marker);
      bounds.push([lat, lon]);
    });
    
    map.addLayer(markers);
    
    // Center map on expanded group if any
    if (state.expandedStopGroup && !state.stopsListMapState) {
      const expandedGroup = groupsArray.find(g => g.id === state.expandedStopGroup);
      if (expandedGroup && expandedGroup.stops.length > 0) {
        const groupBounds = window.L.latLngBounds();
        expandedGroup.stops.forEach(stop => {
          if (stop.stop_lat && stop.stop_lon) {
            const lat = parseFloat(stop.stop_lat);
            const lon = parseFloat(stop.stop_lon);
            if (!isNaN(lat) && !isNaN(lon)) {
              groupBounds.extend([lat, lon]);
            }
          }
        });
        
        if (groupBounds.isValid()) {
          map.fitBounds(groupBounds, { padding: [50, 50], maxZoom: 20 });
        }
      }
    } else if (bounds.length > 0 && !state.stopsListMapState) {
      map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
    }
  
  const stopsListContainer = stopsList.parentElement || stopsList;
  
  if (stopsListContainer) {
    // Remove old handler
    if (stopsListContainer._stopGroupHandler) {
      stopsListContainer.removeEventListener('click', stopsListContainer._stopGroupHandler);
    }
    
    const groupHandler = (e) => {
      const stopGroup = e.target.closest('.stop-group');
      if (!stopGroup) return;
      
      e.preventDefault();
      e.stopPropagation();
      
      const groupId = stopGroup.getAttribute('data-group-id');
      const stopId = stopGroup.getAttribute('data-stop-id');
      
      // Handle single-stop groups (they have data-stop-id instead of data-group-id)
      if (!groupId && stopId) {
        const stop = state.gtfsData.stopsIndex[stopId];
        
        if (stop) {
          // Set map to selected stop
          if (window.stopsListMap && stop.stop_lat && stop.stop_lon) {
            window.stopsListMap.setView(
              [parseFloat(stop.stop_lat), parseFloat(stop.stop_lon)],
              17
            );
          }
          
          state.selectedStop = stop;
          state.stopViewFilteredRoutes = [];
          render();
        }
        return;
      }
      
      const groupsArray = getOrBuildGroupsArray(stopsData);
      const group = groupsArray.find(g => g.id === groupId);
      
      // Always zoom map to clicked group
      if (group && group.stops.length > 0 && window.stopsListMap) {
        const groupBounds = window.L.latLngBounds();
        group.stops.forEach(stop => {
          if (stop.stop_lat && stop.stop_lon) {
            const lat = parseFloat(stop.stop_lat);
            const lon = parseFloat(stop.stop_lon);
            if (!isNaN(lat) && !isNaN(lon)) {
              groupBounds.extend([lat, lon]);
            }
          }
        });
        
        if (groupBounds.isValid()) {
          window.stopsListMap.flyToBounds(groupBounds, { 
            padding: [50, 50], 
            maxZoom: 17,
            duration: 0.5
          });
        }
      }
      
      // Toggle expansion
      if (state.expandedStopGroup === groupId) {
        state.expandedStopGroup = null;
      } else {
        state.expandedStopGroup = groupId;
      }
      
      renderStopsView();
    };
    
    stopsListContainer._stopGroupHandler = groupHandler;
    stopsListContainer.addEventListener('click', groupHandler);
  }

  const stopsList_el = $('stops-list');
  if (stopsList_el) {
    // Remove old handler if exists
    if (stopsList_el._stopItemHandler) {
      stopsList_el.removeEventListener('click', stopsList_el._stopItemHandler);
    }
    
    const handler = (e) => {
      const stopItem = e.target.closest('.stop-item');
      if (!stopItem) return;
      
      const stopId = stopItem.getAttribute('data-stop-id');
      const stop = state.gtfsData.stopsIndex[stopId];
      
if (stop) {
  // USTAW MAPĘ na wybrany przystanek
  if (window.stopsListMap && stop.stop_lat && stop.stop_lon) {
    window.stopsListMap.setView(
      [parseFloat(stop.stop_lat), parseFloat(stop.stop_lon)],
      17 // lub twój ulubiony zoom
    );
  }

  // NIE mroź stanu mapy tutaj!

  state.selectedStop = stop;
  state.stopViewFilteredRoutes = [];
  render();
}
    };
    
    stopsList_el._stopItemHandler = handler;
    stopsList_el.addEventListener('click', handler);
  }
}

function collectRoutesForStop(stopId, selectedDate, filteredRouteIds = []) {
  if (!state.gtfsData || !stopId) return [];
  
  const activeServices = getServicesForDate(selectedDate);
  const routesData = [];
  
  const routesAtStop = new Map();
  
  state.gtfsData.routes.forEach(route => {
    const trips = state.gtfsData.tripsIndex[route.route_id] || [];
    let passesThrough = false;
    let tripCount = 0;
    
    trips.forEach(trip => {
      if (! activeServices.includes(trip.service_id)) return;
      const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
      if (stopTimes.some(st => st.stop_id === stopId)) {
        passesThrough = true;
        tripCount++;
      }
    });
    
    if (passesThrough) {
      routesAtStop.set(route. route_id, { route, tripCount });
    }
  });
  
  let routesToProcess = Array. from(routesAtStop.values());
  if (filteredRouteIds.length > 0) {
    routesToProcess = routesToProcess.filter(rd => filteredRouteIds.includes(rd.route.route_id));
  }
  
  // No limit on number of routes - removed artificial 20 route limit
  
  // UPROSZCZONA LOGIKA - jedna linia = jedna trasa (najpopularniejsza sekwencja)
  routesToProcess.forEach(({ route, tripCount }) => {
    const trips = state.gtfsData.tripsIndex[route.route_id] || [];
    const activeTrips = trips.filter(t => activeServices.includes(t.service_id));
    
    // UPROSZCZENIE: dla przystanku jest tylko jeden kierunek tej linii
    const representative = findMostFrequentTripPattern(
      activeTrips, 
      state.gtfsData.stopTimesIndex,
      stopId,
      activeServices
    );
    
    if (!representative) return; // Brak tripów przez ten przystanek
    
    const stopsToDraw = [];
    representative.stopIds.forEach(sid => {
      const stop = state.gtfsData.stopsIndex[sid];
      if (stop && stop.stop_lat && stop.stop_lon) {
        const lat = parseFloat(stop.stop_lat);
        const lon = parseFloat(stop.stop_lon);
        if (!isNaN(lat) && !isNaN(lon)) {
          stopsToDraw.push({
            id: sid,
            lat,
            lon,
            name: stop.stop_name || sid,
            type: 'core'
          });
        }
      }
    });
    
    if (stopsToDraw.length > 1) {
      const meta = getRouteTypeMeta(route.route_type);
      
      const representativeTrip = activeTrips.find(t => t.trip_id === representative.tripId);
      const shapeId = representativeTrip?.shape_id || null;
      const direction = representativeTrip?.direction_id || '0';
      
      routesData.push({
        route,
        direction: direction,
        directionName: `Direction ${direction}`,
        stops: stopsToDraw,
        color: meta.color || '#3b82f6',
        tripCount: representative.frequency,
        shapeId: shapeId
      });
    }
  });
  
  return { routes: routesData };
}

function updateRouteFilterButtons() {
  const allBtn = $('filter-all-routes');
  if (allBtn) {
    if (state.stopViewFilteredRoutes.length === 0) {
      allBtn.className = allBtn.className.replace(/bg-white hover:bg-gray-50/g, 'bg-blue-500 text-white');
    } else {
      allBtn.className = allBtn.className.replace(/bg-blue-500 text-white/g, 'bg-white hover:bg-gray-50');
    }
  }
  
  $$('.route-filter-btn').forEach(btn => {
    const routeId = btn.getAttribute('data-route-id');
    const isSelected = state.stopViewFilteredRoutes.includes(routeId);
    if (isSelected) {
      btn.className = btn.className.replace(/bg-white hover:bg-gray-50/g, 'bg-blue-500 text-white');
    } else {
      btn.className = btn.className.replace(/bg-blue-500 text-white/g, 'bg-white hover:bg-gray-50');
    }
  });
}

// Helper function to get trip destination (headsign or last stop name)
function getTripDestination(dep) {
  // 1. Prefer trip_headsign if available
  if (dep.headsign && dep.headsign.trim().length > 0) {
    return dep.headsign;
  }
  
  // 2. Fallback: last stop_name from stop_times sequence
  const stopTimes = state.gtfsData.stopTimesIndex[dep.trip.trip_id] || [];
  if (stopTimes.length > 0) {
    const sorted = stopTimes.slice().sort((a, b) => {
      const seqA = parseInt(a.stop_sequence || '0', 10);
      const seqB = parseInt(b.stop_sequence || '0', 10);
      return seqA - seqB;
    });
    const lastStopId = sorted[sorted.length - 1]?.stop_id;
    const lastStop = state.gtfsData.stopsIndex[lastStopId];
    if (lastStop?.stop_name) {
      return lastStop.stop_name;
    }
  }
  
  // 3. Final fallback
  return "-";
}

function updateDeparturesTable() {
  const tableContainer = document.querySelector('#stop-detail-departures-table');
  if (!tableContainer || !state.stopDetailDepartures) return;
  
  let filteredDepartures = state.stopDetailDepartures;
  if (state.stopViewFilteredRoutes.length > 0) {
    filteredDepartures = state.stopDetailDepartures.filter(d => 
      state.stopViewFilteredRoutes.includes(d.route.route_id)
    );
  }
  
  // Generate table HTML
  if (filteredDepartures.length === 0) {
    tableContainer.innerHTML = '<div class="text-gray-700 p-4">No departures found</div>';
  } else {
    const tableHtml = `
<table
  class="text-sm border w-full"
  style="border-collapse: collapse; table-layout: fixed;"
>
  <colgroup>
    <col style="width:4.5em">
    <col style="width:max-content">
    <col style="width:100%">
  </colgroup>

  <thead class="bg-gray-50 sticky top-0 z-10">
    <tr>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Czas
      </th>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Linia
      </th>
      <th class="text-left p-3 font-semibold border">
        Kierunek
      </th>
    </tr>
  </thead>

  <tbody>
    ${filteredDepartures.map(dep => {
      const meta = getRouteTypeMeta(dep.route.route_type);

      return '<tr class="border-b hover:bg-gray-50">' +
        '<td class="p-1 font-bold border whitespace-nowrap text-center">' +
          formatTime(dep.time) +
        '</td>' +
        '<td class="p-1 border whitespace-nowrap">' +
          '<div class="flex justify-center">' +
            routeBadgeHtml(dep.route, meta) +
          '</div>' +
        '</td>' +
        '<td class="p-1 border break-words">' +
          escapeHtml(getTripDestination(dep)) +
        '</td>' +
      '</tr>';
    }).join("")}
  </tbody>
</table>
`;
    tableContainer.innerHTML = tableHtml;
  }
}

// ═══════════════════════════════════════════════════════════════
// 13. UI RENDERING - TIMETABLE
// ═══════════════════════════════════════════════════════════════
function renderTimetable() {
  const container = $('timetable-container'); 
  if (!container) return;
  
  // Get variants data early to build dropdown
  const trips = getAllTripsForRoute();
  if (trips.length === 0) {
    container.innerHTML = "<div class='p-4 text-gray-500'>No schedule available.</div>";
    return;
  }
  
  const variantsData = computeVariantsForRoute();
  const tripToVariantGlobal = variantsData ? variantsData.tripToVariant : {};
  
  // Build variant dropdown options
  let variantOptionsHtml = '<option value="0">Wszystko</option>';
  if (variantsData && variantsData.variantDetails) {
    const variantNumbers = Object.keys(variantsData.variantDetails).map(k => parseInt(k, 10)).filter(n => !isNaN(n)).sort((a, b) => a - b);
    variantNumbers.forEach(vNum => {
      variantOptionsHtml += `<option value="${vNum}">Wariant #${vNum}</option>`;
    });
  }
  
  // Calculate variant range label
  let variantRangeLabel = '';
  if (state.selectedVariantFilter > 0 && variantsData && variantsData.variantDetails) {
    const variant = variantsData.variantDetails[state.selectedVariantFilter];
    if (variant && variant.stopDetails && variant.stopDetails.length > 0) {
      const firstStop = variant.stopDetails[0]?.stop_name || '?';
      const lastStop = variant.stopDetails[variant.stopDetails.length - 1]?.stop_name || '?';
      variantRangeLabel = `${firstStop} - ${lastStop}`;
    }
  }
  
  // Determine depot button state
  const isVariantMode = state.selectedVariantFilter > 0;
  const depotButtonDisabled = isVariantMode ? 'disabled' : '';
  const depotButtonClasses = isVariantMode 
    ? 'bg-blue-500 text-white px-4 py-2 rounded opacity-50 cursor-not-allowed'
    : 'bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600';
  const depotButtonText = isVariantMode 
    ? 'Zjazdy widoczne (tryb wariantu)'
    : (state.showAllTrips ? 'Ukryj zjazdy i wyjazdy' : 'Pokaż zjazdy i wyjazdy');
  
  container.innerHTML = `
    <div class="flex gap-4 items-center mb-4">
      <button id="toggle-depot-trips-main" class="${depotButtonClasses}" ${depotButtonDisabled} style="min-width: 280px;">
        ${depotButtonText}
      </button>
      <select id="variant-filter-select" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 cursor-pointer font-medium" style="appearance: none; background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 24 24%27 fill=%27none%27 stroke=%27white%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27%3e%3cpolyline points=%276 9 12 15 18 9%27%3e%3c/polyline%3e%3c/svg%3e'); background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1.5em 1.5em; padding-right: 2.5rem; margin-left:-0.5rem;">
        ${variantOptionsHtml}
      </select>
      <div class="flex-1 text-right text-gray-700 font-medium" id="variant-range-label">
        ${variantRangeLabel}
      </div>
    </div>
    <div id="schedule-table-root"></div>
`;
  
  // Set selected value for dropdown
  const variantSelect = $('variant-filter-select');
  if (variantSelect) {
    variantSelect.value = state.selectedVariantFilter.toString();
  }
  
  const depotButton = $('toggle-depot-trips-main');
  if (depotButton) {
    depotButton.onclick = () => { 
      if (state.selectedVariantFilter > 0) return; // Disabled in variant mode
      
      const tableRoot = $('schedule-table-root');
      const scrollContainer = tableRoot?.querySelector('.overflow-x-auto');
      const savedScrollLeft = scrollContainer ? scrollContainer.scrollLeft : 0;
      const savedScrollTop = scrollContainer ? scrollContainer.scrollTop : 0;
      
      state.showAllTrips = !state.showAllTrips; 
      renderTimetable(); 
      
      // Restore scroll position after render
      setTimeout(() => {
        const newScrollContainer = $('schedule-table-root')?.querySelector('.overflow-x-auto');
        if (newScrollContainer) {
          newScrollContainer.scrollLeft = savedScrollLeft;
          newScrollContainer.scrollTop = savedScrollTop;
        }
      }, 0);
    };
  }
  
  if (variantSelect) {
    variantSelect.onchange = async (e) => {
      state.selectedVariantFilter = parseInt(e.target.value, 10);
      
      // Auto-enable showAllTrips when variant is selected
      if (state.selectedVariantFilter > 0) {
        state.showAllTrips = true;
        // Update map to show the selected variant
        state.selectedVariant = state.selectedVariantFilter;
      }
      
      renderTimetable();
      
      // Update map to show the selected variant
      if (typeof updateMap === 'function') {
        await updateMap();
      }
    };
  }

  const tableRoot = $('schedule-table-root'); if (!tableRoot) return;

if (variantsData && variantsData.variantDetails) {
  const available = Object.keys(variantsData.variantDetails).map(k=>parseInt(k,10)).filter(n=>!isNaN(n));
  if (available.length>0 && !available.includes(state.selectedVariant)) state.selectedVariant = available[0];
}

let masterList = ensureCanonicalMasterListForCurrentSelection();
let usingCanonical = !!masterList;

const tripStopMaps = {};
trips.forEach(trip => {
  const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
  stopTimes.sort((a,b)=>parseInt(a.stop_sequence||'0') - parseInt(b.stop_sequence||'0'));
  tripStopMaps[trip.trip_id] = stopTimes;
});

const profile = getCurrentRouteProfile();

// === STEP 3: Use pre-computed trip processing from profile ===
// Profile already computed all stop classification, pStops filtering, and service/depot classification
const processedTrips = trips.map(trip => {
  const processed = profile && profile.processedTrips ? profile.processedTrips[trip.trip_id] : null;
  
  if (!processed) {
    // This should rarely happen - profile should process all trips
    console.warn('No processed data for trip (profile not built?):', trip.trip_id);
    // Safe fallback: empty trip with no stops
    return { 
      ...trip, 
      pStops: [], 
      hasPassenger: false, 
      hasPassengerInsideCore: false, 
      isServiceTrip: false,
      firstCoreIdx: -1, 
      lastCoreIdx: -1 
    };
  }
  
  // Use pre-computed data from profile
  return { 
    ...trip, 
    pStops: processed.pStops,
    hasPassenger: processed.hasPassenger,
    hasPassengerInsideCore: processed.hasPassengerInsideCore,
    isServiceTrip: processed.isServiceTrip,
    firstCoreIdx: processed.firstCoreIdx,
    lastCoreIdx: processed.lastCoreIdx
  };
}).filter(t => state.showAllTrips || (t.pStops.length > 0 && t.isServiceTrip));

// Filter trips by selected variant
let filteredTrips = processedTrips;
if (state.selectedVariantFilter > 0) {
  filteredTrips = processedTrips.filter(trip => {
    const variantNum = tripToVariantGlobal[trip.trip_id];
    return variantNum === state.selectedVariantFilter;
  });
}

if (filteredTrips.length === 0) { 
  tableRoot.innerHTML = "<div class='p-4 text-gray-500'>No trips for this threshold.</div>"; 
  return; 
}

let sortedTrips = sortTripsByMostFrequentStop(filteredTrips, tripStopMaps, state.gtfsData.stopsIndex);
sortedTrips = sortedTrips.map(t => {
  const firstStop = t.pStops[0];
  let start = firstStop?.departure_time || "00:00:00";
  if (String(start).match(/^\d:/)) start = "0" + start;
  return { ...t, start };
});

const newTripStopMaps = {};
sortedTrips.forEach(t => {
  // When showAllTrips is true, use ALL stops from the trip (including depot/technical stops)
  // When showAllTrips is false, use only passenger stops (pStops)
  if (state.showAllTrips) {
    // Use all stops from the original tripStopMaps
    newTripStopMaps[t.trip_id] = tripStopMaps[t.trip_id] || [];
  } else {
    // Use only passenger stops
    newTripStopMaps[t.trip_id] = t.pStops;
  }
});

// === STEP 5: Get master list (canonical or fallback) ===
if (!usingCanonical) {
  // Fallback: use old buildMasterList
  masterList = buildMasterList(sortedTrips, newTripStopMaps, state.gtfsData.stopsIndex);
}

if (!masterList || masterList.length === 0) {
  tableRoot.innerHTML = "<div class='p-4 text-gray-500'>Unable to build schedule.</div>";
  return;
}

const tripMappings = createTripMappings(sortedTrips, newTripStopMaps, masterList);

const visibleRowIndices = [];
const visiblePassengerRowIndices = []; // Only passenger rows (excluding tail)

masterList.forEach((mStop, mIdx) => {
  // Rule 1: Hide tail rows when showAllTrips is OFF
  if (!state.showAllTrips && mStop.nodeType === 'tail') {
    return; // Skip this row
  }
  
  // Rule 2: Hide rows with no departures for current date in any trip
  let hasAnyDeparture = false;
  for (let tripIdx = 0; tripIdx < sortedTrips.length; tripIdx++) {
    const mapping = tripMappings[tripIdx];
    if (mapping[mIdx]) {
      hasAnyDeparture = true;
      break;
    }
  }
  
  if (!hasAnyDeparture) {
    return; // Skip this row - no trips stop here on this date
  }
  
  // Row is visible
  visibleRowIndices.push(mIdx);
  
  // Track passenger rows separately for adjacent-swaps ordering
  if (mStop.nodeType !== 'tail') {
    visiblePassengerRowIndices.push(mIdx);
  }
});

// === STEP 7: Apply adjacent-swaps column ordering (reorder TRIPS, not rows) ===
const serviceTrips = [];
const depotTrips = [];

sortedTrips.forEach(trip => {
  // Use pre-computed classification from profile
  if (trip.isServiceTrip) {
    serviceTrips.push(trip);
  } else {
    depotTrips.push(trip);
  }
});

const key = getCanonicalKeyForCurrentSelection() || 'fallback';
const dir = state.selectedDirection || '0';
const columnOrderCacheKey = `${key}::${dir}::${state.selectedDate}::${state.showAllTrips}`;

let orderedServiceTrips = serviceTrips;
if (usingCanonical && serviceTrips.length > 0) {
  const serviceTripMappings = serviceTrips.map(trip => {
    const originalIdx = sortedTrips.findIndex(t => t.trip_id === trip.trip_id);
    return tripMappings[originalIdx];
  });
  
  // Check cache
  if (state.columnOrderCache[columnOrderCacheKey]) {
    const cachedTripIds = state.columnOrderCache[columnOrderCacheKey];
    const tripMap = new Map(serviceTrips.map(t => [t.trip_id, t]));
    orderedServiceTrips = cachedTripIds
      .map(tid => tripMap.get(tid))
      .filter(Boolean);
    
    // If cache doesn't match, recompute
    if (orderedServiceTrips.length !== serviceTrips.length) {
      orderedServiceTrips = adjacentSwapOrder(
        serviceTrips,
        serviceTripMappings,
        visiblePassengerRowIndices, // Use only passenger rows for ranking
        adjacentSwapOrderConfig
      );
      state.columnOrderCache[columnOrderCacheKey] = orderedServiceTrips.map(t => t.trip_id);
    }
  } else {
    // Compute and cache
    orderedServiceTrips = adjacentSwapOrder(
      serviceTrips,
      serviceTripMappings,
      visiblePassengerRowIndices, // Use only passenger rows for ranking
      adjacentSwapOrderConfig
    );
    state.columnOrderCache[columnOrderCacheKey] = orderedServiceTrips.map(t => t.trip_id);
  }
}

const orderedDepotTrips = depotTrips.slice().sort((a, b) => {
  const getFirstCoreTime = (trip) => {
    if (!profile || !profile.coreStops) return null;
    const coreStopsSet = new Set(profile.coreStops);
    const stops = newTripStopMaps[trip.trip_id] || [];
    
    for (let i = 0; i < stops.length; i++) {
      if (coreStopsSet.has(stops[i].stop_id)) {
        return stops[i].departure_time || stops[i].arrival_time;
      }
    }
    return null;
  };
  
  const timeA = getFirstCoreTime(a);
  const timeB = getFirstCoreTime(b);
  
  // Both have firstCoreTime - compare
  if (timeA && timeB) {
    const diff = timeToMinutes(timeA) - timeToMinutes(timeB);
    if (diff !== 0) return diff;
  } else if (timeA) {
    return -1; // a has time, b doesn't - a comes first
  } else if (timeB) {
    return 1; // b has time, a doesn't - b comes first
  }
  
  // Tie-breaker: trip_id
  return a.trip_id.localeCompare(b.trip_id);
});

let orderedTrips;
if (state.showAllTrips) {
  orderedTrips = [...orderedServiceTrips, ...orderedDepotTrips];
} else {
  // When showAllTrips is false, only show service trips
  orderedTrips = orderedServiceTrips;
}

const orderedTripMappings = orderedTrips.map(trip => {
  const originalIdx = sortedTrips.findIndex(t => t.trip_id === trip.trip_id);
  return tripMappings[originalIdx];
});

// Use orderedTrips and orderedTripMappings for rendering
sortedTrips = orderedTrips;
const finalTripMappings = orderedTripMappings;

// === POPULATE CACHED TIMETABLE DATA FOR MODAL ===
// Store all trips (including those that might be hidden)
state.currentTimetableData.allTrips = trips; // Store ALL trips before filtering

const stopDepartures = {};
masterList.forEach((mStop) => {
  const allStopIds = mStop.stopIds || [mStop.id];
  
  const departures = [];
  
  // Go through ALL trips (not just sortedTrips) to include hidden ones
  trips.forEach(trip => {
    const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
    const stopTime = stopTimes.find(st => allStopIds.includes(st.stop_id));
    
    if (stopTime) {
      const departureTime = stopTime.departure_time || stopTime.arrival_time;
      if (departureTime) {
        departures.push({
          trip_id: trip.trip_id,
          time: departureTime,
          trip: trip,
          service_id: trip.service_id,
          headsign: trip.trip_headsign || ''
        });
      }
    }
  });
  
  // Store departures for all stopIds in this merged stop
  allStopIds.forEach(stopId => {
    stopDepartures[stopId] = departures;
  });
});

state.currentTimetableData.stopDepartures = stopDepartures;
// === END CACHED DATA ===
      
      let html = '<div class="overflow-x-auto"><table class="text-sm border-collapse border border-gray-300 w-full bg-white"><thead class="bg-gray-50 sticky top-0">';
      html += '<tr>';
      
// NAGŁÓWEK "Stop Name": 
      // padding: 14px (góra/dół - wysokość) 8px (prawo) 14px (dół) 24px (lewo - wcięcie)
      html += '<th class="text-left font-semibold border border-gray-300 sticky left-0 bg-gray-50 z-30" style="min-width: 250px; padding: 14px 8px 14px 10px;">Przystanek</th>';
      
      sortedTrips.forEach(trip => {
        const vNum = tripToVariantGlobal[trip.trip_id] || 1;
        const isSelected = state.selectedVariant === vNum;
        html += `<th class="p-1 font-semibold border border-gray-300 text-center whitespace-nowrap text-xs cursor-pointer ${isSelected ? 'bg-blue-500 text-white' : 'bg-gray-200 hover:bg-gray-300'}" style="width:58px;" data-variant="${vNum}" tabindex="0" role="button">#${vNum}</th>`;
      });
      html += '</tr></thead><tbody>';

      // Main loop: generate each row for VISIBLE stops only
      visibleRowIndices.forEach((mIdx) => {
        const mStop = masterList[mIdx];
        html += '<tr class="hover:bg-gray-50">';
        
        const isOnDemandStop = sortedTrips.some(trip => {
          const stopMatch = newTripStopMaps[trip.trip_id]?.find(st => st.stop_id === mStop.id);
          return stopMatch?.isOnDemand;
        });
        
        // First column: stop name cell with onclick for modal
        // Note: mStop.id and mStop.name are escaped to prevent XSS
        html += `<td class="p-2 font-medium sticky left-0 bg-white border border-gray-300 cursor-pointer hover:bg-blue-50 z-10" style="min-width:250px; padding-left: 10px;" onclick="openStopTimetable('${escapeHtml(mStop.id)}')">${escapeHtml(mStop.name)}${isOnDemandStop ? ' <span style="color: #ff0000; font-style: normal; margin-left: 4px;">&#128276;</span>' : ''}</td>`;

        const isMergedStop = mStop.stopIds && mStop.stopIds.length > 1;

        // Inner loop: generate time cells for each trip
        finalTripMappings.forEach((mapping, tripIdx) => {
          const stopMatch = mapping[mIdx];
          const trip = sortedTrips[tripIdx];
          
          if (stopMatch) {
            let cellTooltip = '';
            
            if (isMergedStop) {
              const actualStopId = stopMatch.stop_id;  // ← Właściwy stop_id dla TEJ komórki!
              const stopData = state.gtfsData.stopsIndex[actualStopId];
              
              if (stopData) {
                const infoParts = [];
                if (stopData.stop_id) infoParts.push(`ID: ${escapeHtml(stopData.stop_id)}`);
                if (stopData.stop_desc) infoParts.push(escapeHtml(stopData.stop_desc));
                if (stopData.platform_code) infoParts.push(`Peron: ${escapeHtml(stopData.platform_code)}`);
                
                if (infoParts.length > 0) {
                  cellTooltip = infoParts.join('<br>');
                }
              }
            }
            
            // Renderuj komórkę z właściwym tooltipem
            if (cellTooltip) {
              html += `<td class="p-1 text-center text-xs border border-gray-300 time-cell-with-tooltip">
                ${formatTime(stopMatch.departure_time || stopMatch.arrival_time)}
                <span class="tooltip-content">${cellTooltip}</span>
              </td>`;
            } else {
              // No tooltip for non-merged stops
              html += `<td class="p-1 text-center text-xs border border-gray-300">
                ${formatTime(stopMatch.departure_time || stopMatch.arrival_time)}
              </td>`;
            }
          } else {
            // FIX #7: Add "&lt;" symbol for empty cells to indicate no service
            html += '<td class="p-1 text-center text-xs border border-gray-300 text-gray-400">&lt;</td>';
          }
        });
        
        html += '</tr>';
      });
      html += '</tbody></table></div>';
      tableRoot.innerHTML = html;
      
      // FIX #5: Add tooltip positioning on hover
      setTimeout(() => {
        const timeCells = tableRoot.querySelectorAll('.time-cell-with-tooltip');
        timeCells.forEach(cell => {
          cell.addEventListener('mouseenter', function(e) {
            const tooltip = this.querySelector('.tooltip-content');
            if (!tooltip) return;
            
            const cellRect = this.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            const top = cellRect.top - tooltipRect.height - 8;
            const left = cellRect.left + (cellRect.width / 2) - (tooltipRect.width / 2);
            
            const finalTop = Math.max(10, top);
            const finalLeft = Math.max(10, Math.min(left, window.innerWidth - tooltipRect.width - 10));
            
            tooltip.style.top = finalTop + 'px';
            tooltip.style.left = finalLeft + 'px';
          });
        });
      }, 0);
      
      const thead = tableRoot.querySelector('thead');
      if (thead && !thead.dataset.variantListenerAttached) {
        function applyHeaderSelection(rootThead) {
          if (!rootThead) return;
          $$('th[data-variant]', rootThead).forEach(h => {
            const hv = parseInt(h.getAttribute('data-variant'), 10) || 1;
            if (hv === state.selectedVariant) {
              h.classList.remove('bg-gray-200', 'hover:bg-gray-300');
              h.classList.add('bg-blue-500', 'text-white');
              h.setAttribute('aria-pressed', 'true');
            } else {
              h.classList.remove('bg-blue-500', 'text-white');
              h.classList.add('bg-gray-200');
              h.setAttribute('aria-pressed', 'false');
            }
          });
        }
        thead.addEventListener('click', async (evt) => {
          const th = evt.target.closest('th[data-variant]');
          if (!th) return;
          const v = parseInt(th.getAttribute('data-variant'), 10) || 1;
          if (state.selectedVariant === v) return;
          state.selectedVariant = v;
          applyHeaderSelection(thead);
          if (typeof updateMap === 'function') await updateMap();
        });
        thead.addEventListener('keydown', async (evt) => {
          if (evt.key !== 'Enter' && evt.key !== ' ') return;
          const th = evt.target.closest('th[data-variant]');
          if (!th) return;
          evt.preventDefault();
          const v = parseInt(th.getAttribute('data-variant'), 10) || 1;
          if (state.selectedVariant === v) return;
          state.selectedVariant = v;
          applyHeaderSelection(thead);
          if (typeof updateMap === 'function') await updateMap();
          th.focus();
        });
        const scheduleRoot = $('schedule-table-root');
        if (scheduleRoot && !scheduleRoot.dataset.variantObserverAttached) {
          const mo = new MutationObserver((mutations) => {
            const newThead = scheduleRoot.querySelector('thead');
            if (newThead) applyHeaderSelection(newThead);
          });
          mo.observe(scheduleRoot, { childList: true, subtree: true });
          scheduleRoot.dataset.variantObserverAttached = '1';
        }
        applyHeaderSelection(thead);
        thead.dataset.variantListenerAttached = '1';
      }
    }

function openStopTimetable(stopId) {
  if (!state.gtfsData || !state.selectedDate) return;
  const stop = state.gtfsData.stopsIndex[stopId];
  if (!stop) return;

  // Collect departures at this stop
  // If a route is selected, filter by route and direction
  // Otherwise, show ALL routes
  let allDepartures = [];
  
  if (state.selectedRoute && state.selectedDirection !== undefined) {
    // Filter by selected route and direction
    const routeTrips = state.gtfsData.tripsIndex[state.selectedRoute.route_id] || [];
    const directionTrips = routeTrips.filter(t => (t.direction_id || '0') === state.selectedDirection);
    
    directionTrips.forEach(trip => {
      const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
      const stopTime = stopTimes.find(st => st.stop_id === stopId);
      
      if (stopTime) {
        const departureTime = stopTime.departure_time || stopTime.arrival_time;
        if (departureTime) {
          allDepartures.push({
            trip_id: trip.trip_id,
            time: departureTime,
            trip: trip,
            service_id: trip.service_id,
            headsign: trip.trip_headsign || '',
            route: state.selectedRoute
          });
        }
      }
    });
  } else {
    // No route/direction filter - show ALL routes
    state.gtfsData.routes.forEach(route => {
      const routeTrips = state.gtfsData.tripsIndex[route.route_id] || [];
      
      routeTrips.forEach(trip => {
        const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
        const stopTime = stopTimes.find(st => st.stop_id === stopId);
        
        if (stopTime) {
          const departureTime = stopTime.departure_time || stopTime.arrival_time;
          if (departureTime) {
            allDepartures.push({
              trip_id: trip.trip_id,
              time: departureTime,
              trip: trip,
              service_id: trip.service_id,
              headsign: trip.trip_headsign || '',
              route: route
            });
          }
        }
      });
    });
  }

  // Determine main destination based on the currently selected route (if any)
  let mainDestination = '';
  let mainTerminusStopId = null;
  
  if (state.selectedRoute) {
    const routeTrips = state.gtfsData.tripsIndex[state.selectedRoute.route_id] || [];
    const directionTrips = routeTrips.filter(t => (t.direction_id || '0') === state.selectedDirection);
    
    try {
      const directions = getAvailableDirections();
      const currentDir = directions.find(d => String(d.id) === String(state.selectedDirection));
      if (currentDir) {
        mainDestination = currentDir.fullName || currentDir.name || '';
      }
    } catch (e) {
      // Ignore errors
    }
    
    if (!mainDestination) {
      const headsigns = directionTrips.map(t => t.trip_headsign).filter(h => h);
      const headsignCounts = {};
      headsigns.forEach(h => { headsignCounts[h] = (headsignCounts[h] || 0) + 1; });
      let maxCount = 0;
      Object.keys(headsignCounts).forEach(h => {
        if (headsignCounts[h] > maxCount) {
          maxCount = headsignCounts[h];
          mainDestination = h;
        }
      });
    }

    if (mainDestination && directionTrips.length > 0) {
      const trip = directionTrips.find(t => t.trip_headsign === mainDestination);
      if (trip) {
        const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
        if (stopTimes.length > 0) {
          const sortedStopTimes = [...stopTimes].sort((a, b) => parseInt(a.stop_sequence) - parseInt(b.stop_sequence));
          const lastStopTime = sortedStopTimes[sortedStopTimes.length - 1];
          mainTerminusStopId = lastStopTime.stop_id;
        }
      }
    }

    if (!mainDestination && directionTrips.length > 0) {
      const firstTrip = directionTrips[0];
      const stopTimes = state.gtfsData.stopTimesIndex[firstTrip.trip_id] || [];
      if (stopTimes.length > 0) {
        const lastStopTime = stopTimes[stopTimes.length - 1];
        const lastStop = state.gtfsData.stopsIndex[lastStopTime.stop_id];
        mainDestination = lastStop?.stop_name || '';
        mainTerminusStopId = lastStopTime.stop_id;
      }
    }
  } else {
    // No route selected - use the stop name as destination
    mainDestination = stop.stop_name || 'Unknown';
  }

  // Resolve dates for each column with future-oriented preference
  const mondayDate = findDateForDayOfWeek(1); // Monday
  const saturdayDate = findDateForDayOfWeek(6); // Saturday
  const sundayDate = findDateForDayOfWeek(0); // Sunday
  
  // Find holidays in upcoming week
  const nearbyHolidays = findNearbyHolidays(state.selectedDate);
  
  // Classify holidays by day of week
  const holidaysByDayOfWeek = new Map(); // dayOfWeek -> holiday object
  const weekdayHolidays = []; // Holidays falling on Mon-Fri
  
  nearbyHolidays.forEach(holiday => {
    const holidayDate = parseGTFSDate(holiday.date);
    if (holidayDate) {
      const dayOfWeek = holidayDate.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
      holidaysByDayOfWeek.set(dayOfWeek, holiday);
      
      // Check if it's a weekday (Mon-Fri)
      if (dayOfWeek >= 1 && dayOfWeek <= 5) {
        weekdayHolidays.push(holiday);
      }
    }
  });
  
  // Collect all weekday dates (Mon-Fri) for aggregation, excluding holidays
  const weekdayDates = [];
  const weekdayHolidayDates = new Set(weekdayHolidays.map(h => h.date));
  
  if (mondayDate) {
    const monDate = parseGTFSDate(mondayDate);
    for (let i = 0; i < 5; i++) { // Mon to Fri
      const d = new Date(monDate);
      d.setDate(monDate.getDate() + i);
      const dateStr = formatDateToGTFS(d);
      
      // Exclude weekday holidays from the weekday column
      if (!weekdayHolidayDates.has(dateStr)) {
        weekdayDates.push(dateStr);
      }
    }
  }
  
  // Get services for each date
  const weekdayServicesMap = new Map(); // Map of date -> services
  weekdayDates.forEach(dateStr => {
    weekdayServicesMap.set(dateStr, getServicesForDate(dateStr));
  });
  
  const saturdayServices = saturdayDate ? getServicesForDate(saturdayDate) : [];
  const sundayServices = sundayDate ? getServicesForDate(sundayDate) : [];

  // Helper: get trip terminus
  const getTripTerminus = (tripId) => {
    const stopTimes = state.gtfsData.stopTimesIndex[tripId] || [];
    if (stopTimes.length === 0) return null;
    const sortedStopTimes = [...stopTimes].sort((a, b) => parseInt(a.stop_sequence) - parseInt(b.stop_sequence));
    const lastStopTime = sortedStopTimes[sortedStopTimes.length - 1];
    return lastStopTime.stop_id;
  };

  const alternativeTermini = new Map();
  let nextLetter = 'a';

  /**
   * Process departures for a column with weekday annotations
   * For Mon-Fri column only: track which weekdays each minute appears on
   */
  const getTimesByHourWithAnnotations = (departures, isWeekdayColumn = false, dateToServicesMap = null) => {
    const hourGroups = {};
    
    // For weekday column: track minutes by weekday AND terminus
    // Key: "HH:MM:terminus" -> Set of day indices (0=Mon, 4=Fri)
    const minuteWeekdayMap = new Map();
    
    departures.forEach(departure => {
      if (!departure.time) return;
      const [hourStr, minute] = departure.time.split(':');
      let hour = parseInt(hourStr, 10);
      let displayHour = hour % 24;
      
      // Time window: 04:00 to next day 03:59
      if ((hour >= 4 && hour < 24) || (hour >= 24 && hour < 28)) {
        const terminusStopId = getTripTerminus(departure.trip_id);
        let terminusKey = '';
        
        // Determine terminus annotation (lowercase letters)
        if (terminusStopId && terminusStopId !== mainTerminusStopId) {
          const tripHeadsign = departure.headsign;
          if (tripHeadsign && tripHeadsign !== mainDestination) {
            if (!alternativeTermini.has(tripHeadsign)) {
              alternativeTermini.set(tripHeadsign, nextLetter);
              nextLetter = String.fromCharCode(nextLetter.charCodeAt(0) + 1);
            }
            terminusKey = alternativeTermini.get(tripHeadsign);
          } else if (!tripHeadsign) {
            const terminusStop = state.gtfsData.stopsIndex[terminusStopId];
            const terminusName = terminusStop?.stop_name || terminusStopId;
            if (terminusName !== mainDestination) {
              if (!alternativeTermini.has(terminusName)) {
                alternativeTermini.set(terminusName, nextLetter);
                nextLetter = String.fromCharCode(nextLetter.charCodeAt(0) + 1);
              }
              terminusKey = alternativeTermini.get(terminusName);
            }
          }
        }
        
        if (/^[0-5]\d$/.test(minute)) {
          if (!hourGroups[displayHour]) hourGroups[displayHour] = [];
          
          // Track weekday presence for Mon-Fri column
          // Key includes both minute AND terminus to handle different terminus on different days
          if (isWeekdayColumn && dateToServicesMap) {
            const mapKey = `${String(displayHour).padStart(2, '0')}:${minute}:${terminusKey}`;
            if (!minuteWeekdayMap.has(mapKey)) {
              minuteWeekdayMap.set(mapKey, new Set());
            }
            
            // Determine which weekday this departure runs on
            const serviceId = departure.service_id;
            weekdayDates.forEach((dateStr, dayIdx) => {
              const servicesForDay = dateToServicesMap.get(dateStr) || [];
              if (servicesForDay.includes(serviceId)) {
                minuteWeekdayMap.get(mapKey).add(dayIdx);
              }
            });
          }
          
          // Store minute with terminus key for later processing
          hourGroups[displayHour].push({ minute, terminusKey });
        }
      }
    });

    // Add weekday annotations (superscript numbers) for Mon-Fri column
    // Smart algorithm: only annotate the minority pattern when there are complementary patterns
    const weekdayAnnotations = new Map(); // Set of day indices -> superscript symbol
    let nextSuperscript = 1;
    
    if (isWeekdayColumn) {
      // First pass: collect all unique weekday patterns in this hour group
      const hourPatterns = new Map(); // hour -> Map of minuteKey -> weekday pattern
      
      Object.keys(hourGroups).forEach(hour => {
        hourPatterns.set(hour, new Map());
        
        hourGroups[hour].forEach(entry => {
          const { minute, terminusKey } = entry;
          const mapKey = `${String(hour).padStart(2, '0')}:${minute}:${terminusKey}`;
          const weekdaysSet = minuteWeekdayMap.get(mapKey);
          
          if (weekdaysSet && weekdaysSet.size > 0) {
            const pattern = Array.from(weekdaysSet).sort().join(',');
            hourPatterns.get(hour).set(mapKey, {
              pattern,
              dayCount: weekdaysSet.size,
              minute,
              terminusKey
            });
          }
        });
      });
      
      // Second pass: determine which patterns need annotation
      // Strategy: find complementary patterns and only annotate the minority
      const patternsToAnnotate = new Set();
      
      Object.keys(hourGroups).forEach(hour => {
        const patterns = hourPatterns.get(hour);
        const patternCounts = new Map(); // pattern -> count of occurrences
        const patternDayCounts = new Map(); // pattern -> number of days
        
        // Count pattern occurrences
        patterns.forEach((info, mapKey) => {
          const count = patternCounts.get(info.pattern) || 0;
          patternCounts.set(info.pattern, count + 1);
          patternDayCounts.set(info.pattern, info.dayCount);
        });
        
        // Find unique patterns (not all 5 days)
        const uniquePatterns = Array.from(patternCounts.keys()).filter(p => {
          const dayCount = patternDayCounts.get(p);
          return dayCount < 5;
        });
        
        if (uniquePatterns.length === 0) {
          // All patterns run on all 5 days - no annotation needed
        } else if (uniquePatterns.length === 1) {
          // Only one partial pattern - annotate it
          patternsToAnnotate.add(uniquePatterns[0]);
        } else {
          // Multiple patterns - check if they're complementary
          // Complementary means their union = all 5 weekdays
          const allDaysInPatterns = new Set();
          uniquePatterns.forEach(pattern => {
            pattern.split(',').forEach(d => allDaysInPatterns.add(d));
          });
          
          if (allDaysInPatterns.size === 5 && uniquePatterns.length === 2) {
            // Two complementary patterns - annotate only the minority (fewer days)
            const pattern1 = uniquePatterns[0];
            const pattern2 = uniquePatterns[1];
            const count1 = patternDayCounts.get(pattern1);
            const count2 = patternDayCounts.get(pattern2);
            
            if (count1 < count2) {
              patternsToAnnotate.add(pattern1);
            } else if (count2 < count1) {
              patternsToAnnotate.add(pattern2);
            } else {
              // Equal counts - annotate both
              patternsToAnnotate.add(pattern1);
              patternsToAnnotate.add(pattern2);
            }
          } else {
            // Non-complementary or more than 2 patterns - annotate all partial patterns
            uniquePatterns.forEach(p => patternsToAnnotate.add(p));
          }
        }
      });
      
      // Third pass: apply annotations
      Object.keys(hourGroups).forEach(hour => {
        const newMinutes = [];
        
        hourGroups[hour].forEach(entry => {
          const { minute, terminusKey } = entry;
          const mapKey = `${String(hour).padStart(2, '0')}:${minute}:${terminusKey}`;
          
          const weekdaysSet = minuteWeekdayMap.get(mapKey);
          let weekdayAnnotation = '';
          
          if (weekdaysSet && weekdaysSet.size > 0 && weekdaysSet.size < 5) {
            const weekdaysKey = Array.from(weekdaysSet).sort().join(',');
            
            // Only annotate if this pattern should be annotated
            if (patternsToAnnotate.has(weekdaysKey)) {
              if (!weekdayAnnotations.has(weekdaysKey)) {
                const superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹'];
                
                // Special case: if pattern is a single day, use the weekday number (1-5)
                if (weekdaysSet.size === 1) {
                  const dayIndex = Array.from(weekdaysSet)[0];
                  // dayIndex: 0=Mon, 1=Tue, 2=Wed, 3=Thu, 4=Fri
                  // Display as: 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri
                  const weekdayNumber = dayIndex + 1;
                  weekdayAnnotations.set(weekdaysKey, superscripts[weekdayNumber]);
                } else {
                  // Multiple days: use sequential superscript
                  weekdayAnnotations.set(weekdaysKey, superscripts[nextSuperscript]);
                  nextSuperscript++;
                }
              }
              
              weekdayAnnotation = weekdayAnnotations.get(weekdaysKey);
            }
          }
          
          // Format: MM + terminus (lowercase) + weekday (superscript)
          newMinutes.push(minute + terminusKey + weekdayAnnotation);
        });
        
        hourGroups[hour] = newMinutes;
      });
    } else {
      // For non-weekday columns, just format the entries
      Object.keys(hourGroups).forEach(hour => {
        hourGroups[hour] = hourGroups[hour].map(entry => entry.minute + entry.terminusKey);
      });
    }

    // Sort minutes within each hour
    Object.keys(hourGroups).forEach(hour => {
      hourGroups[hour].sort((a, b) => {
        // Extract numeric minute for sorting (remove all annotations)
        const minA = parseInt(a.replace(/[^0-9]/g, ''));
        const minB = parseInt(b.replace(/[^0-9]/g, ''));
        return minA - minB;
      });
    });

    const hourOrder = [];
    for (let h = 4; h < 24; h++) hourOrder.push(h);
    for (let h = 0; h < 4; h++) hourOrder.push(h);
    const filteredOrder = hourOrder.filter(h => hourGroups[h]);
    const result = {};
    filteredOrder.forEach(h => { result[h] = hourGroups[h]; });
    
    return { timesByHour: result, weekdayAnnotations };
  };

  // Process weekday column with annotations (excluding weekday holidays)
  const weekdayDepartures = allDepartures.filter(d => {
    return Array.from(weekdayServicesMap.values()).some(services => services.includes(d.service_id));
  });
  
  const weekdayResult = getTimesByHourWithAnnotations(weekdayDepartures, true, weekdayServicesMap);
  const weekdayTimes = weekdayResult.timesByHour;
  const weekdayAnnotationsMap = weekdayResult.weekdayAnnotations;
  
  // Process weekend columns - check if replaced by holiday
  let saturdayColumn = null;
  let sundayColumn = null;
  
  const saturdayHoliday = holidaysByDayOfWeek.get(6); // Saturday
  const sundayHoliday = holidaysByDayOfWeek.get(0); // Sunday
  
  if (saturdayHoliday) {
    // Saturday is a holiday - use holiday data for this column
    const holidayServices = getServicesForDate(saturdayHoliday.date);
    const holidayDepartures = allDepartures.filter(d => holidayServices.includes(d.service_id));
    const holidayTimes = getTimesByHourWithAnnotations(holidayDepartures, false).timesByHour;
    saturdayColumn = { name: saturdayHoliday.name, times: holidayTimes, isHoliday: true };
  } else {
    // Normal Saturday
    const saturdayDepartures = allDepartures.filter(d => saturdayServices.includes(d.service_id));
    const saturdayTimes = getTimesByHourWithAnnotations(saturdayDepartures, false).timesByHour;
    saturdayColumn = { name: 'Sobota', times: saturdayTimes, isHoliday: false };
  }
  
  if (sundayHoliday) {
    // Sunday is a holiday - use holiday data for this column
    const holidayServices = getServicesForDate(sundayHoliday.date);
    const holidayDepartures = allDepartures.filter(d => holidayServices.includes(d.service_id));
    const holidayTimes = getTimesByHourWithAnnotations(holidayDepartures, false).timesByHour;
    sundayColumn = { name: sundayHoliday.name, times: holidayTimes, isHoliday: true };
  } else {
    // Normal Sunday
    const sundayDepartures = allDepartures.filter(d => sundayServices.includes(d.service_id));
    const sundayTimes = getTimesByHourWithAnnotations(sundayDepartures, false).timesByHour;
    sundayColumn = { name: 'Niedziela', times: sundayTimes, isHoliday: false };
  }
  
  // Process weekday holiday columns (Mon-Fri holidays as separate columns)
  const weekdayHolidayColumns = [];
  weekdayHolidays.forEach(holiday => {
    const holidayServices = getServicesForDate(holiday.date);
    const holidayDepartures = allDepartures.filter(d => holidayServices.includes(d.service_id));
    const holidayTimes = getTimesByHourWithAnnotations(holidayDepartures, false).timesByHour;
    
    weekdayHolidayColumns.push({
      name: holiday.name,
      times: holidayTimes,
      date: holiday.date
    });
  });

  const formatTimesByHour = (timesByHour) => {
    if (Object.keys(timesByHour).length === 0) return '<span style="color: #999;">No service</span>';
    const rows = [];
    const hourOrder = [];
    for (let h = 4; h < 24; h++) hourOrder.push(h);
    for (let h = 0; h < 4; h++) hourOrder.push(h);
    const hours = hourOrder.filter(h => timesByHour.hasOwnProperty(h));
    hours.forEach((hour, index) => {
      const hourPadded = String(hour).padStart(2,'0');
      const minutes = timesByHour[hour].join('  ');
      const bgColor = index % 2 === 0 ? '#e4e7eb' : '#ffffff';
      rows.push(`<div style="margin-bottom: 0; background: ${bgColor}; padding: 0.1rem 0.25rem; line-height: 1.3;"><div style="background: #4a5568; color: white; padding: 0.1rem 0.3rem; display: inline-block; font-weight: bold; min-width: 1.75rem; text-align: center; font-size: 0.8rem;">${hourPadded}</div><div style="padding: 0.1rem 0.3rem; display: inline; font-size: 0.8rem;">${minutes}</div></div>`);
    });
    return rows.join('');
  };

  // Build legends
  let legendHTML = '';
  const legendParts = [];
  
  // Weekday annotations legend
  if (weekdayAnnotationsMap.size > 0) {
    const weekdayNames = ['poniedziałek', 'wtorek', 'środa', 'czwartek', 'piątek'];
    const weekdayItems = [];
    
    weekdayAnnotationsMap.forEach((symbol, weekdaysKey) => {
      const dayIndices = weekdaysKey.split(',').map(s => parseInt(s));
      const dayNames = dayIndices.map(i => weekdayNames[i]).join(', ');
      weekdayItems.push(`<span style="font-weight: bold;">${symbol}</span> - ${dayNames}`);
    });
    
    if (weekdayItems.length > 0) {
      legendParts.push(weekdayItems.join(' • '));
    }
  }
  
  // Terminus annotations legend
  if (alternativeTermini.size > 0) {
    const terminusItems = [];
    alternativeTermini.forEach((letter, terminus) => {
      terminusItems.push(`<span style="font-weight: bold;">${letter}</span> - do ${escapeHtml(terminus)}`);
    });
    legendParts.push(terminusItems.join(' • '));
  }
  
  if (legendParts.length > 0) {
    legendHTML = `<div style="padding: 0.2rem 1rem; border-top: 1px solid #ddd; background: #f9fafb; font-size: 0.7rem; line-height: 1.2; margin: 0;">${legendParts.join(' | ')}</div>`;
  }

  // Build table HTML
  let tableHeaderHTML = `<tr style="background: #e5e7eb;">
    <th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">Dzień powszedni</th>
    <th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">${escapeHtml(saturdayColumn.name)}</th>
    <th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">${escapeHtml(sundayColumn.name)}</th>`;
  
  // Add weekday holiday columns
  weekdayHolidayColumns.forEach(hCol => {
    tableHeaderHTML += `<th style="padding: 0.1rem 0.3rem; border: 1px solid #ddd; text-align: center; font-size: 0.8rem; font-weight: 700;">${escapeHtml(hCol.name)}</th>`;
  });
  
  tableHeaderHTML += `</tr>`;
  
  let tableBodyHTML = `<tr>
    <td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(weekdayTimes)}</td>
    <td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(saturdayColumn.times)}</td>
    <td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(sundayColumn.times)}</td>`;
  
  // Add weekday holiday column data
  weekdayHolidayColumns.forEach(hCol => {
    tableBodyHTML += `<td style="padding: 0.25rem; border: 1px solid #ddd; vertical-align: top;">${formatTimesByHour(hCol.times)}</td>`;
  });
  
  tableBodyHTML += `</tr>`;

  // Build modal header - show route badge only if a route is selected
  let headerHTML = '<div style="display: flex; gap: 1rem; align-items: flex-start; padding: 0.75rem 1rem; border-bottom: 2px solid #ddd;">';
  
  if (state.selectedRoute) {
    headerHTML += `<div style="border: 3px solid #000; height: 53px; font-weight: bold; font-size: 1.9rem; text-align: center; line-height: 1.2; min-width: 93px; display: flex; align-items: center; justify-content: center;">${state.selectedRoute.route_short_name || state.selectedRoute.route_id}</div>`;
  }
  
  headerHTML += `<div style="flex: 1; min-width: 0;"><div style="font-size: 1.75rem; font-weight: 900; line-height: 1.1; text-transform: uppercase;">${escapeHtml(stop.stop_name)}</div>`;
  
  if (mainDestination && state.selectedRoute) {
    headerHTML += `<div style="font-size: 1.5rem; font-weight: 700; line-height: 1.2; text-transform: uppercase; display: flex; align-items: center; white-space: nowrap;"><span style="margin-right: 0.3em;">&#8594;</span><span style="overflow-wrap: anywhere;">${escapeHtml(mainDestination)}</span></div>`;
  }
  
  headerHTML += '</div></div>';

  const modalHTML = `<div id="stop-timetable-modal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;"><div style="background: white; padding: 0; border-radius: 8px; max-width: 1400px; max-height: 95vh; overflow-y: auto;">${headerHTML}<table style="width: 100%; border-collapse: collapse; border: 1px solid #ddd;"><thead>${tableHeaderHTML}</thead><tbody>${tableBodyHTML}</tbody></table>${legendHTML}</div></div>`;
  
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHTML;
  document.body.appendChild(modalContainer);
  
  let modalClosed = false;
  const closeModal = () => {
    if (modalClosed) return;
    modalClosed = true;
    if (modalContainer && document.body.contains(modalContainer)) document.body.removeChild(modalContainer);
    document.removeEventListener('keydown', handleEscape);
  };
  const handleEscape = (e) => { if (e.key === 'Escape') closeModal(); };
  document.addEventListener('keydown', handleEscape);
  $('stop-timetable-modal').onclick = (e) => { if (e.target.id === 'stop-timetable-modal') closeModal(); };
}

// ═══════════════════════════════════════════════════════════════
// 14. MAIN RENDER & VIEW CONTROL
// ═══════════════════════════════════════════════════════════════
    function getCurrentView() {
      // Early returns in order of precedence - simpler flow with clear hierarchy
      if (state.loading) return VIEW.LOADING;
      if (state.error) return VIEW.ERROR;
      if (!state.gtfsData) return VIEW.UPLOAD;
      
      // Stop-related views (check selectedStop before showStopsView for specificity)
      if (!state.selectedRoute && state.showStopsView && state.selectedStop) {
        return VIEW.STOP_DETAIL;
      }
      if (!state.selectedRoute && state.showStopsView) {
        return VIEW.STOPS_LIST;
      }
      
      // Route views
      if (!state.selectedRoute) return VIEW.ROUTES_LIST;
      return VIEW.ROUTE_TIMETABLE;
    }

    function renderImmediate() {
      const root = $('root');
      const currentView = getCurrentView();
      
      let html = `<div class="h-screen flex flex-col bg-gray-50">
  <div class="bg-white shadow-sm border-b px-4 py-1">
    <div class="max-w-6xl mx-auto" style="display:flex; align-items:center; justify-content:center; position:relative; min-height: 32px;">
      
      <button id="back-button" 
        class="bg-orange-500 text-white rounded cursor-pointer hover:bg-orange-600 inline-flex items-center justify-center font-medium" 
        style="position:absolute; left:0; width: 40px; height: 32px;" aria-label="Back">
        <span style="font-size: 1rem; line-height: 1; margin-top: -1px;">←</span>
      </button>

      <h2 class="text-xl font-bold text-orange-500" style="margin:0; line-height: 32px;">GTFS Fusion</h2>

      <label class="bg-orange-500 text-white rounded cursor-pointer hover:bg-orange-600 inline-flex items-center justify-center font-medium" 
        style="position:absolute; right:0; width: 40px; height: 32px;">
        ${icons.upload(16)}
        <input type="file" accept=".zip" id="file-input-header" class="hidden" />
      </label>
      
    </div>
  </div>`;

switch(currentView) {
  case VIEW.LOADING:
    html += `<div class="flex-1 flex flex-col items-center justify-center bg-gray-50">
    <div class="text-center">
      <p class="text-gray-600 font-medium animate-ellipsis">Przetwarzanie</p>
      <div style="margin-top:1rem;">
        <button id="cancel-parse" class="bg-red-500 text-white px-3 py-1 hover:bg-red-600">Anuluj</button>
      </div>
    </div>
  </div>`;
    break;
    
  case VIEW.ERROR:
    html += `<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 m-4 rounded">${state.error}</div>`;
    break;
    
  case VIEW.UPLOAD:
    html += `<div class="flex-1 flex items-center justify-center">
    <label class="bg-orange-500 text-white px-6 py-3 rounded-lg cursor-pointer hover:bg-orange-600 inline-flex items-center gap-2 text-lg font-medium">
      Załaduj GTFS
      <input type="file" accept=".zip" id="file-input" class="hidden" />
    </label>
  </div>`;
    break;
    
  case VIEW.STOP_DETAIL:
    const stop = state.selectedStop;
    
    const allStopIds = stop.stopIds || [stop.stop_id];
    
    const activeServices = getServicesForDate(state.selectedDate);
    const departures = [];
    const routesAtStop = new Map();
    
    state.gtfsData.routes.forEach(route => {
      const trips = state.gtfsData.tripsIndex[route.route_id] || [];
      trips.forEach(trip => {
        if (!activeServices.includes(trip.service_id)) return;
        const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
        const stopTime = stopTimes.find(st => st.stop_id === stop.stop_id);
        if (stopTime) {
          const departureTime = stopTime.departure_time || stopTime.arrival_time;
          if (departureTime) {
            departures.push({
              route: route,
              trip: trip,
              time: departureTime,
              timeMinutes: timeToMinutes(departureTime),
              headsign: trip.trip_headsign || ''
            });
            if (!routesAtStop.has(route.route_id)) routesAtStop.set(route.route_id, route);
          }
        }
      });
    });
    
    departures.sort((a, b) => a.timeMinutes - b.timeMinutes);
    
    // Store departures in state for dynamic filtering
    state.stopDetailDepartures = departures;
    
    let filteredDepartures = departures;
    if (state.stopViewFilteredRoutes.length > 0) {
      filteredDepartures = departures.filter(d => state.stopViewFilteredRoutes.includes(d.route.route_id));
    }
    
    const routesArray = Array.from(routesAtStop.values());
    routesArray.sort((a, b) => {
      const na = String(a.route_short_name || a.route_id || '');
      const nb = String(b.route_short_name || b.route_id || '');
      return na.localeCompare(nb, undefined, { numeric: true, sensitivity: 'base' });
    });
    
    html += `<div class="flex-1 overflow-auto p-6">
  <div class="max-w-6xl mx-auto">
    <div class="bg-white shadow-sm p-4">
      <!-- Nagłówek -->
      <div class="header-row">
        <div class="header-left">
          <h2 class="text-2xl font-bold" style="margin:0;">${escapeHtml(stop.stop_name)}</h2>
        </div>
        <div class="title-controls">
          ${state.availableDates.length ? `<select id="date-select-stop" class="border rounded px-3 py-2 text-sm">${state.availableDates.map(d => `<option value="${escapeHtml(String(d.value))}" ${String(d.value) === String(state.selectedDate) ? 'selected' : ''}>${escapeHtml(d.label)}</option>`).join('')}</select>` : ''}
        </div>
      </div>
      <!-- Filtry -->
      <div style="margin-top:12px;">
        <div style="display:grid; grid-template-columns: repeat(16, 1fr); gap:8px;">
          <button id="filter-all-routes" class="px-2 py-1 rounded border border-black text-xs font-semibold ${state.stopViewFilteredRoutes.length === 0 ? 'bg-blue-500 text-white' : 'bg-white hover:bg-gray-50'}" style="min-height:50px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
            <span>Wszystkie</span>
            <span>(${departures.length})</span>
          </button>
          ${(() => {
            const buttons = [];
            const slotsPerRow = 16;
            for (let i = 0; i < routesArray.length; i++) {
              const route = routesArray[i];
              const isSelected = state.stopViewFilteredRoutes.includes(route.route_id);
              const meta = getRouteTypeMeta(route.route_type);
              const count = departures.filter(d => d.route.route_id === route.route_id).length;
              buttons.push(`<button class="route-filter-btn px-2 py-1 rounded border border-black text-xs font-semibold ${isSelected ? 'bg-blue-500 text-white' : 'bg-white hover:bg-gray-50'}" data-route-id="${escapeHtml(route.route_id)}" style="border-left: 4px solid ${meta.color}; min-height:50px; display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <span>${escapeHtml(route.route_short_name || route.route_id)}</span>
                <span>(${count})</span>
              </button>`);
            }
            const totalSlots = Math.ceil((routesArray.length + 1) / slotsPerRow) * slotsPerRow;
            const emptySlots = totalSlots - (routesArray.length + 1);
            for (let i = 0; i < emptySlots; i++) {
              buttons.push(`<div class="px-2 py-1 rounded border border-gray-300 bg-gray-100" style="min-height:50px;"></div>`);
            }
            return buttons.join('');
          })()}
        </div>
      </div>
      
<!-- Mapa i tabela -->
      <div style="margin-top:12px; display:grid; grid-template-columns: repeat(16, 1fr); gap:8px;">
        <!-- Tabela zajmuje 6 kolumn -->
        <div style="grid-column: 1 / 7;">
          <div id="stop-detail-departures-table" style="height:500px; overflow-y:auto;">
            ${filteredDepartures.length === 0 ? '<div class="text-gray-700 p-4">No departures found</div>' : `
<table
  class="text-sm border w-full"
  style="border-collapse: collapse; table-layout: fixed;"
>
  <colgroup>
    <col style="width:4.5em">
    <col style="width:max-content">
    <col style="width:100%">
  </colgroup>

  <thead class="bg-gray-50 sticky top-0 z-10">
    <tr>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Czas
      </th>
      <th class="text-left p-3 font-semibold border whitespace-nowrap">
        Linia
      </th>
      <th class="text-left p-3 font-semibold border">
        Kierunek
      </th>
    </tr>
  </thead>

  <tbody>
    ${filteredDepartures.map(dep => {
      const meta = getRouteTypeMeta(dep.route.route_type);

      return `
        <tr class="border-b hover:bg-gray-50">
          <td class="p-1 font-bold border whitespace-nowrap text-center">
            ${formatTime(dep.time)}
          </td>

          <!-- ROUTE: NIE ROZCIĄGA SIĘ -->
<td class="p-1 border whitespace-nowrap">
  <div class="flex justify-center">
    ${routeBadgeHtml(dep.route, meta)}
  </div>
</td>

          <!-- DESTINATION: BIERZE RESZTĘ -->
          <td class="p-1 border break-words">
            ${escapeHtml(getTripDestination(dep))}
          </td>
        </tr>
      `;
    }).join("")}
  </tbody>
</table>
`}
          </div>
        </div>
        
<!-- Mapa zaczyna się od środka między 6. a 7. kolumną (6.5) i idzie do końca -->
        <div style="grid-column: 7 / 17;">
          <div class="bg-white shadow-sm" style="height:500px; margin-left:-4px; position:relative;">
            <div id="stop-detail-map" style="width:100%; height:100%; overflow:hidden;"></div>
          </div>
        </div>
</div>`;
    break;

  case VIEW.STOPS_LIST:
    // ========== WIDOK PRZYSTANKÓW ==========
    html += `<div class="flex-1 overflow-auto p-6">
    <div class="max-w-6xl mx-auto">
      <div class="routes-header">
        <div style="display:flex; align-items:center; gap:1rem;">
          <h2 class="text-2xl font-bold" style="margin:0;">Zobacz:</h2>
          <select id="view-mode-select-stops" class="border rounded px-3 py-2 text-base font-semibold">
            <option value="routes">linie</option>
            <option value="stops" selected>przystanki</option>
          </select>
        </div>
      </div>
      
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
        <div class="bg-white shadow-sm" style="max-height: 600px; display: flex; flex-direction: column;">
          <div style="position: sticky; top: 0; z-index: 10; background: white; padding: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #e5e7eb;">
            <input 
              type="text" 
              id="stops-search-input-header"
              placeholder="search" 
              class="border rounded px-3 py-2 text-sm"
              style="width: 100%;"
            />
          </div>
          <div style="flex: 1; overflow-y: auto; padding: 1rem; padding-top: 0.5rem;">
            <div id="stops-list"></div>
          </div>
        </div>
        <div class="bg-white shadow-sm">
          <div id="stops-map" style="width:100%; height:600px;"></div>
        </div>
      </div>
    </div>
  </div>`;
    break;

  case VIEW.ROUTES_LIST:
    // ========== WIDOK TRAS ==========
    html += `<div id="routes-list-container" class="flex-1 overflow-auto p-6"><div class="max-w-6xl mx-auto">
    <div class="routes-header">
      <div style="display:flex; align-items:center; gap:1rem;">
        <h2 class="text-2xl font-bold" style="margin:0;">Zobacz:</h2>
        <select id="view-mode-select" class="border rounded px-3 py-2 text-base font-semibold">
          <option value="routes" selected>linie</option>
          <option value="stops">przystanki</option>
        </select>
      </div>
      <div style="position:relative;">
        <button id="routes-options-btn" class="border rounded px-3 py-2 text-sm">Opcje ▾</button>
        <div id="routes-options" class="routes-options" style="display:none;">
          <label style="display:flex;align-items:center;gap:8px;"><span style="font-size:13px;">Grupuj według</span>
<select id="route-group-select" class="border rounded px-2 py-1 text-sm" style="margin-left:8px;">
<option value="logical" ${state.routeGroupMode==='logical'?'selected':''}>Zgrupowane linie</option>
<option value="service_type" ${state.routeGroupMode==='service_type'?'selected':''}>Środka transportu</option>
<option value="agency" ${state.routeGroupMode==='agency'?'selected':''}>Przewoźnika</option>
<option value="raw_routes" ${state.routeGroupMode==='raw_routes'?'selected':''}>route_id</option>
</select>
          </label>
        </div>
      </div>
    </div>
    <div id="routes-container" class="mb-8"><div id="routes-tbody"></div></div>
  </div></div>`;
    break;

  case VIEW.ROUTE_TIMETABLE:
    // ========== WIDOK LINII z rozkładem ==========
    const directions = getAvailableDirections();
    const dirA = Array.isArray(directions) && directions.length >= 1 ? directions[0] : null;
    const dirB = Array.isArray(directions) && directions.length >= 2 ? directions[1] : null;
    const displayA = dirA ? (dirA.fullName || dirA.name || '') : '';
    const displayB = dirB ? (dirB.fullName || dirB.name || '') : '';
    const combinedAB = (displayA && displayB) ? `${displayA} → ${displayB}` : (displayA || displayB || '');
    
    const shortName = String(state.selectedRoute.route_short_name || '').trim();
    const longName = String(state.selectedRoute.route_long_name || '').trim();
    
    let routeTitleRaw = '';
    // Priority: 1. Clean directions from getAvailableDirections (if both available)
    //           2. Fallback to route_long_name if directions not available
    if (combinedAB) {
      routeTitleRaw = combinedAB;
    } else if (longName) {
      routeTitleRaw = longName;
    } else {
      const selDir = Array.isArray(directions) && directions.length
        ? (directions.find(d => String(d.id) === String(state.selectedDirection)) || directions[0])
        : null;
      routeTitleRaw = selDir ? (selDir.fullName || selDir.name || '') : (state.selectedRoute.route_id || '');
    }
    if (shortName && routeTitleRaw) {
      routeTitleRaw = shortName + ' ' + routeTitleRaw;
    }
    if (shortName) {
      const escaped = shortName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const doubleRe = new RegExp('^' + escaped + '\\s+' + escaped + '(?:\\s|$)');
      if (doubleRe.test(routeTitleRaw)) {
        routeTitleRaw = routeTitleRaw.replace(new RegExp('^' + escaped + '\\s*'), '');
      }
    }
    const routeTitle = escapeHtml(routeTitleRaw);
    let titleWithoutShort = routeTitleRaw || '';
    if (shortName) {
      const escapedShortForRe = shortName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      titleWithoutShort = titleWithoutShort.replace(new RegExp('^' + escapedShortForRe + '\\s*'), '');
    }
    const shortEsc = escapeHtml(shortName);
    const titleEsc = escapeHtml(titleWithoutShort || routeTitleRaw || '');
    
    html += `<div class="flex-1 overflow-auto">
  <div class="max-w-6xl mx-auto">
    <div class="bg-white border-b p-4" style="box-sizing:border-box;">
      <div class="header-row" style="display:flex;align-items:center;gap:0.5rem;">
        <div class="header-left" style="min-width:0; display:flex; align-items:center; gap:0.5rem; flex:0 1 auto;">
          <h2 class="text-2xl font-bold" title="${escapeHtml(routeTitleRaw)}" style="margin:0; display:flex; align-items:center;">
            <span class="header-with-badge">` +
              (shortName ? `<span class="route-badge">${shortEsc}</span>` : '') +
              `<span class="route-title" title="${escapeHtml(routeTitleRaw)}">${titleEsc}</span>
            </span>
          </h2>
        </div>

        <div class="title-controls" style="margin-left:auto;display:flex;align-items:center;gap:0.5rem;flex:0 0 auto;">
          ${directions.length>1 ? `<select id="direction-select" style="max-width:160px;display:inline-block;" class="border rounded px-3 py-2 text-sm">${directions.map(dir => `<option value="${escapeHtml(String(dir.id))}" ${String(state.selectedDirection) === String(dir.id) ? 'selected' : ''}>${escapeHtml(dir.name)}</option>`).join('')}</select>` : ''}
          ${ (state.availableDates || []).length ? `<select id="date-select" style="width:auto;min-width:160px;display:inline-block;" class="border rounded px-3 py-2 text-sm">${(state.availableDates||[]).map(d => `<option value="${escapeHtml(String(d.value))}" ${String(d.value) === String(state.selectedDate) ? 'selected' : ''}>${escapeHtml(d.label)}</option>`).join('')}</select>` : '' }
        </div>
      </div>

      <div style="margin-top:12px;">
        <div id="map-container" style="width:100%; height:420px; box-sizing:border-box; border-radius:6px; overflow:hidden; background:#fff;"></div>
        <div id="timetable-container" class="mt-4 mb-0"></div>
      </div>
    </div>
  </div>
</div>`;
    break;
}
      
      html += `</div>`;
      root.innerHTML = html;

      $('file-input')?.addEventListener('change', handleFileUpload);

      $('file-input-header')?.addEventListener('change', handleFileUpload);

      $('cancel-parse')?.addEventListener('click', cancelParsing);
      const routesOptionsBtn = $('routes-options-btn');
      const routesOptions = $('routes-options');
      if (routesOptionsBtn && routesOptions) {
        routesOptionsBtn.addEventListener('click', (e) => {
          state.routesOptionsOpen = !state.routesOptionsOpen;
          routesOptions.style.display = state.routesOptionsOpen ? 'block' : 'none';
        });
        if (!state.routesOptionsListenerAttached) {
          document.addEventListener('click', (ev) => {
            try {
              if (!$('routes-options')) return;
              const ro = $('routes-options');
              const btn = $('routes-options-btn');
              if (!ro || !btn) return;
              if (!ro.contains(ev.target) && ev.target !== btn) {
                state.routesOptionsOpen = false;
                ro.style.display = 'none';
              }
            } catch(e){}
          });
          state.routesOptionsListenerAttached = true;
        }
      }
      $('route-group-select')?.addEventListener('change', (e) => { state.routeGroupMode = e.target.value || 'route_id'; renderRouteTable(); });
      $('view-mode-select')?.addEventListener('change', (e) => {
    state.showStopsView = (e.target.value === 'stops');
    render();
  });

$('view-mode-select-stops')?.addEventListener('change', (e) => {
    state.showStopsView = (e.target.value === 'stops');
    render();
  });
$('back-button')?.addEventListener('click', () => {
    if (state.selectedStop) {
      // Powrót ze STOP_DETAIL do STOPS_LIST
      // Restore expanded group if we had one
      if (state.stopsListMapState && state.stopsListMapState.expandedGroup) {
        state.expandedStopGroup = state.stopsListMapState.expandedGroup;
      }
      // FIX #3: Reset map state when leaving STOP_DETAIL
      state.stopDetailMapInitialized = false;
      state.stopDetailMapLayers = {};
      if (state.stopDetailMapInstance) {
        try {
          state.stopDetailMapInstance.remove();
        } catch(e) {}
        state.stopDetailMapInstance = null;
      }
      state.selectedStop = null;
      state.stopViewFilteredRoutes = [];
    } else if (state.selectedRoute) {
      // Powrót z ROUTE_TIMETABLE do ROUTES_LIST
      state.selectedRoute = null;
      resetMap();
    } else if (state.showStopsView) {
      // Powrót ze STOPS_LIST do ROUTES_LIST
      state.showStopsView = false;
      state.expandedStopGroup = null;
      state.stopsListMapState = null;
      state.stopsListSearchQuery = '';
      state.routesListScrollPosition = 0; // Reset scroll position
      resetMap();
    } else if (!state.showStopsView) {
      // Powrót z ROUTES_LIST do STOPS_LIST
      state.showStopsView = true;
      state.routesListScrollPosition = 0; // Reset scroll position
      resetMap();
    }
    render(); 
  });

const filterAllBtn = document.getElementById('filter-all-routes');
if (filterAllBtn) {
  const oldHandler = filterAllBtn._filterHandler;
  if (oldHandler) filterAllBtn.removeEventListener('click', oldHandler);
  const newHandler = () => {
    state.stopViewFilteredRoutes = [];
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
    updateRouteFilterButtons();
    updateDeparturesTable();
  };
  filterAllBtn._filterHandler = newHandler;
  filterAllBtn.addEventListener('click', newHandler);
}
document.querySelectorAll('.route-filter-btn').forEach(btn => {
  const oldHandler = btn._filterHandler;
  if (oldHandler) btn.removeEventListener('click', oldHandler);
  const newHandler = () => {
    const routeId = btn.getAttribute('data-route-id');
    const idx = state.stopViewFilteredRoutes.indexOf(routeId);
    if (idx > -1) {
      state.stopViewFilteredRoutes.splice(idx, 1);
    } else {
      state.stopViewFilteredRoutes.push(routeId);
    }
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
    updateRouteFilterButtons();
    updateDeparturesTable();
  };
  btn._filterHandler = newHandler;
  btn.addEventListener('click', newHandler);
});
// -- KONIEC BLOKU obsługi kliknięć --		

// WARNING: Do not duplicate these event listeners - they should only be registered once
// to avoid multiple callbacks firing on each change
$('direction-select')?.addEventListener('change', async (e) => {
    const newDirection = String(e.target.value);
    if (newDirection === state.selectedDirection) return; // Avoid redundant updates
    state.selectedDirection = newDirection;
    // Invalidate canonical cache when direction changes
    invalidateCanonicalCacheForCurrentSelection();
    resetMap();
    render();
  });

$('date-select')?.addEventListener('change', async (e) => {
    state.selectedDate = String(e.target.value);
    resetMap();
    render();
  });

if (state.gtfsData && !state.selectedRoute && !state.showStopsView) {
  renderRouteTable();
  // Restore scroll position after rendering routes list
  if (state.routesListScrollPosition !== undefined && state.routesListScrollPosition > 0) {
    setTimeout(() => {
      const container = document.querySelector('#routes-list-container');
      if (container) {
        container.scrollTop = state.routesListScrollPosition;
      }
    }, 50);
  }
}
if (state.gtfsData && !state.selectedRoute && state.showStopsView && state.selectedStop) {
  // Renderuj mapę z trasami linii - only once on first load
  setTimeout(async () => {
    await renderStopDetailMap(state.selectedStop.stop_id, state.selectedDate, state.stopViewFilteredRoutes);
    // FIX #3: Apply initial filter after map is initialized
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
  }, 50);
  
// replace the stop-detail date-select handler with this (if present in your file)
$('date-select-stop')?.addEventListener('change', async (e) => {
  state.selectedDate = String(e.target.value);
  state.stopDetailDepartures = [];
  
  // FIX #4: Update layers without restarting map
  if (state.stopDetailMapInstance && state.stopDetailMapInitialized) {
    const map = state.stopDetailMapInstance;
    const stopId = state.selectedStop.stop_id;
    
    // Remove old layers
    Object.values(state.stopDetailMapLayers).forEach(layer => {
      map.removeLayer(layer);
    });
    state.stopDetailMapLayers = {};
    
    const result = collectRoutesForStop(stopId, state.selectedDate, []);
    
    const routesData = result.routes || [];
    
    // Recreate layers
    for (const routeData of routesData) {
      const { route, stops, color, direction, shapeId } = routeData;
      const layerKey = `${route.route_id}_${direction}`;
      
      const layer = window.L.featureGroup();
      
      const mainRouteStops = stops.filter(s => s.type === 'core' || s.type === 'branch');
      
      if (mainRouteStops.length > 1) {
        let lineGeometry = null;
        
        if (shapeId && state.gtfsData.shapesIndex && state.gtfsData.shapesIndex[shapeId]) {
          lineGeometry = state.gtfsData.shapesIndex[shapeId];
        }
        
        if (!lineGeometry) {
          try {
            lineGeometry = await generateLineGeometry(mainRouteStops, route.route_type);
          } catch (err) {
            // Ignore geometry generation errors - fallback to straight lines between stops
          }
        }
        
        if (!lineGeometry || lineGeometry.length < 2) {
          lineGeometry = mainRouteStops.map(s => [s.lat, s.lon]).filter(([lat, lon]) => !isNaN(lat) && !isNaN(lon));
        }
        
        if (Array.isArray(lineGeometry) && lineGeometry.length > 1) {
          window.L.polyline(lineGeometry, {
            color: color,
            weight: 3,
            opacity: 0.7,
            smoothFactor: 0.5
          }).addTo(layer);
        }
      }
      
      mainRouteStops.forEach(s => {
        if (!s || isNaN(parseFloat(s.lat)) || isNaN(parseFloat(s.lon))) return;
        const sLat = parseFloat(s.lat);
        const sLon = parseFloat(s.lon);
        window.L.marker([sLat, sLon], {
          icon: createSvgIcon(color)
        }).addTo(layer).bindPopup(s.name);
      });
      
      state.stopDetailMapLayers[layerKey] = layer;
      layer.addTo(map);
    }
    
    // Apply current filter
    filterStopDetailMapLayers(state.stopViewFilteredRoutes);
  }
  
  const activeServices = getServicesForDate(state.selectedDate);
  const departures = [];
  const routesAtStop = new Map();
  
  state.gtfsData.routes.forEach(route => {
    const trips = state.gtfsData.tripsIndex[route.route_id] || [];
    trips.forEach(trip => {
      if (!activeServices.includes(trip.service_id)) return;
      const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
      const stopTime = stopTimes.find(st => st.stop_id === state.selectedStop.stop_id);
      if (stopTime) {
        const departureTime = stopTime.departure_time || stopTime.arrival_time;
        if (departureTime) {
          departures.push({
            route: route,
            trip: trip,
            time: departureTime,
            timeMinutes: timeToMinutes(departureTime),
            headsign: trip.trip_headsign || ''
          });
          if (!routesAtStop.has(route.route_id)) routesAtStop.set(route.route_id, route);
        }
      }
    });
  });
  
  departures.sort((a, b) => a.timeMinutes - b.timeMinutes);
  state.stopDetailDepartures = departures;
  
  // Update UI
  updateDeparturesTable();
  updateRouteFilterButtons();
});

}
if (state.gtfsData && !state.selectedRoute && state.showStopsView && !state.selectedStop) renderStopsView();
if (state.gtfsData && state.selectedRoute) { 
  try {
    renderTimetable(); 
  } catch (err) {
    console.error('renderTimetable error:', err);
  }
  updateMap().catch(() => {
    // Ignore map update errors - map functionality is non-critical for timetable display
  }); 
}
}

    function render(force = false) {
      const now = Date.now();
      
      // During loading, throttle renders to avoid excessive DOM updates
      if (state.loading && !force) {
        if (now - lastRenderTime < RENDER_THROTTLE_MS) {
          return; // Skip render if called too soon
        }
      }
      
      lastRenderTime = now;
      renderImmediate();
    }

// ═══════════════════════════════════════════════════════════════
// 15. GLOBAL EVENT HANDLERS & INITIALIZATION
// ═══════════════════════════════════════════════════════════════
    // global delegated handlers (one-time) ---------------------------------------------------------
    // handle clicks on any .route-link (works for badges in stop detail, modal, lists)
    document.addEventListener('click', (e) => {
      const routeLink = e.target.closest('.route-link');
      if (!routeLink) return;
      e.preventDefault();
      const routeId = routeLink.getAttribute('data-route-id');
      if (!routeId) return;
      const route = findRouteById(routeId);
      if (!route) return;
      selectRoute(route);
      // when navigating from stop view we want to leave stop view
      state.selectedStop = null;
      state.stopViewFilteredRoutes = [];
      resetMap();
      render();
    });

    // initial render
    render();

    // ═══════════════════════════════════════════════════════════════
    // DEBUG FUNCTION: window.debugTrips()
    // ═══════════════════════════════════════════════════════════════
    
    /**
     * Debug function to export all trip data for current route as HTML
     * Helps debug trip filtering issues by showing all trips with classification data
     */
    window.debugTrips = function() {
      // 1. Validation: Check if route is selected
      if (!state.selectedRoute) {
        console.error('❌ No route selected! Select a route first.');
        return;
      }

      if (!state.gtfsData || !state.selectedDate) {
        console.error('❌ No GTFS data loaded or date selected!');
        return;
      }

      // 2. Data collection using existing functions
      const allTrips = getAllTripsForRoute();
      const variantsData = computeVariantsForRoute();
      const profile = getCurrentRouteProfile();
      const activeServices = getServicesForDate(state.selectedDate);

      if (!allTrips || allTrips.length === 0) {
        console.error('❌ No trips found for this route!');
        return;
      }

      // HTML escape utility
      const escapeHtml = (str) => {
        if (str === null || str === undefined) return '';
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      };

      // 3. Process each trip
      const processedTrips = allTrips.map(trip => {
        const stopTimes = state.gtfsData.stopTimesIndex[trip.trip_id] || [];
        const sortedStops = [...stopTimes].sort((a, b) => 
          parseInt(a.stop_sequence || '0') - parseInt(b.stop_sequence || '0')
        );

        // Get core stops info from profile
        let coreStops = new Set();
        let nodeTypes = {};
        if (profile && profile.coreStops) {
          // profile.coreStops is a flat array of stop_ids, not objects
          if (Array.isArray(profile.coreStops)) {
            profile.coreStops.forEach(stopId => coreStops.add(stopId));
          }
        }
        if (profile && profile.nodeTypes) {
          nodeTypes = profile.nodeTypes;
        }

        // Calculate firstCoreIdx and lastCoreIdx
        let firstCoreIdx = -1;
        let lastCoreIdx = -1;
        for (let i = 0; i < sortedStops.length; i++) {
          const stopId = sortedStops[i].stop_id;
          if (coreStops.has(stopId)) {
            if (firstCoreIdx === -1) firstCoreIdx = i;
            lastCoreIdx = i;
          }
        }

        // Process stop details
        const stopDetails = sortedStops.map((st, idx) => {
          const stopId = st.stop_id;
          const stopInfo = state.gtfsData.stopsIndex[stopId] || {};
          const pType = st.pickup_type ? String(st.pickup_type).trim() : "0";
          const dType = st.drop_off_type ? String(st.drop_off_type).trim() : "0";
          
          // Determine if technical stop
          let isTech = false;
          const nodeType = nodeTypes[stopId] || 'passenger';
          
          if (nodeType === 'tail') {
            isTech = true;
          } else if (nodeType === 'passenger' || nodeType === 'core') {
            isTech = false;
          } else {
            // Fallback logic
            const isStrictlyTechnical = (pType === "1" && dType === "1");
            if (isStrictlyTechnical) {
              isTech = true;
            } else if (idx === 0 && pType === "1") {
              isTech = true;
            } else if (idx === sortedStops.length - 1 && dType === "1") {
              isTech = true;
            }
          }

          const isCore = coreStops.has(stopId);
          const isBetweenCore = idx > firstCoreIdx && idx < lastCoreIdx && firstCoreIdx !== -1 && lastCoreIdx !== -1;

          return {
            seq: st.stop_sequence,
            stop_id: stopId,
            stop_name: stopInfo.stop_name || stopId,
            arrival: st.arrival_time || '',
            departure: st.departure_time || '',
            pickup_type: pType,
            drop_off_type: dType,
            nodeType: nodeType,
            isCore: isCore,
            isTech: isTech,
            isBetweenCore: isBetweenCore
          };
        });

        // Calculate hasPassenger
        const hasPassenger = stopDetails.some(s => !s.isTech);
        
        // Count passenger stops (non-technical stops)
        const passengerStopCount = stopDetails.filter(s => !s.isTech).length;

        // Calculate hasPassengerBetweenCore (same as hasPassengerInsideCore in main code)
        let hasPassengerBetweenCore = false;
        if (firstCoreIdx !== -1 && lastCoreIdx !== -1 && firstCoreIdx < lastCoreIdx) {
          for (let i = firstCoreIdx + 1; i < lastCoreIdx; i++) {
            if (stopDetails[i] && !stopDetails[i].isTech) {
              hasPassengerBetweenCore = true;
              break;
            }
          }
        }

        // Calculate filtering status
        const wouldBeFiltered = !hasPassenger && !state.showAllTrips;
        
        // Match the main code logic for service vs depot classification
        // For trips with ≤2 passenger stops: classify as service if it has any passenger stops
        // For trips with 3+ passenger stops: classify as service only if has passenger stops between core
        const isServiceTrip = passengerStopCount <= 2 
          ? hasPassenger 
          : hasPassengerBetweenCore;
        const wouldBeDepot = !isServiceTrip;
        const activeOnDate = activeServices.includes(trip.service_id);
        const variant = variantsData ? variantsData.tripToVariant[trip.trip_id] : 'N/A';

        // Generate classification reason
        let classificationReason = '';
        if (!hasPassenger) {
          classificationReason = '✗ NO passenger stops (all technical) | 🚫 FILTERED OUT (depot positioning)';
        } else if (passengerStopCount <= 2) {
          // Short trips (≤2 passenger stops): classified as service if has any passenger stops
          classificationReason = `✓ Has ${passengerStopCount} passenger stop(s) | ✅ SHORT TRIP → CLASSIFIED AS SERVICE TRIP`;
        } else if (!hasPassengerBetweenCore) {
          const coreRange = firstCoreIdx !== -1 && lastCoreIdx !== -1 
            ? `${firstCoreIdx} to ${lastCoreIdx}` 
            : 'none';
          classificationReason = `✓ Has ${passengerStopCount} passenger stops | Core stops: ${coreRange} | ❌ NO PASSENGER STOPS BETWEEN CORE | 🔧 CLASSIFIED AS DEPOT TRIP`;
        } else {
          const coreRange = firstCoreIdx !== -1 && lastCoreIdx !== -1 
            ? `${firstCoreIdx} to ${lastCoreIdx}` 
            : 'none';
          classificationReason = `✓ Has ${passengerStopCount} passenger stops | Core stops: ${coreRange} | ✓ Has passengers between core | ✅ NORMAL SERVICE TRIP`;
        }

        return {
          trip,
          variant,
          firstCoreIdx,
          lastCoreIdx,
          hasPassenger,
          hasPassengerBetweenCore,
          wouldBeFiltered,
          wouldBeDepot,
          activeOnDate,
          stopsCount: sortedStops.length,
          stopDetails,
          classificationReason
        };
      });

      // 4. Calculate active days in current month
      const selectedDate = parseGTFSDate(state.selectedDate);
      const year = selectedDate.getFullYear();
      const month = selectedDate.getMonth();
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      
      const activeDaysInMonth = [];
      for (let day = 1; day <= daysInMonth; day++) {
        const testDate = new Date(year, month, day);
        const dateStr = `${testDate.getFullYear()}${String(testDate.getMonth() + 1).padStart(2, '0')}${String(testDate.getDate()).padStart(2, '0')}`;
        const servicesForDate = getServicesForDate(dateStr);
        
        // Check if any trip from this route runs on this date
        const hasServiceOnDate = allTrips.some(trip => servicesForDate.includes(trip.service_id));
        if (hasServiceOnDate) {
          activeDaysInMonth.push(day);
        }
      }

      // 5. Generate HTML
      const routeId = state.selectedRoute.route_id || 'unknown';
      const routeName = state.selectedRoute.route_short_name || state.selectedRoute.route_long_name || routeId;
      const direction = state.selectedDirection;
      const directionName = direction === '0' ? 'Direction 0' : 'Direction 1';
      
      const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Trips - ${escapeHtml(routeName)} - ${escapeHtml(state.selectedDate)}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      margin: 20px;
      font-size: 12px;
      line-height: 1.4;
    }
    h1 { font-size: 18px; margin-bottom: 10px; }
    h2 { font-size: 14px; margin-top: 15px; margin-bottom: 8px; }
    .header-info { margin-bottom: 15px; background: #f0f0f0; padding: 10px; border-radius: 4px; }
    .header-info p { margin: 4px 0; }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 10px;
      font-size: 11px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 4px 6px;
      text-align: left;
    }
    th {
      background-color: #f5f5f5;
      font-weight: 600;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    tr.filtered {
      background-color: #fff3cd;
    }
    tr:hover {
      background-color: #f9f9f9;
    }
    .mono {
      font-family: 'Courier New', monospace;
    }
    .center {
      text-align: center;
    }
    .stops-table {
      font-size: 10px;
      margin: 5px 0;
      width: 100%;
    }
    .stops-table th, .stops-table td {
      padding: 2px 4px;
    }
    .stops-table th {
      background-color: #e9e9e9;
    }
    .checkmark { color: green; }
    .crossmark { color: red; }
    .stats { display: flex; gap: 20px; margin-top: 10px; }
    .stat { font-weight: bold; }
    details { margin: 5px 0; }
    summary { cursor: pointer; font-weight: 600; }
  </style>
</head>
<body>
  <h1>🔍 Debug Trips Export</h1>
  
  <div class="header-info">
    <p><strong>Route:</strong> ${escapeHtml(routeName)} (ID: ${escapeHtml(routeId)})</p>
    <p><strong>Date:</strong> ${escapeHtml(state.selectedDate)}</p>
    <p><strong>Direction:</strong> ${escapeHtml(directionName)} (${escapeHtml(direction)})</p>
    <p><strong>Show All Trips Mode:</strong> ${state.showAllTrips ? '✓ ON (showing depot trips)' : '✗ OFF (hiding depot trips)'}</p>
    <p><strong>Active days this month:</strong> ${activeDaysInMonth.length > 0 ? activeDaysInMonth.join(', ') : 'None'} (${activeDaysInMonth.length} days out of ${daysInMonth})</p>
    
    <div class="stats">
      <span class="stat">Total trips: ${processedTrips.length}</span>
      <span class="stat">Active on ${escapeHtml(state.selectedDate)}: ${processedTrips.filter(t => t.activeOnDate).length}</span>
      <span class="stat">Would be filtered: ${processedTrips.filter(t => t.wouldBeFiltered).length}</span>
      <span class="stat">Depot trips: ${processedTrips.filter(t => t.wouldBeDepot).length}</span>
      <span class="stat">Normal service trips: ${processedTrips.filter(t => !t.wouldBeDepot).length}</span>
    </div>
  </div>

  <table>
    <thead>
      <tr>
        <th>Trip ID</th>
        <th>Variant</th>
        <th>Service ID</th>
        <th>Direction</th>
        <th class="center">Stops Count</th>
        <th class="center">First Core</th>
        <th class="center">Last Core</th>
        <th class="center">Has Passenger</th>
        <th class="center">Passenger Between Core</th>
        <th class="center">Active on Date</th>
        <th class="center">Would Be Filtered</th>
        <th class="center">Would Be Depot</th>
        <th>Classification Reason</th>
        <th>Stop Sequence</th>
      </tr>
    </thead>
    <tbody>
${processedTrips.map(pt => {
  const trip = pt.trip;
  const rowClass = pt.wouldBeFiltered ? ' class="filtered"' : '';
  
  // Build stop sequence nested table
  const stopsHtml = `
    <details>
      <summary>${pt.stopDetails.length} stops (click to expand)</summary>
      <table class="stops-table">
        <thead>
          <tr>
            <th>Seq</th>
            <th>Stop ID</th>
            <th>Stop Name</th>
            <th>Arrival</th>
            <th>Departure</th>
            <th>Pickup</th>
            <th>Drop</th>
            <th>Node Type</th>
            <th>Core?</th>
            <th>Tech?</th>
            <th>Between Core?</th>
          </tr>
        </thead>
        <tbody>
${pt.stopDetails.map(s => `          <tr>
            <td class="center">${escapeHtml(s.seq)}</td>
            <td class="mono">${escapeHtml(s.stop_id)}</td>
            <td>${escapeHtml(s.stop_name)}</td>
            <td class="center mono">${escapeHtml(s.arrival)}</td>
            <td class="center mono">${escapeHtml(s.departure)}</td>
            <td class="center">${escapeHtml(s.pickup_type)}</td>
            <td class="center">${escapeHtml(s.drop_off_type)}</td>
            <td class="center">${escapeHtml(s.nodeType)}</td>
            <td class="center">${s.isCore ? '✓' : ''}</td>
            <td class="center">${s.isTech ? '✓' : ''}</td>
            <td class="center">${s.isBetweenCore ? '✓' : ''}</td>
          </tr>`).join('\n')}
        </tbody>
      </table>
    </details>
  `;

  return `      <tr${rowClass}>
        <td class="mono">${escapeHtml(trip.trip_id)}</td>
        <td class="center">${escapeHtml(String(pt.variant))}</td>
        <td class="mono">${escapeHtml(trip.service_id)}</td>
        <td class="center">${escapeHtml(trip.direction_id || '0')}</td>
        <td class="center">${pt.stopsCount}</td>
        <td class="center">${pt.firstCoreIdx !== -1 ? pt.firstCoreIdx : 'N/A'}</td>
        <td class="center">${pt.lastCoreIdx !== -1 ? pt.lastCoreIdx : 'N/A'}</td>
        <td class="center ${pt.hasPassenger ? 'checkmark' : 'crossmark'}">${pt.hasPassenger ? '✓' : '✗'}</td>
        <td class="center ${pt.hasPassengerBetweenCore ? 'checkmark' : 'crossmark'}">${pt.hasPassengerBetweenCore ? '✓' : '✗'}</td>
        <td class="center ${pt.activeOnDate ? 'checkmark' : 'crossmark'}">${pt.activeOnDate ? '✓' : '✗'}</td>
        <td class="center ${pt.wouldBeFiltered ? 'crossmark' : ''}">${pt.wouldBeFiltered ? '✓ Filtered' : ''}</td>
        <td class="center">${pt.wouldBeDepot ? '🚂' : '🚌'}</td>
        <td>${escapeHtml(pt.classificationReason)}</td>
        <td>${stopsHtml}</td>
      </tr>`;
}).join('\n')}
    </tbody>
  </table>

  <p style="margin-top: 20px; color: #666; font-size: 11px;">
    Generated at: ${new Date().toISOString()}<br>
    Yellow background = trips that would be filtered out when "Show All Trips" is OFF
  </p>
</body>
</html>`;

      // 6. Download HTML file
      const filename = `debug_trips_${routeId.replace(/[^a-zA-Z0-9]/g, '_')}_dir${direction}_${state.selectedDate}.html`;
      const blob = new Blob([html], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);

      // 7. Console output
      console.log('✅ Debug HTML exported!');
      console.log(`📄 Filename: ${filename}`);
      console.log(`📊 Total trips: ${processedTrips.length}`);
      console.log(`✅ Active on ${state.selectedDate}: ${processedTrips.filter(t => t.activeOnDate).length}`);
      console.log(`🚫 Would be filtered: ${processedTrips.filter(t => t.wouldBeFiltered).length}`);
      console.log(`🚂 Depot trips: ${processedTrips.filter(t => t.wouldBeDepot).length}`);
      console.log(`🚌 Normal service trips: ${processedTrips.filter(t => !t.wouldBeDepot).length}`);
    };
  </script>
</body>
</html>
